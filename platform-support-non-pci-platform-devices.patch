Return-Path: <robdclark@gmail.com>
X-Original-To: dennis@ausil.us
Delivered-To: dennis@ausil.us
Received: from localhost (unknown [127.0.0.1])
	by mail.ausil.us (Postfix) with ESMTP id 6B14F2E021E
	for <dennis@ausil.us>; Mon, 16 Jun 2014 18:13:57 +0000 (UTC)
X-Virus-Scanned: amavisd-new at ausil.us
Authentication-Results: mail02.ausil.us (amavisd-new);
	dkim=pass (2048-bit key) header.d=gmail.com
Received: from mail.ausil.us ([127.0.0.1])
	by localhost (mail02.ausil.us [127.0.0.1]) (amavisd-new, port 10024)
	with ESMTP id Z0kSi2KBV9uu for <dennis@ausil.us>;
	Mon, 16 Jun 2014 18:13:40 +0000 (GMT)
X-Greylist: whitelisted by SQLgrey-1.8.0
Received: from mail-qc0-x22e.google.com (mail-qc0-x22e.google.com [IPv6:2607:f8b0:400d:c01::22e])
	(using TLSv1 with cipher ECDHE-RSA-RC4-SHA (128/128 bits))
	(No client certificate requested)
	by mail.ausil.us (Postfix) with ESMTPS id 8DA682E024F
	for <dennis@ausil.us>; Mon, 16 Jun 2014 18:13:38 +0000 (GMT)
Received: by mail-qc0-f174.google.com with SMTP id x13so8164787qcv.5
        for <dennis@ausil.us>; Mon, 16 Jun 2014 11:13:36 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20120113;
        h=from:to:cc:subject:date:message-id:in-reply-to:references;
        bh=6VVOWdKY9pK2dBxdOSDqYcBMYVy4/+VDTxfgBepvrAI=;
        b=MAKBIQ9TJrWGjVzYWsHECticUkQa0+TS5frl+oQnrCPULnqXN+rYmsx5HvCzVexJtm
         fChdHXt/IxeAUjBH56HD3X9mkf6Pn+U2TkjUOmMJBm2q2tYgE2fYHCTDnsDYk3oMRlVP
         abSXoAiURG2fODA3sPTQaAnn2Ojfvk6jzTQnN7X327u+0rA/aVjNC4u3IIcd5Cj7lo2I
         dVnzPqxdKQoSDFAfpr2mC8pKoQzSabQw3TdCMrryGjN9enNnS+V5+5Sv6MIbrGotW/k5
         2O2GkTR08WpNO/Ae1NJQYRW3QfL1UGZE/GCsDW8KYS8C91mWwXcsN+QHnx92hA9K2YVU
         eerg==
X-Received: by 10.140.81.16 with SMTP id e16mr6124036qgd.110.1402942414050;
        Mon, 16 Jun 2014 11:13:34 -0700 (PDT)
Received: from localhost (pool-108-20-245-130.bstnma.east.verizon.net. [108.20.245.130])
        by mx.google.com with ESMTPSA id d2sm1375720qge.24.2014.06.16.11.13.32
        for <multiple recipients>
        (version=TLSv1.2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Mon, 16 Jun 2014 11:13:33 -0700 (PDT)
From: Rob Clark <robdclark@gmail.com>
To: xorg-devel@lists.x.org
Cc: Dennis Gilmore <dennis@ausil.us>,
	Dave Airlie <airlied@gmail.com>,
	Thierry Reding <thierry.reding@gmail.com>,
	Rob Clark <robdclark@gmail.com>
Subject: [PATCH 1/2] platform: support non-pci platform devices
Date: Mon, 16 Jun 2014 14:13:16 -0400
Message-Id: <1402942397-16427-2-git-send-email-robdclark@gmail.com>
X-Mailer: git-send-email 1.9.3
In-Reply-To: <1402942397-16427-1-git-send-email-robdclark@gmail.com>
References: <1402942397-16427-1-git-send-email-robdclark@gmail.com>

This makes things not completely fail if DDX implements platformProbe()
but the device is not actually a PCI device.  Also, the platform device
name does not always match the DDX name, so deal with that.  I'm sure
there are more cases that find_non_pci_driver() needs to handle for
that, but this is a start.

Signed-off-by: Rob Clark <robdclark@gmail.com>
Reviewed-by: Hans de Goede <hdegoede@redhat.com>
---
 hw/xfree86/common/xf86platformBus.c | 65 ++++++++++++++++++++++++++++++++++---
 1 file changed, 61 insertions(+), 4 deletions(-)

diff --git a/hw/xfree86/common/xf86platformBus.c b/hw/xfree86/common/xf86platformBus.c
index dd118a2..eca0f8c 100644
--- a/hw/xfree86/common/xf86platformBus.c
+++ b/hw/xfree86/common/xf86platformBus.c
@@ -199,6 +199,41 @@ xf86_check_platform_slot(const struct xf86_platform_device *pd)
     return TRUE;
 }
 
+static int
+find_non_pci_driver(const char *busid, char *returnList[], int returnListMax)
+{
+    /* Add more entries here if we ever return more than 4 drivers for
+       any device */
+    const char *driverList[5] = { NULL, NULL, NULL, NULL, NULL };
+    int i = 0;
+    char *p, *s;
+
+    s = xstrdup(busid);
+    p = strtok(s, ":");
+
+    if (strcmp(p, "platform"))
+        goto out;
+
+    /* extract device name: */
+    p = strtok(NULL, ":");
+
+    /* check for special cases where DDX driver name does not match busid: */
+    if (!strcmp(p, "mdp")) {
+        driverList[i++] = "freedreno";
+    }
+
+    /* add name derived from busid last: */
+    driverList[i++] = p;
+
+    for (i = 0; (i < returnListMax) && (driverList[i] != NULL); i++) {
+        returnList[i] = xnfstrdup(driverList[i]);
+    }
+
+out:
+    free(s);
+    return i;                   /* Number of entries added */
+}
+
 /**
  *  @return The numbers of found devices that match with the current system
  *  drivers.
@@ -230,6 +265,9 @@ xf86PlatformMatchDriver(char *matches[], int nmatches)
 
             if ((info != NULL) && (j < nmatches)) {
                 j += xf86VideoPtrToDriverList(info, &(matches[j]), nmatches - j);
+            } else if (j < nmatches) {
+                char *busid = xf86_get_platform_attrib(i, ODEV_ATTRIB_BUSID);
+                j += find_non_pci_driver(busid, &(matches[j]), nmatches - j);
             }
         }
     }
@@ -248,6 +286,9 @@ xf86platformProbe(void)
         pci = FALSE;
     }
 
+    /* First pass, look for PCI devices.  If we find a suitable
+     * PCI device that takes priority.
+     */
     for (i = 0; i < xf86_num_platform_devices; i++) {
         char *busid = xf86_get_platform_attrib(i, ODEV_ATTRIB_BUSID);
 
@@ -255,6 +296,24 @@ xf86platformProbe(void)
             platform_find_pci_info(&xf86_platform_devices[i], busid);
         }
     }
+
+    /* if we found something, we are done: */
+    if (primaryBus.type != BUS_NONE)
+        return 0;
+
+    /* Second pass, look for real platform devices (ie. in the linux-
+     * kernel sense of platform device.. something that is not pci)
+     */
+    for (i = 0; i < xf86_num_platform_devices; i++) {
+        char *busid = xf86_get_platform_attrib(i, ODEV_ATTRIB_BUSID);
+
+        if (strncmp(busid, "platform:", 9) == 0) {
+            primaryBus.type = BUS_PLATFORM;
+            primaryBus.id.plat = &xf86_platform_devices[i];
+            break;
+        }
+    }
+
     return 0;
 }
 
@@ -401,10 +460,8 @@ xf86platformProbeDev(DriverPtr drvp)
                 /* for non-seat0 servers assume first device is the master */
                 if (ServerIsNotSeat0())
                     break;
-                if (xf86_platform_devices[j].pdev) {
-                    if (xf86IsPrimaryPlatform(&xf86_platform_devices[j]))
-                        break;
-                }
+                if (xf86IsPrimaryPlatform(&xf86_platform_devices[j]))
+                    break;
             }
         }
 
-- 
1.9.3

