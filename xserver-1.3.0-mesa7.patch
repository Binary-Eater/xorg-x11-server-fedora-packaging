diff --git a/GL/apple/Makefile.am b/GL/apple/Makefile.am
new file mode 100644
index 0000000..2b2d10c
--- /dev/null
+++ b/GL/apple/Makefile.am
@@ -0,0 +1,15 @@
+AM_CFLAGS = -I$(top_srcdir) \
+	 -I$(top_srcdir)/hw/darwin/quartz \
+	 -I$(top_srcdir)/GL/glx \
+	 -I$(top_srcdir)/hw/darwin/quartz/cr \
+	 -I$(top_srcdir)/GL/include
+
+if HAVE_AGL_FRAMEWORK
+noinst_LIBRARIES = libAGLcore.a 
+libAGLcore_a_SOURCES = aglGlx.c \
+		       $(top_srcdir)/hw/darwin/quartz/xpr/x-list.c \
+		       $(top_srcdir)/hw/darwin/quartz/xpr/x-list.h \
+		       $(top_srcdir)/hw/darwin/quartz/xpr/x-hash.c \
+		       $(top_srcdir)/hw/darwin/quartz/xpr/x-hash.h \
+		       $(top_srcdir)/hw/dmx/glxProxy/compsize.c
+endif
diff --git a/GL/apple/indirect.c b/GL/apple/indirect.c
index 8cba1c6..ba54186 100644
--- a/GL/apple/indirect.c
+++ b/GL/apple/indirect.c
@@ -1,11 +1,10 @@
 /*
  * GLX implementation that uses Apple's OpenGL.framework
  * (Indirect rendering path)
- */
-/*
- * Copyright (c) 2002 Greg Parker. All Rights Reserved.
- * Copyright (c) 2002 Apple Computer, Inc.
+ *
+ * Copyright (c) 2007 Apple Inc.
  * Copyright (c) 2004 Torrey T. Lyons. All Rights Reserved.
+ * Copyright (c) 2002 Greg Parker. All Rights Reserved.
  *
  * Portions of this file are copied from Mesa's xf86glx.c,
  * which contains the following copyright:
@@ -39,11 +38,12 @@
 #include "dri.h"
 #include "quartz.h"
 
-#include <CoreGraphics/CoreGraphics.h>
+//#include <CoreGraphics/CoreGraphics.h>
 #include <OpenGL/OpenGL.h>
 #include <OpenGL/CGLContext.h>
 
 // X11 and X11's glx
+#include <GL/gl.h>
 #include <miscstruct.h>
 #include <windowstr.h>
 #include <resource.h>
@@ -61,11 +61,16 @@
 #include "x-hash.h"
 #include "x-list.h"
 
+#include <dispatch.h>
+
 #include "glcontextmodes.h"
+#include <glapi.h>
+#include <glapitable.h>
 
 // ggs: needed to call back to glx with visual configs
 extern void GlxSetVisualConfigs(int nconfigs, __GLXvisualConfig *configs, void **configprivs);
 
+#define GLAQUA_DEBUG 1
 
 // Write debugging output, or not
 #ifdef GLAQUA_DEBUG
@@ -74,182 +79,163 @@ extern void GlxSetVisualConfigs(int nconfigs, __GLXvisualConfig *configs, void *
 #define GLAQUA_DEBUG_MSG(a, ...)
 #endif
 
-
-// The following GL functions don't have an EXT suffix in OpenGL.framework.
-GLboolean glAreTexturesResidentEXT(GLsizei a, const GLuint *b, GLboolean *c) {
-    return glAreTexturesResident(a, b, c);
-}
-void glDeleteTexturesEXT(GLsizei d, const GLuint *e) {
-    glDeleteTextures(d, e);
-}
-void glGenTexturesEXT(GLsizei f, GLuint *g) {
-    glGenTextures(f, g);
-}
-GLboolean glIsTextureEXT(GLuint h) {
-    return glIsTexture(h);
-}
+static void setup_dispatch_table(void);
 
 // some prototypes
-static Bool glAquaScreenProbe(int screen);
+static __GLXscreen * __glXAquaScreenProbe(ScreenPtr pScreen);
 static Bool glAquaInitVisuals(VisualPtr *visualp, DepthPtr *depthp,
                               int *nvisualp, int *ndepthp,
                               int *rootDepthp, VisualID *defaultVisp,
                               unsigned long sizes, int bitsPerRGB);
 static void glAquaSetVisualConfigs(int nconfigs, __GLXvisualConfig *configs,
                                    void **privates);
+
 static __GLinterface *glAquaCreateContext(__GLimports *imports,
                                           __GLcontextModes *mode,
                                           __GLinterface *shareGC);
-static void glAquaCreateBuffer(__GLXdrawablePrivate *glxPriv);
 static void glAquaResetExtension(void);
-
-/*
- * This structure is statically allocated in the __glXScreens[]
- * structure.  This struct is not used anywhere other than in
- * __glXScreenInit to initialize each of the active screens
- * (__glXActiveScreens[]).  Several of the fields must be initialized by
- * the screenProbe routine before they are copied to the active screens
- * struct.  In particular, the contextCreate, modes, numVisuals,
- * and numUsableVisuals fields must be initialized.
- */
-static __GLXscreenInfo __glDDXScreenInfo = {
-    glAquaScreenProbe,   /* Must be generic and handle all screens */
-    glAquaCreateContext, /* Substitute screen's createContext routine */
-    glAquaCreateBuffer,  /* Substitute screen's createBuffer routine */
-    NULL,                 /* Set up modes in probe */
-    NULL,                 /* Set up pVisualPriv in probe */
-    0,                    /* Set up numVisuals in probe */
-    0,                    /* Set up numUsableVisuals in probe */
-    "Vendor String",      /* GLXvendor is overwritten by __glXScreenInit */
-    "Version String",     /* GLXversion is overwritten by __glXScreenInit */
-    "Extensions String",  /* GLXextensions is overwritten by __glXScreenInit */
-    NULL                  /* WrappedPositionWindow is overwritten */
-};
-
-void *__glXglDDXScreenInfo(void) {
-    return &__glDDXScreenInfo;
-}
-
-static __GLXextensionInfo __glDDXExtensionInfo = {
-    GL_CORE_APPLE,
-    glAquaResetExtension,
-    glAquaInitVisuals,
-    glAquaSetVisualConfigs
+static void __glXAquaContextDestroy(__GLXcontext *baseContext);
+static int __glXAquaContextMakeCurrent(__GLXcontext *baseContext);
+static int __glXAquaContextLoseCurrent(__GLXcontext *baseContext);
+static int __glXAquaContextForceCurrent(__GLXcontext *baseContext);
+static int __glXAquaContextCopy(__GLXcontext *baseDst, __GLXcontext *baseSrc, unsigned long mask);
+static __GLXdrawable * __glXAquaContextCreateDrawable(__GLXcontext *context, DrawablePtr pDraw, XID drawId);
+
+static CGLPixelFormatObj makeFormat(__GLcontextModes *mode);
+
+__GLXprovider __glXMesaProvider = {
+  __glXAquaScreenProbe,
+  "Core OpenGL",
+    NULL
 };
 
-void *__glXglDDXExtensionInfo(void) {
-    return &__glDDXExtensionInfo;
+__GLXprovider *
+GlxGetMesaProvider (void)
+{
+  ErrorF("GlxGetMesaProvider\n");
+  return &__glXMesaProvider;
 }
 
-// prototypes
+typedef struct __GLXAquaScreen   __GLXAquaScreen;
+typedef struct __GLXAquaContext  __GLXAquaContext;
+typedef struct __GLXAquaDrawable __GLXAquaDrawable;
 
-static GLboolean glAquaDestroyContext(__GLcontext *gc);
-static GLboolean glAquaLoseCurrent(__GLcontext *gc);
-static GLboolean glAquaMakeCurrent(__GLcontext *gc);
-static GLboolean glAquaShareContext(__GLcontext *gc, __GLcontext *gcShare);
-static GLboolean glAquaCopyContext(__GLcontext *dst, const __GLcontext *src,
-                                    GLuint mask);
-static GLboolean glAquaForceCurrent(__GLcontext *gc);
-
-/* Drawing surface notification callbacks */
-static GLboolean glAquaNotifyResize(__GLcontext *gc);
-static void glAquaNotifyDestroy(__GLcontext *gc);
-static void glAquaNotifySwapBuffers(__GLcontext *gc);
-
-/* Dispatch table override control for external agents like libGLS */
-static struct __GLdispatchStateRec* glAquaDispatchExec(__GLcontext *gc);
-static void glAquaBeginDispatchOverride(__GLcontext *gc);
-static void glAquaEndDispatchOverride(__GLcontext *gc);
-
-static __GLexports glAquaExports = {
-    glAquaDestroyContext,
-    glAquaLoseCurrent,
-    glAquaMakeCurrent,
-    glAquaShareContext,
-    glAquaCopyContext,
-    glAquaForceCurrent,
-
-    glAquaNotifyResize,
-    glAquaNotifyDestroy,
-    glAquaNotifySwapBuffers,
-
-    glAquaDispatchExec,
-    glAquaBeginDispatchOverride,
-    glAquaEndDispatchOverride
-};
-
-typedef struct {
+struct __GLXAquaScreen {
+  __GLXscreen   base;
+  int           index;
     int num_vis;
     __GLcontextModes *modes;
-    void **priv;
+};
 
-    // wrapped screen functions
-    RealizeWindowProcPtr RealizeWindow;
-    UnrealizeWindowProcPtr UnrealizeWindow;
-} glAquaScreenRec;
+static __GLXAquaScreen glAquaScreens[MAXSCREENS];
 
-static glAquaScreenRec glAquaScreens[MAXSCREENS];
+struct __GLXAquaContext {
+  __GLXcontext base;
+  CGLContextObj ctx;
+  CGLPixelFormatObj pixelFormat;
+  xp_surface_id sid;
+  unsigned isAttached :1;
+};
 
-// __GLdrawablePrivate->private
-typedef struct {
+struct __GLXAquaDrawable {
+  __GLXdrawable base;
     DrawablePtr pDraw;
     xp_surface_id sid;
-} GLAquaDrawableRec;
-
-struct __GLcontextRec {
-    struct __GLinterfaceRec interface; // required to be first
-
-    CGLContextObj ctx;
-    CGLPixelFormatObj pixelFormat;
+};
 
-    /* set when attached */
-    xp_surface_id sid;
+static __GLXcontext *
+__glXAquaScreenCreateContext(__GLXscreen *screen,
+			     __GLcontextModes *modes,
+			     __GLXcontext *baseShareContext)
+{
+  __GLXAquaContext *context;
+  __GLXAquaContext *shareContext = (__GLXAquaContext *) baseShareContext;
+  CGLError gl_err;
+  
+  GLAQUA_DEBUG_MSG("glXAquaScreenCreateContext\n");
+
+  context = malloc (sizeof (__GLXAquaContext));
+  if (context == NULL) return NULL;
+
+  memset(context, 0, sizeof *context);
+
+  context->base.pGlxScreen = screen;
+  context->base.modes      = modes;
+
+  context->base.destroy        = __glXAquaContextDestroy;
+  context->base.makeCurrent    = __glXAquaContextMakeCurrent;
+  context->base.loseCurrent    = __glXAquaContextLoseCurrent;
+  context->base.copy           = __glXAquaContextCopy;
+  context->base.forceCurrent   = __glXAquaContextForceCurrent;
+  context->base.createDrawable = __glXAquaContextCreateDrawable;
+
+  context->pixelFormat = makeFormat(modes);
+  if (!context->pixelFormat) {
+        free(context);
+        return NULL;
+  }
+
+  context->ctx = NULL;
+  gl_err = CGLCreateContext(context->pixelFormat,
+                            shareContext ? shareContext->ctx : NULL,
+                            &context->ctx);
+
+  if (gl_err != 0) {
+      ErrorF("CGLCreateContext error: %s\n", CGLErrorString(gl_err));
+      CGLDestroyPixelFormat(context->pixelFormat);
+      free(context);
+      return NULL;
+    }
+	setup_dispatch_table();
+    GLAQUA_DEBUG_MSG("glAquaCreateContext done\n");
+  return &context->base;
+}
 
-    unsigned isAttached :1;
+static __GLXextensionInfo __glDDXExtensionInfo = {
+    GL_CORE_APPLE,
+    glAquaResetExtension,
+    glAquaInitVisuals,
+    glAquaSetVisualConfigs
 };
 
+void *__glXglDDXExtensionInfo(void) {
+  GLAQUA_DEBUG_MSG("glXAglDDXExtensionInfo\n");
+    return &__glDDXExtensionInfo;
+}
+
 /* maps from surface id -> list of __GLcontext */
 static x_hash_table *surface_hash;
 
-
-// Context manipulation; return GL_FALSE on failure
-static GLboolean glAquaDestroyContext(__GLcontext *gc)
-{
+static void __glXAquaContextDestroy(__GLXcontext *baseContext) {
     x_list *lst;
 
-    GLAQUA_DEBUG_MSG("glAquaDestroyContext (ctx 0x%x)\n",
-                     (unsigned int) gc->ctx);
+    __GLXAquaContext *context = (__GLXAquaContext *) baseContext;
 
-    if (gc != NULL)
-    {
-        if (gc->sid != 0 && surface_hash != NULL)
-        {
-            lst = x_hash_table_lookup(surface_hash, (void *) gc->sid, NULL);
-            lst = x_list_remove(lst, gc);
-            x_hash_table_insert(surface_hash, (void *) gc->sid, lst);
-        }
-
-        if (gc->ctx != NULL)
-            CGLDestroyContext(gc->ctx);
+    GLAQUA_DEBUG_MSG("glAquaContextDestroy (ctx 0x%x)\n",
+                     (unsigned int) baseContext);
+    if (context != NULL) {
+      if (context->sid != 0 && surface_hash != NULL) {
+		lst = x_hash_table_lookup(surface_hash, (void *) context->sid, NULL);
+		lst = x_list_remove(lst, context);
+		x_hash_table_insert(surface_hash, (void *) context->sid, lst);
+      }
 
-        if (gc->pixelFormat != NULL)
-            CGLDestroyPixelFormat(gc->pixelFormat);
+      if (context->ctx != NULL) CGLDestroyContext(context->ctx);
 
-        free(gc);
+      if (context->pixelFormat != NULL)	CGLDestroyPixelFormat(context->pixelFormat);
+      
+      free(context);
     }
-
-    return GL_TRUE;
 }
 
-static GLboolean glAquaLoseCurrent(__GLcontext *gc)
-{
+static int __glXAquaContextLoseCurrent(__GLXcontext *baseContext) {
     CGLError gl_err;
 
-    GLAQUA_DEBUG_MSG("glAquaLoseCurrent (ctx 0x%x)\n", (unsigned int) gc->ctx);
+    GLAQUA_DEBUG_MSG("glAquaLoseCurrent (ctx 0x%p)\n", baseContext);
 
     gl_err = CGLSetCurrentContext(NULL);
     if (gl_err != 0)
-        ErrorF("CGLSetCurrentContext error: %s\n", CGLErrorString(gl_err));
+      ErrorF("CGLSetCurrentContext error: %s\n", CGLErrorString(gl_err));
 
     __glXLastContext = NULL; // Mesa does this; why?
 
@@ -258,141 +244,139 @@ static GLboolean glAquaLoseCurrent(__GLcontext *gc)
 
 /* Called when a surface is destroyed as a side effect of destroying
    the window it's attached to. */
-static void surface_notify(void *_arg, void *data)
-{
-    DRISurfaceNotifyArg *arg = _arg;
-    GLAquaDrawableRec *aquaPriv = data;
-    __GLcontext *gc;
+static void surface_notify(void *_arg, void *data) {
+    DRISurfaceNotifyArg *arg = (DRISurfaceNotifyArg *)_arg;
+    __GLXAquaDrawable *draw = (__GLXAquaDrawable *)data;
+    __GLXAquaContext *context;
     x_list *lst;
-
-    switch (arg->kind)
-    {
+	if(_arg == NULL || data == NULL) {
+		ErrorF("surface_notify called with bad params");
+		return;
+	}
+	
+    GLAQUA_DEBUG_MSG("surface_notify(%p, %p)\n", _arg, data);
+    switch (arg->kind) {
     case AppleDRISurfaceNotifyDestroyed:
         if (surface_hash != NULL)
             x_hash_table_remove(surface_hash, (void *) arg->id);
-
-        aquaPriv->pDraw = NULL;
-        aquaPriv->sid = 0;
+	        draw->base->pDraw = NULL;
+			draw->sid = 0;
         break;
 
     case AppleDRISurfaceNotifyChanged:
-        if (surface_hash != NULL)
-        {
+        if (surface_hash != NULL) {
             lst = x_hash_table_lookup(surface_hash, (void *) arg->id, NULL);
             for (; lst != NULL; lst = lst->next)
             {
-                gc = lst->data;
-                xp_update_gl_context(gc->ctx);
+                context = lst->data;
+                xp_update_gl_context(context->ctx);
             }
         }
         break;
+	default:
+		ErrorF("surface_notify: unknown kind %d\n", arg->kind);
+		break;
     }
 }
 
-static void unattach(__GLcontext *gc)
-{
-    x_list *lst;
-
-    if (gc->isAttached)
-    {
-        GLAQUA_DEBUG_MSG("unattaching\n");
-
-        if (surface_hash != NULL)
-        {
-            lst = x_hash_table_lookup(surface_hash, (void *) gc->sid, NULL);
-            lst = x_list_remove(lst, gc);
-            x_hash_table_insert(surface_hash, (void *) gc->sid, lst);
-        }
-
-        CGLClearDrawable(gc->ctx);
-        gc->isAttached = FALSE;
-        gc->sid = 0;
-    }
-}
-
-static void attach(__GLcontext *gc, __GLdrawablePrivate *glPriv)
-{
-    __GLXdrawablePrivate *glxPriv;
-    GLAquaDrawableRec *aquaPriv;
+static void attach(__GLXAquaContext *context, __GLXAquaDrawable *draw) {
     DrawablePtr pDraw;
-
-    glxPriv = (__GLXdrawablePrivate *)glPriv->other;
-    aquaPriv = (GLAquaDrawableRec *)glPriv->private;
-    pDraw = glxPriv->pDraw;
-
-    if (aquaPriv->sid == 0)
-    {
-        if (!quartzProcs->CreateSurface(pDraw->pScreen, pDraw->id, pDraw,
-                                        0, &aquaPriv->sid, NULL,
-                                        surface_notify, aquaPriv))
-        {
+	GLAQUA_DEBUG_MSG("attach(%p, %p)\n", context, draw);
+    pDraw = draw->base.pDraw;
+
+    if (draw->sid == 0) {
+//        if (!quartzProcs->CreateSurface(pDraw->pScreen, pDraw->id, pDraw,
+        if (!DRICreateSurface(pDraw->pScreen, pDraw->id, pDraw,
+                                        0, &draw->sid, NULL,
+                                        surface_notify, draw))
             return;
-        }
-        aquaPriv->pDraw = pDraw;
-    }
+        draw->pDraw = pDraw;
+	} 
 
-    if (!gc->isAttached || gc->sid != aquaPriv->sid)
-    {
+    if (!context->isAttached || context->sid != draw->sid) {
         x_list *lst;
 
-        if (xp_attach_gl_context(gc->ctx, aquaPriv->sid) != Success)
-        {
-            quartzProcs->DestroySurface(pDraw->pScreen, pDraw->id, pDraw,
-                                        surface_notify, aquaPriv);
+        if (xp_attach_gl_context(context->ctx, draw->sid) != Success) {
+//            quartzProcs->DestroySurface(pDraw->pScreen, pDraw->id, pDraw,
+            DRIDestroySurface(pDraw->pScreen, pDraw->id, pDraw,
+								surface_notify, draw);
             if (surface_hash != NULL)
-                x_hash_table_remove(surface_hash, (void *) aquaPriv->sid);
+                x_hash_table_remove(surface_hash, (void *) draw->sid);
 
-            aquaPriv->sid = 0;
+            draw->sid = 0;
             return;
         }
 
-        gc->isAttached = TRUE;
-        gc->sid = aquaPriv->sid;
+        context->isAttached = TRUE;
+        context->sid = draw->sid;
 
         if (surface_hash == NULL)
             surface_hash = x_hash_table_new(NULL, NULL, NULL, NULL);
 
-        lst = x_hash_table_lookup(surface_hash, (void *) gc->sid, NULL);
-        if (x_list_find(lst, gc) == NULL)
-        {
-            lst = x_list_prepend(lst, gc);
-            x_hash_table_insert(surface_hash, (void *) gc->sid, lst);
+        lst = x_hash_table_lookup(surface_hash, (void *) context->sid, NULL);
+        if (x_list_find(lst, context) == NULL) {
+            lst = x_list_prepend(lst, context);
+            x_hash_table_insert(surface_hash, (void *) context->sid, lst);
         }
 
         GLAQUA_DEBUG_MSG("attached 0x%x to 0x%x\n", (unsigned int) pDraw->id,
-                         (unsigned int) aquaPriv->sid);
+                         (unsigned int) draw->sid);
+    } 
+}
+
+static void unattach(__GLXAquaContext *context) {
+	x_list *lst;
+	GLAQUA_DEBUG_MSG("unattach\n");
+	if (context == NULL) {
+		ErrorF("Tried to unattach a null context\n");
+		return;
+	}
+    if (context->isAttached) {
+        GLAQUA_DEBUG_MSG("unattaching\n");
+
+        if (surface_hash != NULL) {
+            lst = x_hash_table_lookup(surface_hash, (void *) context->sid, NULL);
+            lst = x_list_remove(lst, context);
+            x_hash_table_insert(surface_hash, (void *) context->sid, lst);
+        }
+
+        CGLClearDrawable(context->ctx);
+        context->isAttached = FALSE;
+        context->sid = 0;
     }
 }
 
-static GLboolean glAquaMakeCurrent(__GLcontext *gc)
-{
-    __GLdrawablePrivate *glPriv = gc->interface.imports.getDrawablePrivate(gc);
+static int __glXAquaContextMakeCurrent(__GLXcontext *baseContext) {
     CGLError gl_err;
+    __GLXAquaContext *context = (__GLXAquaContext *) baseContext;
+	__GLXAquaDrawable *drawPriv = (__GLXAquaDrawable *) context->base.drawPriv;
+    __GLXAquaDrawable *readPriv = (__GLXAquaDrawable *) context->base.readPriv;
 
-    GLAQUA_DEBUG_MSG("glAquaMakeCurrent (ctx 0x%x)\n", (unsigned int) gc->ctx);
-
-    attach(gc, glPriv);
+    GLAQUA_DEBUG_MSG("glAquaMakeCurrent (ctx 0x%p)\n", baseContext);
+    
+    attach(context, drawPriv);
 
-    gl_err = CGLSetCurrentContext(gc->ctx);
+    gl_err = CGLSetCurrentContext(context->ctx);
     if (gl_err != 0)
         ErrorF("CGLSetCurrentContext error: %s\n", CGLErrorString(gl_err));
-
+    
     return gl_err == 0;
 }
 
 static GLboolean glAquaShareContext(__GLcontext *gc, __GLcontext *gcShare)
 {
   GLAQUA_DEBUG_MSG("glAquaShareContext unimplemented\n");
-
   return GL_TRUE;
 }
 
-static GLboolean glAquaCopyContext(__GLcontext *dst, const __GLcontext *src,
-                                   GLuint mask)
+static int __glXAquaContextCopy(__GLXcontext *baseDst, __GLXcontext *baseSrc, unsigned long mask)
 {
     CGLError gl_err;
 
-    GLAQUA_DEBUG_MSG("glAquaCopyContext\n");
+    __GLXAquaContext *dst = (__GLXAquaContext *) baseDst;
+    __GLXAquaContext *src = (__GLXAquaContext *) baseSrc;
+
+    GLAQUA_DEBUG_MSG("GLXAquaContextCopy\n");
 
     gl_err = CGLCopyContext(src->ctx, dst->ctx, mask);
     if (gl_err != 0)
@@ -401,14 +385,13 @@ static GLboolean glAquaCopyContext(__GLcontext *dst, const __GLcontext *src,
     return gl_err == 0;
 }
 
-static GLboolean glAquaForceCurrent(__GLcontext *gc)
+static int __glXAquaContextForceCurrent(__GLXcontext *baseContext)
 {
     CGLError gl_err;
+    __GLXAquaContext *context = (__GLXAquaContext *) baseContext;
+    GLAQUA_DEBUG_MSG("glAquaForceCurrent (ctx %p)\n", context->ctx);
 
-    GLAQUA_DEBUG_MSG("glAquaForceCurrent (ctx 0x%x)\n",
-                     (unsigned int) gc->ctx);
-
-    gl_err = CGLSetCurrentContext(gc->ctx);
+    gl_err = CGLSetCurrentContext(context->ctx);
     if (gl_err != 0)
         ErrorF("CGLSetCurrentContext error: %s\n", CGLErrorString(gl_err));
 
@@ -417,45 +400,41 @@ static GLboolean glAquaForceCurrent(__GLcontext *gc)
 
 /* Drawing surface notification callbacks */
 
-static GLboolean glAquaNotifyResize(__GLcontext *gc)
-{
-    GLAQUA_DEBUG_MSG("unimplemented glAquaNotifyResize");
+static GLboolean __glXAquaDrawableResize(__GLXdrawable *base)  {
+    GLAQUA_DEBUG_MSG("unimplemented glAquaDrawableResize\n");
     return GL_TRUE;
 }
 
-static void glAquaNotifyDestroy(__GLcontext *gc)
-{
+static void glAquaNotifyDestroy(__GLcontext *gc) {
     GLAQUA_DEBUG_MSG("unimplemented glAquaNotifyDestroy");
 }
 
-static void glAquaNotifySwapBuffers(__GLcontext *gc)
-{
-    GLAQUA_DEBUG_MSG("unimplemented glAquaNotifySwapBuffers");
-}
-
-/* Dispatch table override control for external agents like libGLS */
-static struct __GLdispatchStateRec* glAquaDispatchExec(__GLcontext *gc)
-{
-    GLAQUA_DEBUG_MSG("unimplemented glAquaDispatchExec");
-    return NULL;
-}
-
-static void glAquaBeginDispatchOverride(__GLcontext *gc)
-{
-    GLAQUA_DEBUG_MSG("unimplemented glAquaBeginDispatchOverride");
-}
-
-static void glAquaEndDispatchOverride(__GLcontext *gc)
-{
-    GLAQUA_DEBUG_MSG("unimplemented glAquaEndDispatchOverride");
+static GLboolean __glXAquaDrawableSwapBuffers(__GLXdrawable *base) {
+    __GLXAquaDrawable *glxPriv = (__GLXAquaDrawable *) base;
+    CGLError gl_err;
+	__GLXAquaContext * drawableCtx;
+//    GLAQUA_DEBUG_MSG("glAquaDrawableSwapBuffers(%p)\n",base);
+	
+	if(!base) {
+		ErrorF("glXAquaDrawbleSwapBuffers passed NULL\n");
+	    return GL_FALSE;
+	}
+
+    drawableCtx = (__GLXAquaContext *)base->drawGlxc;
+
+    if (drawableCtx != NULL && drawableCtx->ctx != NULL) {
+        gl_err = CGLFlushDrawable(drawableCtx->ctx);
+        if (gl_err != 0)
+            ErrorF("CGLFlushDrawable error: %s\n", CGLErrorString(gl_err));
+    }
+    return GL_TRUE;
 }
 
-static CGLPixelFormatObj makeFormat(__GLcontextModes *mode)
-{
+static CGLPixelFormatObj makeFormat(__GLcontextModes *mode) {
     int i;
     CGLPixelFormatAttribute attr[64]; // currently uses max of 30
     CGLPixelFormatObj result;
-    long n_formats;
+    GLint n_formats;
     CGLError gl_err;
     
     GLAQUA_DEBUG_MSG("makeFormat\n");
@@ -491,10 +470,12 @@ static CGLPixelFormatObj makeFormat(__GLcontextModes *mode)
         attr[i++] = mode->accumRedBits + mode->accumGreenBits
                     + mode->accumBlueBits + mode->accumAlphaBits;
     }
+	
     if (mode->haveDepthBuffer) {
         attr[i++] = kCGLPFADepthSize;
         attr[i++] = mode->depthBits;
     }
+	
     if (mode->haveStencilBuffer) {
         attr[i++] = kCGLPFAStencilSize;
         attr[i++] = mode->stencilBits;
@@ -521,129 +502,6 @@ static CGLPixelFormatObj makeFormat(__GLcontextModes *mode)
     return result;
 }
 
-static __GLinterface *glAquaCreateContext(__GLimports *imports,
-                                          __GLcontextModes *mode,
-                                          __GLinterface *shareGC)
-{
-    __GLcontext *result;
-    __GLcontext *sharectx = (__GLcontext *)shareGC;
-    CGLError gl_err;
-
-    GLAQUA_DEBUG_MSG("glAquaCreateContext\n");
-
-    result = (__GLcontext *)calloc(1, sizeof(__GLcontext));
-    if (!result) return NULL;
-
-    result->interface.imports = *imports;
-    result->interface.exports = glAquaExports;
-
-    result->pixelFormat = makeFormat(mode);
-    if (!result->pixelFormat) {
-        free(result);
-        return NULL;
-    }
-
-    result->ctx = NULL;
-    gl_err = CGLCreateContext(result->pixelFormat,
-                              sharectx ? sharectx->ctx : NULL,
-                              &result->ctx);
-
-    if (gl_err != 0) {
-        ErrorF("CGLCreateContext error: %s\n", CGLErrorString(gl_err));
-        CGLDestroyPixelFormat(result->pixelFormat);
-        free(result);
-        return NULL;
-    }
-
-    GLAQUA_DEBUG_MSG("glAquaCreateContext done\n");
-    return (__GLinterface *)result;
-}
-
-Bool
-glAquaRealizeWindow(WindowPtr pWin)
-{
-    // If this window has GL contexts, tell them to reattach
-    Bool result;
-    ScreenPtr pScreen = pWin->drawable.pScreen;
-    glAquaScreenRec *screenPriv = &glAquaScreens[pScreen->myNum];
-    __GLXdrawablePrivate *glxPriv;
-
-    GLAQUA_DEBUG_MSG("glAquaRealizeWindow\n");
-
-    // Allow the window to be created (RootlessRealizeWindow is inside our wrap)
-    pScreen->RealizeWindow = screenPriv->RealizeWindow;
-    result = pScreen->RealizeWindow(pWin);
-    pScreen->RealizeWindow = glAquaRealizeWindow;
-
-    // The Aqua window will already have been created (windows are
-    // realized from top down)
-
-    // Re-attach this window's GL contexts, if any.
-    glxPriv = __glXFindDrawablePrivate(pWin->drawable.id);
-    if (glxPriv) {
-        __GLXcontext *gx;
-        __GLcontext *gc;
-        __GLdrawablePrivate *glPriv = &glxPriv->glPriv;
-        GLAQUA_DEBUG_MSG("glAquaRealizeWindow is GL drawable!\n");
-
-        // GL contexts bound to this window for drawing
-        for (gx = glxPriv->drawGlxc; gx != NULL; gx = gx->next) {
-            gc = (__GLcontext *)gx->gc;
-            attach(gc, glPriv);
-        }
-
-        // GL contexts bound to this window for reading
-        for (gx = glxPriv->readGlxc; gx != NULL; gx = gx->next) {
-            gc = (__GLcontext *)gx->gc;
-            attach(gc, glPriv);
-        }
-    }
-
-    return result;
-}
-
-Bool
-glAquaUnrealizeWindow(WindowPtr pWin)
-{
-    // If this window has GL contexts, tell them to unattach
-    Bool result;
-    ScreenPtr pScreen = pWin->drawable.pScreen;
-    glAquaScreenRec *screenPriv = &glAquaScreens[pScreen->myNum];
-    __GLXdrawablePrivate *glxPriv;
-
-    GLAQUA_DEBUG_MSG("glAquaUnrealizeWindow\n");
-
-    // The Aqua window may have already been destroyed (windows
-    // are unrealized from top down)
-
-    // Unattach this window's GL contexts, if any.
-    glxPriv = __glXFindDrawablePrivate(pWin->drawable.id);
-    if (glxPriv) {
-        __GLXcontext *gx;
-        __GLcontext *gc;
-        GLAQUA_DEBUG_MSG("glAquaUnealizeWindow is GL drawable!\n");
-
-        // GL contexts bound to this window for drawing
-        for (gx = glxPriv->drawGlxc; gx != NULL; gx = gx->next) {
-            gc = (__GLcontext *)gx->gc;
-            unattach(gc);
-        }
-
-        // GL contexts bound to this window for reading
-        for (gx = glxPriv->readGlxc; gx != NULL; gx = gx->next) {
-            gc = (__GLcontext *)gx->gc;
-            unattach(gc);
-        }
-    }
-
-    pScreen->UnrealizeWindow = screenPriv->UnrealizeWindow;
-    result = pScreen->UnrealizeWindow(pWin);
-    pScreen->UnrealizeWindow = glAquaUnrealizeWindow;
-
-    return result;
-}
-
-
 // Originally copied from Mesa
 
 static int                 numConfigs     = 0;
@@ -821,15 +679,15 @@ static Bool init_visuals(int *nvisualp, VisualPtr *visualp,
 
     /* Alloc space for the list of new GLX visuals */
     pNewVisualConfigs = (__GLXvisualConfig *)
-                     __glXMalloc(numNewConfigs * sizeof(__GLXvisualConfig));
+                     malloc(numNewConfigs * sizeof(__GLXvisualConfig));
     if (!pNewVisualConfigs) {
         return FALSE;
     }
 
     /* Alloc space for the list of new GLX visual privates */
-    pNewVisualPriv = (void **) __glXMalloc(numNewConfigs * sizeof(void *));
+    pNewVisualPriv = (void **) malloc(numNewConfigs * sizeof(void *));
     if (!pNewVisualPriv) {
-        __glXFree(pNewVisualConfigs);
+        free(pNewVisualConfigs);
         return FALSE;
     }
 
@@ -879,40 +737,40 @@ static Bool init_visuals(int *nvisualp, VisualPtr *visualp,
     numConfigs = 0;
 
     /* Alloc temp space for the list of orig VisualIDs for each new visual */
-    orig_vid = (VisualID *)__glXMalloc(numNewVisuals * sizeof(VisualID));
+    orig_vid = (VisualID *)malloc(numNewVisuals * sizeof(VisualID));
     if (!orig_vid) {
-        __glXFree(pNewVisualPriv);
-        __glXFree(pNewVisualConfigs);
+        free(pNewVisualPriv);
+        free(pNewVisualConfigs);
         return FALSE;
     }
 
     /* Alloc space for the list of glXVisuals */
     modes = _gl_context_modes_create(numNewVisuals, sizeof(__GLcontextModes));
     if (modes == NULL) {
-        __glXFree(orig_vid);
-        __glXFree(pNewVisualPriv);
-        __glXFree(pNewVisualConfigs);
+        free(orig_vid);
+        free(pNewVisualPriv);
+        free(pNewVisualConfigs);
         return FALSE;
     }
 
     /* Alloc space for the list of glXVisualPrivates */
-    glXVisualPriv = (void **)__glXMalloc(numNewVisuals * sizeof(void *));
+    glXVisualPriv = (void **)malloc(numNewVisuals * sizeof(void *));
     if (!glXVisualPriv) {
         _gl_context_modes_destroy( modes );
-        __glXFree(orig_vid);
-        __glXFree(pNewVisualPriv);
-        __glXFree(pNewVisualConfigs);
+        free(orig_vid);
+        free(pNewVisualPriv);
+        free(pNewVisualConfigs);
         return FALSE;
     }
 
     /* Alloc space for the new list of the X server's visuals */
-    pVisualNew = (VisualPtr)__glXMalloc(numNewVisuals * sizeof(VisualRec));
+    pVisualNew = (VisualPtr)malloc(numNewVisuals * sizeof(VisualRec));
     if (!pVisualNew) {
-        __glXFree(glXVisualPriv);
+        free(glXVisualPriv);
         _gl_context_modes_destroy( modes );
-        __glXFree(orig_vid);
-        __glXFree(pNewVisualPriv);
-        __glXFree(pNewVisualConfigs);
+        free(orig_vid);
+        free(pNewVisualPriv);
+        free(pNewVisualConfigs);
         return FALSE;
     }
 
@@ -1007,7 +865,7 @@ static Bool init_visuals(int *nvisualp, VisualPtr *visualp,
 
     /* Save the GLX visuals in the screen structure */
     glAquaScreens[screenInfo.numScreens-1].num_vis = numNewVisuals;
-    glAquaScreens[screenInfo.numScreens-1].priv = glXVisualPriv;
+    //    glAquaScreens[screenInfo.numScreens-1].priv = glXVisualPriv;
 
     /* Set up depth's VisualIDs */
     for (i = 0; i < ndepth; i++) {
@@ -1022,7 +880,7 @@ static Bool init_visuals(int *nvisualp, VisualPtr *visualp,
                 numVids++;
 
         /* Allocate a new list of VisualIDs for this depth */
-        pVids = (VisualID *)__glXMalloc(numVids * sizeof(VisualID));
+        pVids = (VisualID *)malloc(numVids * sizeof(VisualID));
 
         /* Initialize the new list of VisualIDs for this depth */
         for (j = 0; j < pdepth[i].numVids; j++)
@@ -1031,7 +889,7 @@ static Bool init_visuals(int *nvisualp, VisualPtr *visualp,
                 pVids[n++] = pVisualNew[k].vid;
 
         /* Update this depth's list of VisualIDs */
-        __glXFree(pdepth[i].vids);
+        free(pdepth[i].vids);
         pdepth[i].vids = pVids;
         pdepth[i].numVids = numVids;
     }
@@ -1041,21 +899,22 @@ static Bool init_visuals(int *nvisualp, VisualPtr *visualp,
     *visualp = pVisualNew;
 
     /* Free the old list of the X server's visuals */
-    __glXFree(pVisual);
+    free(pVisual);
 
     /* Clean up temporary allocations */
-    __glXFree(orig_vid);
-    __glXFree(pNewVisualPriv);
-    __glXFree(pNewVisualConfigs);
+    free(orig_vid);
+    free(pNewVisualPriv);
+    free(pNewVisualConfigs);
 
     /* Free the private list created by DDX HW driver */
     if (visualPrivates)
-        xfree(visualPrivates);
+        free(visualPrivates);
     visualPrivates = NULL;
 
     return TRUE;
 }
 
+Bool enable_stereo = FALSE;
 /* based on code in i830_dri.c
    This ends calling glAquaSetVisualConfigs to set the static
    numconfigs, etc. */
@@ -1066,20 +925,22 @@ glAquaInitVisualConfigs(void)
     __GLXvisualConfig  *lclVisualConfigs  = NULL;
     void              **lclVisualPrivates = NULL;
 
-    int depth, aux, buffers, stencil, accum;
+    int stereo, depth, aux, buffers, stencil, accum;
     int i = 0;
 
     GLAQUA_DEBUG_MSG("glAquaInitVisualConfigs ");
         
     /* count num configs:
+        2 stereo (on, off) (optional)
         2 Z buffer (0, 24 bit)
         2 AUX buffer (0, 2)
         2 buffers (single, double)
         2 stencil (0, 8 bit)
         2 accum (0, 64 bit)
-        = 32 configs */
+        = 64 configs with stereo, or 32 without */
 
-    lclNumConfigs = 2 * 2 * 2 * 2 * 2; /* 32 */
+    if (enable_stereo) lclNumConfigs = 2 * 2 * 2 * 2 * 2 * 2; /* 64 */
+    else               lclNumConfigs = 2 * 2 * 2 * 2 * 2; /* 32 */
 
     /* alloc */
     lclVisualConfigs = xcalloc(sizeof(__GLXvisualConfig), lclNumConfigs);
@@ -1088,54 +949,55 @@ glAquaInitVisualConfigs(void)
     /* fill in configs */
     if (NULL != lclVisualConfigs) {
         i = 0; /* current buffer */
-        for (depth = 0; depth < 2; depth++) {
+        for (stereo = 0; stereo < (enable_stereo ? 2 : 1); stereo++) {
+	  for (depth = 0; depth < 2; depth++) {
             for (aux = 0; aux < 2; aux++) {
-                for (buffers = 0; buffers < 2; buffers++) {
-                    for (stencil = 0; stencil < 2; stencil++) {
-                        for (accum = 0; accum < 2; accum++) {
-                            lclVisualConfigs[i].vid = -1;
-                            lclVisualConfigs[i].class = -1;
-                            lclVisualConfigs[i].rgba = TRUE;
-                            lclVisualConfigs[i].redSize = -1;
-                            lclVisualConfigs[i].greenSize = -1;
-                            lclVisualConfigs[i].blueSize = -1;
-                            lclVisualConfigs[i].redMask = -1;
-                            lclVisualConfigs[i].greenMask = -1;
-                            lclVisualConfigs[i].blueMask = -1;
-                            lclVisualConfigs[i].alphaMask = 0;
-                            if (accum) {
-                                lclVisualConfigs[i].accumRedSize = 16;
-                                lclVisualConfigs[i].accumGreenSize = 16;
-                                lclVisualConfigs[i].accumBlueSize = 16;
-                                lclVisualConfigs[i].accumAlphaSize = 16;
-                            }
-                            else {
-                                lclVisualConfigs[i].accumRedSize = 0;
-                                lclVisualConfigs[i].accumGreenSize = 0;
-                                lclVisualConfigs[i].accumBlueSize = 0;
-                                lclVisualConfigs[i].accumAlphaSize = 0;
-                            }
-                            lclVisualConfigs[i].doubleBuffer = buffers ? TRUE : FALSE;
-                            lclVisualConfigs[i].stereo = FALSE;
-                            lclVisualConfigs[i].bufferSize = -1;
-
-                            lclVisualConfigs[i].depthSize = depth? 24 : 0;
-                            lclVisualConfigs[i].stencilSize = stencil ? 8 : 0;
-                            lclVisualConfigs[i].auxBuffers = aux ? 2 : 0;
-                            lclVisualConfigs[i].level = 0;
-                            lclVisualConfigs[i].visualRating = GLX_NONE_EXT;
-                            lclVisualConfigs[i].transparentPixel = 0;
-                            lclVisualConfigs[i].transparentRed = 0;
-                            lclVisualConfigs[i].transparentGreen = 0;
-                            lclVisualConfigs[i].transparentBlue = 0;
-                            lclVisualConfigs[i].transparentAlpha = 0;
-                            lclVisualConfigs[i].transparentIndex = 0;
-                            i++;
-                        }
-                    }
-                }
+	      for (buffers = 0; buffers < 2; buffers++) {
+		for (stencil = 0; stencil < 2; stencil++) {
+		  for (accum = 0; accum < 2; accum++) {
+		    lclVisualConfigs[i].vid = -1;
+		    lclVisualConfigs[i].class = -1;
+		    lclVisualConfigs[i].rgba = TRUE;
+		    lclVisualConfigs[i].redSize = -1;
+		    lclVisualConfigs[i].greenSize = -1;
+		    lclVisualConfigs[i].blueSize = -1;
+		    lclVisualConfigs[i].redMask = -1;
+		    lclVisualConfigs[i].greenMask = -1;
+		    lclVisualConfigs[i].blueMask = -1;
+		    lclVisualConfigs[i].alphaMask = 0;
+		    if (accum) {
+		      lclVisualConfigs[i].accumRedSize = 16;
+		      lclVisualConfigs[i].accumGreenSize = 16;
+		      lclVisualConfigs[i].accumBlueSize = 16;
+		      lclVisualConfigs[i].accumAlphaSize = 16;
+		    } else {
+		      lclVisualConfigs[i].accumRedSize = 0;
+		      lclVisualConfigs[i].accumGreenSize = 0;
+		      lclVisualConfigs[i].accumBlueSize = 0;
+		      lclVisualConfigs[i].accumAlphaSize = 0;
+		    }
+		    lclVisualConfigs[i].doubleBuffer = buffers ? TRUE : FALSE;
+		    lclVisualConfigs[i].stereo = stereo ? TRUE : FALSE;
+		    lclVisualConfigs[i].bufferSize = -1;
+		    
+		    lclVisualConfigs[i].depthSize = depth? 24 : 0;
+		    lclVisualConfigs[i].stencilSize = stencil ? 8 : 0;
+		    lclVisualConfigs[i].auxBuffers = aux ? 2 : 0;
+		    lclVisualConfigs[i].level = 0;
+		    lclVisualConfigs[i].visualRating = GLX_NONE_EXT;
+		    lclVisualConfigs[i].transparentPixel = 0;
+		    lclVisualConfigs[i].transparentRed = 0;
+		    lclVisualConfigs[i].transparentGreen = 0;
+		    lclVisualConfigs[i].transparentBlue = 0;
+		    lclVisualConfigs[i].transparentAlpha = 0;
+		    lclVisualConfigs[i].transparentIndex = 0;
+		    i++;
+		  }
+		}
+	      }
             }
-        }
+	  }
+	}
     }
     if (i != lclNumConfigs)
         GLAQUA_DEBUG_MSG("glAquaInitVisualConfigs failed to alloc visual configs");
@@ -1171,7 +1033,7 @@ static Bool glAquaInitVisuals(VisualPtr *visualp, DepthPtr *depthp,
                         *ndepthp, *depthp, *rootDepthp);
 }
 
-
+#if 0
 static void fixup_visuals(int screen)
 {
     ScreenPtr pScreen = screenInfo.screens[screen];
@@ -1204,27 +1066,35 @@ static void fixup_visuals(int screen)
         }
     }
 }
+#endif
+static void __glXAquaScreenDestroy(__GLXscreen *screen) {
 
-static void init_screen_visuals(int screen)
-{
-    ScreenPtr pScreen = screenInfo.screens[screen];
-    __GLcontextModes *modes;
-    int *used;
-    int i, j;
+	GLAQUA_DEBUG_MSG("glXAquaScreenDestroy(%p)\n", screen);
+  __glXScreenDestroy(screen);
 
+  free(screen);
+}
+
+static void init_screen_visuals(__GLXAquaScreen *screen) {
+  ScreenPtr pScreen = screen->base.pScreen;
+  
+  __GLcontextModes *modes;
+  int *used;
+  int i, j;
+  
     GLAQUA_DEBUG_MSG("init_screen_visuals\n");
 
     /* FIXME: Change 'used' to be a array of bits (rather than of ints),
      * FIXME: create a stack array of 8 or 16 bytes.  If 'numVisuals' is less
      * FIXME: than 64 or 128 the stack array can be used instead of calling
-     * FIXME: __glXMalloc / __glXFree.  If nothing else, convert 'used' to
+     * FIXME: malloc / free.  If nothing else, convert 'used' to
      * FIXME: array of bytes instead of ints!
      */
-    used = (int *)__glXMalloc(pScreen->numVisuals * sizeof(int));
-    __glXMemset(used, 0, pScreen->numVisuals * sizeof(int));
+    used = (int *)malloc(pScreen->numVisuals * sizeof(int));
+    memset(used, 0, pScreen->numVisuals * sizeof(int));
 
     i = 0;
-    for ( modes = glAquaScreens[screen].modes 
+    for ( modes = screen -> base.modes
           ; modes != NULL
           ; modes = modes->next ) {
         const int vis_class = _gl_convert_to_x_visual_type( modes->visualType );
@@ -1261,102 +1131,70 @@ static void init_screen_visuals(int screen)
         i++;
     }
 
-    __glXFree(used);
+    free(used);
 }
 
-static Bool glAquaScreenProbe(int screen)
-{
-    ScreenPtr pScreen;
-    glAquaScreenRec *screenPriv;
-
-    GLAQUA_DEBUG_MSG("glAquaScreenProbe\n");
+static __GLXscreen * __glXAquaScreenProbe(ScreenPtr pScreen) {
+  __GLXAquaScreen *screen;
+  GLAQUA_DEBUG_MSG("glXAquaScreenProbe\n");
+  if (screen == NULL) return NULL;
 
-    /*
-     * Set up the current screen's visuals.
-     */
-    __glDDXScreenInfo.modes = glAquaScreens[screen].modes;
-    __glDDXScreenInfo.pVisualPriv = glAquaScreens[screen].priv;
-    __glDDXScreenInfo.numVisuals =
-        __glDDXScreenInfo.numUsableVisuals = glAquaScreens[screen].num_vis;
+  screen = malloc(sizeof *screen);
 
-    /*
-     * Set the current screen's createContext routine.  This could be
-     * wrapped by a DDX GLX context creation routine.
-     */
-    __glDDXScreenInfo.createContext = glAquaCreateContext;
+  __glXScreenInit(&screen->base, pScreen);
 
-    /*
-     * The ordering of the rgb compenents might have been changed by the
-     * driver after mi initialized them.
-     */
-    fixup_visuals(screen);
+  screen->base.destroy       = __glXAquaScreenDestroy;
+  screen->base.createContext = __glXAquaScreenCreateContext;
+  screen->base.pScreen       = pScreen;
 
-    /*
-     * Find the GLX visuals that are supported by this screen and create
-     * XMesa's visuals.
-     */
-    init_screen_visuals(screen);
+  init_screen_visuals(screen);
 
-    /*
-     * Wrap RealizeWindow and UnrealizeWindow on this screen
-     */
-    pScreen = screenInfo.screens[screen];
-    screenPriv = &glAquaScreens[screen];
-    screenPriv->RealizeWindow = pScreen->RealizeWindow;
-    pScreen->RealizeWindow = glAquaRealizeWindow;
-    screenPriv->UnrealizeWindow = pScreen->UnrealizeWindow;
-    pScreen->UnrealizeWindow = glAquaUnrealizeWindow;
-
-    return TRUE;
-}
-
-static GLboolean glAquaSwapBuffers(__GLXdrawablePrivate *glxPriv)
-{
-    // swap buffers on only *one* of the contexts
-    // (e.g. the last one for drawing)
-    __GLcontext *gc = (__GLcontext *)glxPriv->drawGlxc->gc;
-    CGLError gl_err;
-
-    GLAQUA_DEBUG_MSG("glAquaSwapBuffers\n");
-
-    if (gc != NULL && gc->ctx != NULL)
-    {
-        gl_err = CGLFlushDrawable(gc->ctx);
-        if (gl_err != 0)
-            ErrorF("CGLFlushDrawable error: %s\n", CGLErrorString(gl_err));
-    }
-
-    return GL_TRUE;
+  return &screen->base;
 }
 
-static void glAquaDestroyDrawablePrivate(__GLdrawablePrivate *glPriv)
-{
+static void __glXAquaDrawableDestroy(__GLXdrawable *base) {
     GLAQUA_DEBUG_MSG("glAquaDestroyDrawablePrivate\n");
 
     /* It doesn't work to call DRIDestroySurface here, the drawable's
        already gone.. But dri.c notices the window destruction and
        frees the surface itself. */
 
-    free(glPriv->private);
-    glPriv->private = NULL;
+    free(base);
 }
 
-static void glAquaCreateBuffer(__GLXdrawablePrivate *glxPriv)
+static __GLXdrawable *
+__glXAquaContextCreateDrawable(__GLXcontext *context,
+			       DrawablePtr pDraw,
+			       XID drawId)
 {
-    GLAquaDrawableRec *aquaPriv = malloc(sizeof(GLAquaDrawableRec));
-    __GLdrawablePrivate *glPriv = &glxPriv->glPriv;
+  __GLXAquaDrawable *glxPriv;
+  __GLXscreen *pGlxScreen;
+
+  GLAQUA_DEBUG_MSG("glAquaContextCreateDrawable(%p,%p,%d)\n", context, pDraw, drawId);
+  if (glxPriv == NULL) return NULL;
+  glxPriv = xalloc(sizeof *glxPriv);
+
+  memset(glxPriv, 0, sizeof *glxPriv);
 
-    aquaPriv->sid = 0;
-    aquaPriv->pDraw = NULL;
+  if (!__glXDrawableInit(&glxPriv->base, context, pDraw, drawId)) {
+    xfree(glxPriv);
+    return NULL;
+  }
+
+  glxPriv->base.destroy       = __glXAquaDrawableDestroy;
+  glxPriv->base.resize        = __glXAquaDrawableResize;
+  glxPriv->base.swapBuffers   = __glXAquaDrawableSwapBuffers;
+
+  pGlxScreen = __glXActiveScreens[pDraw->pScreen->myNum];
 
-    GLAQUA_DEBUG_MSG("glAquaCreateBuffer\n");
+  if (glxPriv->base.type == DRAWABLE_WINDOW) {
+    VisualID vid = wVisual((WindowPtr)pDraw);
 
-    // replace swapBuffers (original is never called)
-    glxPriv->swapBuffers = glAquaSwapBuffers;
+    glxPriv->base.modes = _gl_context_modes_find_visual(pGlxScreen->modes, vid);
+  } else 
+    glxPriv->base.modes = glxPriv->base.pGlxPixmap->modes;
 
-    // stash private data
-    glPriv->private = aquaPriv;
-    glPriv->freePrivate = glAquaDestroyDrawablePrivate;
+    return &glxPriv->base;
 }
 
 static void glAquaResetExtension(void)
@@ -1377,3 +1215,1239 @@ GLuint __glFloorLog2(GLuint val)
     }
     return c;
 }
+
+static void setup_dispatch_table(void) {
+	struct _glapi_table *disp=_glapi_get_dispatch();
+
+ SET_NewList(disp, glNewList);
+ SET_EndList(disp, glEndList);
+ SET_CallList(disp, glCallList);
+ SET_CallLists(disp, glCallLists);
+ SET_DeleteLists(disp, glDeleteLists);
+ SET_GenLists(disp, glGenLists);
+ SET_ListBase(disp, glListBase);
+ SET_Begin(disp, glBegin);
+ SET_Bitmap(disp, glBitmap);
+ SET_Color3b(disp, glColor3b);
+ SET_Color3bv(disp, glColor3bv);
+ SET_Color3d(disp, glColor3d);
+ SET_Color3dv(disp, glColor3dv);
+ SET_Color3f(disp, glColor3f);
+ SET_Color3fv(disp, glColor3fv);
+ SET_Color3i(disp, glColor3i);
+ SET_Color3iv(disp, glColor3iv);
+ SET_Color3s(disp, glColor3s);
+ SET_Color3sv(disp, glColor3sv);
+ SET_Color3ub(disp, glColor3ub);
+ SET_Color3ubv(disp, glColor3ubv);
+ SET_Color3ui(disp, glColor3ui);
+ SET_Color3uiv(disp, glColor3uiv);
+ SET_Color3us(disp, glColor3us);
+ SET_Color3usv(disp, glColor3usv);
+ SET_Color4b(disp, glColor4b);
+ SET_Color4bv(disp, glColor4bv);
+ SET_Color4d(disp, glColor4d);
+ SET_Color4dv(disp, glColor4dv);
+ SET_Color4f(disp, glColor4f);
+ SET_Color4fv(disp, glColor4fv);
+ SET_Color4i(disp, glColor4i);
+ SET_Color4iv(disp, glColor4iv);
+ SET_Color4s(disp, glColor4s);
+ SET_Color4sv(disp, glColor4sv);
+ SET_Color4ub(disp, glColor4ub);
+ SET_Color4ubv(disp, glColor4ubv);
+ SET_Color4ui(disp, glColor4ui);
+ SET_Color4uiv(disp, glColor4uiv);
+ SET_Color4us(disp, glColor4us);
+ SET_Color4usv(disp, glColor4usv);
+ SET_EdgeFlag(disp, glEdgeFlag);
+ SET_EdgeFlagv(disp, glEdgeFlagv);
+ SET_End(disp, glEnd);
+ SET_Indexd(disp, glIndexd);
+ SET_Indexdv(disp, glIndexdv);
+ SET_Indexf(disp, glIndexf);
+ SET_Indexfv(disp, glIndexfv);
+ SET_Indexi(disp, glIndexi);
+ SET_Indexiv(disp, glIndexiv);
+ SET_Indexs(disp, glIndexs);
+ SET_Indexsv(disp, glIndexsv);
+ SET_Normal3b(disp, glNormal3b);
+ SET_Normal3bv(disp, glNormal3bv);
+ SET_Normal3d(disp, glNormal3d);
+ SET_Normal3dv(disp, glNormal3dv);
+ SET_Normal3f(disp, glNormal3f);
+ SET_Normal3fv(disp, glNormal3fv);
+ SET_Normal3i(disp, glNormal3i);
+ SET_Normal3iv(disp, glNormal3iv);
+ SET_Normal3s(disp, glNormal3s);
+ SET_Normal3sv(disp, glNormal3sv);
+ SET_RasterPos2d(disp, glRasterPos2d);
+ SET_RasterPos2dv(disp, glRasterPos2dv);
+ SET_RasterPos2f(disp, glRasterPos2f);
+ SET_RasterPos2fv(disp, glRasterPos2fv);
+ SET_RasterPos2i(disp, glRasterPos2i);
+ SET_RasterPos2iv(disp, glRasterPos2iv);
+ SET_RasterPos2s(disp, glRasterPos2s);
+ SET_RasterPos2sv(disp, glRasterPos2sv);
+ SET_RasterPos3d(disp, glRasterPos3d);
+ SET_RasterPos3dv(disp, glRasterPos3dv);
+ SET_RasterPos3f(disp, glRasterPos3f);
+ SET_RasterPos3fv(disp, glRasterPos3fv);
+ SET_RasterPos3i(disp, glRasterPos3i);
+ SET_RasterPos3iv(disp, glRasterPos3iv);
+ SET_RasterPos3s(disp, glRasterPos3s);
+ SET_RasterPos3sv(disp, glRasterPos3sv);
+ SET_RasterPos4d(disp, glRasterPos4d);
+ SET_RasterPos4dv(disp, glRasterPos4dv);
+ SET_RasterPos4f(disp, glRasterPos4f);
+ SET_RasterPos4fv(disp, glRasterPos4fv);
+ SET_RasterPos4i(disp, glRasterPos4i);
+ SET_RasterPos4iv(disp, glRasterPos4iv);
+ SET_RasterPos4s(disp, glRasterPos4s);
+ SET_RasterPos4sv(disp, glRasterPos4sv);
+ SET_Rectd(disp, glRectd);
+ SET_Rectdv(disp, glRectdv);
+ SET_Rectf(disp, glRectf);
+ SET_Rectfv(disp, glRectfv);
+ SET_Recti(disp, glRecti);
+ SET_Rectiv(disp, glRectiv);
+ SET_Rects(disp, glRects);
+ SET_Rectsv(disp, glRectsv);
+ SET_TexCoord1d(disp, glTexCoord1d);
+ SET_TexCoord1dv(disp, glTexCoord1dv);
+ SET_TexCoord1f(disp, glTexCoord1f);
+ SET_TexCoord1fv(disp, glTexCoord1fv);
+ SET_TexCoord1i(disp, glTexCoord1i);
+ SET_TexCoord1iv(disp, glTexCoord1iv);
+ SET_TexCoord1s(disp, glTexCoord1s);
+ SET_TexCoord1sv(disp, glTexCoord1sv);
+ SET_TexCoord2d(disp, glTexCoord2d);
+ SET_TexCoord2dv(disp, glTexCoord2dv);
+ SET_TexCoord2f(disp, glTexCoord2f);
+ SET_TexCoord2fv(disp, glTexCoord2fv);
+ SET_TexCoord2i(disp, glTexCoord2i);
+ SET_TexCoord2iv(disp, glTexCoord2iv);
+ SET_TexCoord2s(disp, glTexCoord2s);
+ SET_TexCoord2sv(disp, glTexCoord2sv);
+ SET_TexCoord3d(disp, glTexCoord3d);
+ SET_TexCoord3dv(disp, glTexCoord3dv);
+ SET_TexCoord3f(disp, glTexCoord3f);
+ SET_TexCoord3fv(disp, glTexCoord3fv);
+ SET_TexCoord3i(disp, glTexCoord3i);
+ SET_TexCoord3iv(disp, glTexCoord3iv);
+ SET_TexCoord3s(disp, glTexCoord3s);
+ SET_TexCoord3sv(disp, glTexCoord3sv);
+ SET_TexCoord4d(disp, glTexCoord4d);
+ SET_TexCoord4dv(disp, glTexCoord4dv);
+ SET_TexCoord4f(disp, glTexCoord4f);
+ SET_TexCoord4fv(disp, glTexCoord4fv);
+ SET_TexCoord4i(disp, glTexCoord4i);
+ SET_TexCoord4iv(disp, glTexCoord4iv);
+ SET_TexCoord4s(disp, glTexCoord4s);
+ SET_TexCoord4sv(disp, glTexCoord4sv);
+ SET_Vertex2d(disp, glVertex2d);
+ SET_Vertex2dv(disp, glVertex2dv);
+ SET_Vertex2f(disp, glVertex2f);
+ SET_Vertex2fv(disp, glVertex2fv);
+ SET_Vertex2i(disp, glVertex2i);
+ SET_Vertex2iv(disp, glVertex2iv);
+ SET_Vertex2s(disp, glVertex2s);
+ SET_Vertex2sv(disp, glVertex2sv);
+ SET_Vertex3d(disp, glVertex3d);
+ SET_Vertex3dv(disp, glVertex3dv);
+ SET_Vertex3f(disp, glVertex3f);
+ SET_Vertex3fv(disp, glVertex3fv);
+ SET_Vertex3i(disp, glVertex3i);
+ SET_Vertex3iv(disp, glVertex3iv);
+ SET_Vertex3s(disp, glVertex3s);
+ SET_Vertex3sv(disp, glVertex3sv);
+ SET_Vertex4d(disp, glVertex4d);
+ SET_Vertex4dv(disp, glVertex4dv);
+ SET_Vertex4f(disp, glVertex4f);
+ SET_Vertex4fv(disp, glVertex4fv);
+ SET_Vertex4i(disp, glVertex4i);
+ SET_Vertex4iv(disp, glVertex4iv);
+ SET_Vertex4s(disp, glVertex4s);
+ SET_Vertex4sv(disp, glVertex4sv);
+ SET_ClipPlane(disp, glClipPlane);
+ SET_ColorMaterial(disp, glColorMaterial);
+ SET_CullFace(disp, glCullFace);
+ SET_Fogf(disp, glFogf);
+ SET_Fogfv(disp, glFogfv);
+ SET_Fogi(disp, glFogi);
+ SET_Fogiv(disp, glFogiv);
+ SET_FrontFace(disp, glFrontFace);
+ SET_Hint(disp, glHint);
+ SET_Lightf(disp, glLightf);
+ SET_Lightfv(disp, glLightfv);
+ SET_Lighti(disp, glLighti);
+ SET_Lightiv(disp, glLightiv);
+ SET_LightModelf(disp, glLightModelf);
+ SET_LightModelfv(disp, glLightModelfv);
+ SET_LightModeli(disp, glLightModeli);
+ SET_LightModeliv(disp, glLightModeliv);
+ SET_LineStipple(disp, glLineStipple);
+ SET_LineWidth(disp, glLineWidth);
+ SET_Materialf(disp, glMaterialf);
+ SET_Materialfv(disp, glMaterialfv);
+ SET_Materiali(disp, glMateriali);
+ SET_Materialiv(disp, glMaterialiv);
+ SET_PointSize(disp, glPointSize);
+ SET_PolygonMode(disp, glPolygonMode);
+ SET_PolygonStipple(disp, glPolygonStipple);
+ SET_Scissor(disp, glScissor);
+ SET_ShadeModel(disp, glShadeModel);
+ SET_TexParameterf(disp, glTexParameterf);
+ SET_TexParameterfv(disp, glTexParameterfv);
+ SET_TexParameteri(disp, glTexParameteri);
+ SET_TexParameteriv(disp, glTexParameteriv);
+ SET_TexImage1D(disp, glTexImage1D);
+ SET_TexImage2D(disp, glTexImage2D);
+ SET_TexEnvf(disp, glTexEnvf);
+ SET_TexEnvfv(disp, glTexEnvfv);
+ SET_TexEnvi(disp, glTexEnvi);
+ SET_TexEnviv(disp, glTexEnviv);
+ SET_TexGend(disp, glTexGend);
+ SET_TexGendv(disp, glTexGendv);
+ SET_TexGenf(disp, glTexGenf);
+ SET_TexGenfv(disp, glTexGenfv);
+ SET_TexGeni(disp, glTexGeni);
+ SET_TexGeniv(disp, glTexGeniv);
+ SET_FeedbackBuffer(disp, glFeedbackBuffer);
+ SET_SelectBuffer(disp, glSelectBuffer);
+ SET_RenderMode(disp, glRenderMode);
+ SET_InitNames(disp, glInitNames);
+ SET_LoadName(disp, glLoadName);
+ SET_PassThrough(disp, glPassThrough);
+ SET_PopName(disp, glPopName);
+ SET_PushName(disp, glPushName);
+ SET_DrawBuffer(disp, glDrawBuffer);
+ SET_Clear(disp, glClear);
+ SET_ClearAccum(disp, glClearAccum);
+ SET_ClearIndex(disp, glClearIndex);
+ SET_ClearColor(disp, glClearColor);
+ SET_ClearStencil(disp, glClearStencil);
+ SET_ClearDepth(disp, glClearDepth);
+ SET_StencilMask(disp, glStencilMask);
+ SET_ColorMask(disp, glColorMask);
+ SET_DepthMask(disp, glDepthMask);
+ SET_IndexMask(disp, glIndexMask);
+ SET_Accum(disp, glAccum);
+ SET_Disable(disp, glDisable);
+ SET_Enable(disp, glEnable);
+ SET_Finish(disp, glFinish);
+ SET_Flush(disp, glFlush);
+ SET_PopAttrib(disp, glPopAttrib);
+ SET_PushAttrib(disp, glPushAttrib);
+ SET_Map1d(disp, glMap1d);
+ SET_Map1f(disp, glMap1f);
+ SET_Map2d(disp, glMap2d);
+ SET_Map2f(disp, glMap2f);
+ SET_MapGrid1d(disp, glMapGrid1d);
+ SET_MapGrid1f(disp, glMapGrid1f);
+ SET_MapGrid2d(disp, glMapGrid2d);
+ SET_MapGrid2f(disp, glMapGrid2f);
+ SET_EvalCoord1d(disp, glEvalCoord1d);
+ SET_EvalCoord1dv(disp, glEvalCoord1dv);
+ SET_EvalCoord1f(disp, glEvalCoord1f);
+ SET_EvalCoord1fv(disp, glEvalCoord1fv);
+ SET_EvalCoord2d(disp, glEvalCoord2d);
+ SET_EvalCoord2dv(disp, glEvalCoord2dv);
+ SET_EvalCoord2f(disp, glEvalCoord2f);
+ SET_EvalCoord2fv(disp, glEvalCoord2fv);
+ SET_EvalMesh1(disp, glEvalMesh1);
+ SET_EvalPoint1(disp, glEvalPoint1);
+ SET_EvalMesh2(disp, glEvalMesh2);
+ SET_EvalPoint2(disp, glEvalPoint2);
+ SET_AlphaFunc(disp, glAlphaFunc);
+ SET_BlendFunc(disp, glBlendFunc);
+ SET_LogicOp(disp, glLogicOp);
+ SET_StencilFunc(disp, glStencilFunc);
+ SET_StencilOp(disp, glStencilOp);
+ SET_DepthFunc(disp, glDepthFunc);
+ SET_PixelZoom(disp, glPixelZoom);
+ SET_PixelTransferf(disp, glPixelTransferf);
+ SET_PixelTransferi(disp, glPixelTransferi);
+ SET_PixelStoref(disp, glPixelStoref);
+ SET_PixelStorei(disp, glPixelStorei);
+ SET_PixelMapfv(disp, glPixelMapfv);
+ SET_PixelMapuiv(disp, glPixelMapuiv);
+ SET_PixelMapusv(disp, glPixelMapusv);
+ SET_ReadBuffer(disp, glReadBuffer);
+ SET_CopyPixels(disp, glCopyPixels);
+ SET_ReadPixels(disp, glReadPixels);
+ SET_DrawPixels(disp, glDrawPixels);
+ SET_GetBooleanv(disp, glGetBooleanv);
+ SET_GetClipPlane(disp, glGetClipPlane);
+ SET_GetDoublev(disp, glGetDoublev);
+ SET_GetError(disp, glGetError);
+ SET_GetFloatv(disp, glGetFloatv);
+ SET_GetIntegerv(disp, glGetIntegerv);
+ SET_GetLightfv(disp, glGetLightfv);
+ SET_GetLightiv(disp, glGetLightiv);
+ SET_GetMapdv(disp, glGetMapdv);
+ SET_GetMapfv(disp, glGetMapfv);
+ SET_GetMapiv(disp, glGetMapiv);
+ SET_GetMaterialfv(disp, glGetMaterialfv);
+ SET_GetMaterialiv(disp, glGetMaterialiv);
+ SET_GetPixelMapfv(disp, glGetPixelMapfv);
+ SET_GetPixelMapuiv(disp, glGetPixelMapuiv);
+ SET_GetPixelMapusv(disp, glGetPixelMapusv);
+ SET_GetPolygonStipple(disp, glGetPolygonStipple);
+ SET_GetString(disp, glGetString);
+ SET_GetTexEnvfv(disp, glGetTexEnvfv);
+ SET_GetTexEnviv(disp, glGetTexEnviv);
+ SET_GetTexGendv(disp, glGetTexGendv);
+ SET_GetTexGenfv(disp, glGetTexGenfv);
+ SET_GetTexGeniv(disp, glGetTexGeniv);
+ SET_GetTexImage(disp, glGetTexImage);
+ SET_GetTexParameterfv(disp, glGetTexParameterfv);
+ SET_GetTexParameteriv(disp, glGetTexParameteriv);
+ SET_GetTexLevelParameterfv(disp, glGetTexLevelParameterfv);
+ SET_GetTexLevelParameteriv(disp, glGetTexLevelParameteriv);
+ SET_IsEnabled(disp, glIsEnabled);
+ SET_IsList(disp, glIsList);
+ SET_DepthRange(disp, glDepthRange);
+ SET_Frustum(disp, glFrustum);
+ SET_LoadIdentity(disp, glLoadIdentity);
+ SET_LoadMatrixf(disp, glLoadMatrixf);
+ SET_LoadMatrixd(disp, glLoadMatrixd);
+ SET_MatrixMode(disp, glMatrixMode);
+ SET_MultMatrixf(disp, glMultMatrixf);
+ SET_MultMatrixd(disp, glMultMatrixd);
+ SET_Ortho(disp, glOrtho);
+ SET_PopMatrix(disp, glPopMatrix);
+ SET_PushMatrix(disp, glPushMatrix);
+ SET_Rotated(disp, glRotated);
+ SET_Rotatef(disp, glRotatef);
+ SET_Scaled(disp, glScaled);
+ SET_Scalef(disp, glScalef);
+ SET_Translated(disp, glTranslated);
+ SET_Translatef(disp, glTranslatef);
+ SET_Viewport(disp, glViewport);
+ SET_ArrayElement(disp, glArrayElement);
+ SET_BindTexture(disp, glBindTexture);
+ SET_ColorPointer(disp, glColorPointer);
+ SET_DisableClientState(disp, glDisableClientState);
+ SET_DrawArrays(disp, glDrawArrays);
+ SET_DrawElements(disp, glDrawElements);
+ SET_EdgeFlagPointer(disp, glEdgeFlagPointer);
+ SET_EnableClientState(disp, glEnableClientState);
+ SET_IndexPointer(disp, glIndexPointer);
+ SET_Indexub(disp, glIndexub);
+ SET_Indexubv(disp, glIndexubv);
+ SET_InterleavedArrays(disp, glInterleavedArrays);
+ SET_NormalPointer(disp, glNormalPointer);
+ SET_PolygonOffset(disp, glPolygonOffset);
+ SET_TexCoordPointer(disp, glTexCoordPointer);
+ SET_VertexPointer(disp, glVertexPointer);
+ SET_AreTexturesResident(disp, glAreTexturesResident); 
+ SET_CopyTexImage1D(disp, glCopyTexImage1D);
+ SET_CopyTexImage2D(disp, glCopyTexImage2D);
+ SET_CopyTexSubImage1D(disp, glCopyTexSubImage1D);
+ SET_CopyTexSubImage2D(disp, glCopyTexSubImage2D);
+ SET_DeleteTextures(disp, glDeleteTextures);
+ SET_GenTextures(disp, glGenTextures);
+ SET_GetPointerv(disp, glGetPointerv);
+ SET_IsTexture(disp, glIsTexture);
+ SET_PrioritizeTextures(disp, glPrioritizeTextures);
+ SET_TexSubImage1D(disp, glTexSubImage1D);
+ SET_TexSubImage2D(disp, glTexSubImage2D);
+ SET_PopClientAttrib(disp, glPopClientAttrib);
+ SET_PushClientAttrib(disp, glPushClientAttrib);
+ SET_BlendColor(disp, glBlendColor);
+ SET_BlendEquation(disp, glBlendEquation);
+ SET_DrawRangeElements(disp, glDrawRangeElements);
+ SET_ColorTable(disp, glColorTable);
+ SET_ColorTableParameterfv(disp, glColorTableParameterfv);
+ SET_ColorTableParameteriv(disp, glColorTableParameteriv);
+ SET_CopyColorTable(disp, glCopyColorTable);
+ SET_GetColorTable(disp, glGetColorTable);
+ SET_GetColorTableParameterfv(disp, glGetColorTableParameterfv);
+ SET_GetColorTableParameteriv(disp, glGetColorTableParameteriv);
+ SET_ColorSubTable(disp, glColorSubTable);
+ SET_CopyColorSubTable(disp, glCopyColorSubTable);
+ SET_ConvolutionFilter1D(disp, glConvolutionFilter1D);
+ SET_ConvolutionFilter2D(disp, glConvolutionFilter2D);
+ SET_ConvolutionParameterf(disp, glConvolutionParameterf);
+ SET_ConvolutionParameterfv(disp, glConvolutionParameterfv);
+ SET_ConvolutionParameteri(disp, glConvolutionParameteri);
+ SET_ConvolutionParameteriv(disp, glConvolutionParameteriv);
+ SET_CopyConvolutionFilter1D(disp, glCopyConvolutionFilter1D);
+ SET_CopyConvolutionFilter2D(disp, glCopyConvolutionFilter2D);
+ SET_GetConvolutionFilter(disp, glGetConvolutionFilter);
+ SET_GetConvolutionParameterfv(disp, glGetConvolutionParameterfv);
+ SET_GetConvolutionParameteriv(disp, glGetConvolutionParameteriv);
+ SET_GetSeparableFilter(disp, glGetSeparableFilter);
+ SET_SeparableFilter2D(disp, glSeparableFilter2D);
+ SET_GetHistogram(disp, glGetHistogram);
+ SET_GetHistogramParameterfv(disp, glGetHistogramParameterfv);
+ SET_GetHistogramParameteriv(disp, glGetHistogramParameteriv);
+ SET_GetMinmax(disp, glGetMinmax);
+ SET_GetMinmaxParameterfv(disp, glGetMinmaxParameterfv);
+ SET_GetMinmaxParameteriv(disp, glGetMinmaxParameteriv);
+ SET_Histogram(disp, glHistogram);
+ SET_Minmax(disp, glMinmax);
+ SET_ResetHistogram(disp, glResetHistogram);
+ SET_ResetMinmax(disp, glResetMinmax);
+ SET_TexImage3D(disp, glTexImage3D);
+ SET_TexSubImage3D(disp, glTexSubImage3D);
+ SET_CopyTexSubImage3D(disp, glCopyTexSubImage3D);
+ SET_ActiveTextureARB(disp, glActiveTextureARB);
+ SET_ClientActiveTextureARB(disp, glClientActiveTextureARB);
+ SET_MultiTexCoord1dARB(disp, glMultiTexCoord1dARB);
+ SET_MultiTexCoord1dvARB(disp, glMultiTexCoord1dvARB);
+ SET_MultiTexCoord1fARB(disp, glMultiTexCoord1fARB);
+ SET_MultiTexCoord1fvARB(disp, glMultiTexCoord1fvARB);
+ SET_MultiTexCoord1iARB(disp, glMultiTexCoord1iARB);
+ SET_MultiTexCoord1ivARB(disp, glMultiTexCoord1ivARB);
+ SET_MultiTexCoord1sARB(disp, glMultiTexCoord1sARB);
+ SET_MultiTexCoord1svARB(disp, glMultiTexCoord1svARB);
+ SET_MultiTexCoord2dARB(disp, glMultiTexCoord2dARB);
+ SET_MultiTexCoord2dvARB(disp, glMultiTexCoord2dvARB);
+ SET_MultiTexCoord2fARB(disp, glMultiTexCoord2fARB);
+ SET_MultiTexCoord2fvARB(disp, glMultiTexCoord2fvARB);
+ SET_MultiTexCoord2iARB(disp, glMultiTexCoord2iARB);
+ SET_MultiTexCoord2ivARB(disp, glMultiTexCoord2ivARB);
+ SET_MultiTexCoord2sARB(disp, glMultiTexCoord2sARB);
+ SET_MultiTexCoord2svARB(disp, glMultiTexCoord2svARB);
+ SET_MultiTexCoord3dARB(disp, glMultiTexCoord3dARB);
+ SET_MultiTexCoord3dvARB(disp, glMultiTexCoord3dvARB);
+ SET_MultiTexCoord3fARB(disp, glMultiTexCoord3fARB);
+ SET_MultiTexCoord3fvARB(disp, glMultiTexCoord3fvARB);
+ SET_MultiTexCoord3iARB(disp, glMultiTexCoord3iARB);
+ SET_MultiTexCoord3ivARB(disp, glMultiTexCoord3ivARB);
+ SET_MultiTexCoord3sARB(disp, glMultiTexCoord3sARB);
+ SET_MultiTexCoord3svARB(disp, glMultiTexCoord3svARB);
+ SET_MultiTexCoord4dARB(disp, glMultiTexCoord4dARB);
+ SET_MultiTexCoord4dvARB(disp, glMultiTexCoord4dvARB);
+ SET_MultiTexCoord4fARB(disp, glMultiTexCoord4fARB);
+ SET_MultiTexCoord4fvARB(disp, glMultiTexCoord4fvARB);
+ SET_MultiTexCoord4iARB(disp, glMultiTexCoord4iARB);
+ SET_MultiTexCoord4ivARB(disp, glMultiTexCoord4ivARB);
+ SET_MultiTexCoord4sARB(disp, glMultiTexCoord4sARB);
+ SET_MultiTexCoord4svARB(disp, glMultiTexCoord4svARB);
+ SET_LoadTransposeMatrixfARB(disp, glLoadTransposeMatrixfARB);
+ SET_LoadTransposeMatrixdARB(disp, glLoadTransposeMatrixdARB);
+ SET_MultTransposeMatrixfARB(disp, glMultTransposeMatrixfARB);
+ SET_MultTransposeMatrixdARB(disp, glMultTransposeMatrixdARB);
+ SET_SampleCoverageARB(disp, glSampleCoverageARB);
+ SET_DrawBuffersARB(disp, glDrawBuffersARB);
+/* SET_PolygonOffsetEXT(disp, glPolygonOffsetEXT);
+ SET_GetTexFilterFuncSGIS(disp, glGetTexFilterFuncSGIS);
+ SET_TexFilterFuncSGIS(disp, glTexFilterFuncSGIS);
+ SET_GetHistogramEXT(disp, glGetHistogramEXT);
+ SET_GetHistogramParameterfvEXT(disp, glGetHistogramParameterfvEXT);
+ SET_GetHistogramParameterivEXT(disp, glGetHistogramParameterivEXT);
+ SET_GetMinmaxEXT(disp, glGetMinmaxEXT);
+ SET_GetMinmaxParameterfvEXT(disp, glGetMinmaxParameterfvEXT);
+ SET_GetMinmaxParameterivEXT(disp, glGetMinmaxParameterivEXT);
+ SET_GetConvolutionFilterEXT(disp, glGetConvolutionFilterEXT);
+ SET_GetConvolutionParameterfvEXT(disp, glGetConvolutionParameterfvEXT);
+ SET_GetConvolutionParameterivEXT(disp, glGetConvolutionParameterivEXT);
+ SET_GetSeparableFilterEXT(disp, glGetSeparableFilterEXT);
+ SET_GetColorTableSGI(disp, glGetColorTableSGI);
+ SET_GetColorTableParameterfvSGI(disp, glGetColorTableParameterfvSGI);
+ SET_GetColorTableParameterivSGI(disp, glGetColorTableParameterivSGI);
+ SET_PixelTexGenSGIX(disp, glPixelTexGenSGIX);
+ SET_PixelTexGenParameteriSGIS(disp, glPixelTexGenParameteriSGIS);
+ SET_PixelTexGenParameterivSGIS(disp, glPixelTexGenParameterivSGIS);
+ SET_PixelTexGenParameterfSGIS(disp, glPixelTexGenParameterfSGIS);
+ SET_PixelTexGenParameterfvSGIS(disp, glPixelTexGenParameterfvSGIS);
+ SET_GetPixelTexGenParameterivSGIS(disp, glGetPixelTexGenParameterivSGIS);
+ SET_GetPixelTexGenParameterfvSGIS(disp, glGetPixelTexGenParameterfvSGIS);
+ SET_TexImage4DSGIS(disp, glTexImage4DSGIS);
+ SET_TexSubImage4DSGIS(disp, glTexSubImage4DSGIS); */
+ SET_AreTexturesResidentEXT(disp, glAreTexturesResident);
+ SET_GenTexturesEXT(disp, glGenTextures);
+ SET_IsTextureEXT(disp, glIsTexture);
+/* SET_DetailTexFuncSGIS(disp, glDetailTexFuncSGIS);
+ SET_GetDetailTexFuncSGIS(disp, glGetDetailTexFuncSGIS);
+ SET_SharpenTexFuncSGIS(disp, glSharpenTexFuncSGIS);
+ SET_GetSharpenTexFuncSGIS(disp, glGetSharpenTexFuncSGIS);
+ SET_SampleMaskSGIS(disp, glSampleMaskSGIS);
+ SET_SamplePatternSGIS(disp, glSamplePatternSGIS);
+ SET_ColorPointerEXT(disp, glColorPointerEXT);
+ SET_EdgeFlagPointerEXT(disp, glEdgeFlagPointerEXT);
+ SET_IndexPointerEXT(disp, glIndexPointerEXT);
+ SET_NormalPointerEXT(disp, glNormalPointerEXT);
+ SET_TexCoordPointerEXT(disp, glTexCoordPointerEXT);
+ SET_VertexPointerEXT(disp, glVertexPointerEXT);
+ SET_SpriteParameterfSGIX(disp, glSpriteParameterfSGIX);
+ SET_SpriteParameterfvSGIX(disp, glSpriteParameterfvSGIX);
+ SET_SpriteParameteriSGIX(disp, glSpriteParameteriSGIX);
+ SET_SpriteParameterivSGIX(disp, glSpriteParameterivSGIX);
+ SET_PointParameterfEXT(disp, glPointParameterfEXT);
+ SET_PointParameterfvEXT(disp, glPointParameterfvEXT);
+ SET_GetInstrumentsSGIX(disp, glGetInstrumentsSGIX);
+ SET_InstrumentsBufferSGIX(disp, glInstrumentsBufferSGIX);
+ SET_PollInstrumentsSGIX(disp, glPollInstrumentsSGIX);
+ SET_ReadInstrumentsSGIX(disp, glReadInstrumentsSGIX);
+ SET_StartInstrumentsSGIX(disp, glStartInstrumentsSGIX);
+ SET_StopInstrumentsSGIX(disp, glStopInstrumentsSGIX);
+ SET_FrameZoomSGIX(disp, glFrameZoomSGIX);
+ SET_TagSampleBufferSGIX(disp, glTagSampleBufferSGIX);
+ SET_ReferencePlaneSGIX(disp, glReferencePlaneSGIX);
+ SET_FlushRasterSGIX(disp, glFlushRasterSGIX);
+ SET_GetListParameterfvSGIX(disp, glGetListParameterfvSGIX);
+ SET_GetListParameterivSGIX(disp, glGetListParameterivSGIX);
+ SET_ListParameterfSGIX(disp, glListParameterfSGIX);
+ SET_ListParameterfvSGIX(disp, glListParameterfvSGIX);
+ SET_ListParameteriSGIX(disp, glListParameteriSGIX);
+ SET_ListParameterivSGIX(disp, glListParameterivSGIX);
+ SET_FragmentColorMaterialSGIX(disp, glFragmentColorMaterialSGIX);
+ SET_FragmentLightfSGIX(disp, glFragmentLightfSGIX);
+ SET_FragmentLightfvSGIX(disp, glFragmentLightfvSGIX);
+ SET_FragmentLightiSGIX(disp, glFragmentLightiSGIX);
+ SET_FragmentLightivSGIX(disp, glFragmentLightivSGIX);
+ SET_FragmentLightModelfSGIX(disp, glFragmentLightModelfSGIX);
+ SET_FragmentLightModelfvSGIX(disp, glFragmentLightModelfvSGIX);
+ SET_FragmentLightModeliSGIX(disp, glFragmentLightModeliSGIX);
+ SET_FragmentLightModelivSGIX(disp, glFragmentLightModelivSGIX);
+ SET_FragmentMaterialfSGIX(disp, glFragmentMaterialfSGIX);
+ SET_FragmentMaterialfvSGIX(disp, glFragmentMaterialfvSGIX);
+ SET_FragmentMaterialiSGIX(disp, glFragmentMaterialiSGIX);
+ SET_FragmentMaterialivSGIX(disp, glFragmentMaterialivSGIX);
+ SET_GetFragmentLightfvSGIX(disp, glGetFragmentLightfvSGIX);
+ SET_GetFragmentLightivSGIX(disp, glGetFragmentLightivSGIX);
+ SET_GetFragmentMaterialfvSGIX(disp, glGetFragmentMaterialfvSGIX);
+ SET_GetFragmentMaterialivSGIX(disp, glGetFragmentMaterialivSGIX);
+ SET_LightEnviSGIX(disp, glLightEnviSGIX); 
+ SET_VertexWeightfEXT(disp, glVertexWeightfEXT);
+ SET_VertexWeightfvEXT(disp, glVertexWeightfvEXT);
+ SET_VertexWeightPointerEXT(disp, glVertexWeightPointerEXT);
+ SET_FlushVertexArrayRangeNV(disp, glFlushVertexArrayRangeNV);
+ SET_VertexArrayRangeNV(disp, glVertexArrayRangeNV);
+ SET_CombinerParameterfvNV(disp, glCombinerParameterfvNV);
+ SET_CombinerParameterfNV(disp, glCombinerParameterfNV);
+ SET_CombinerParameterivNV(disp, glCombinerParameterivNV);
+ SET_CombinerParameteriNV(disp, glCombinerParameteriNV);
+ SET_CombinerInputNV(disp, glCombinerInputNV);
+ SET_CombinerOutputNV(disp, glCombinerOutputNV);
+ SET_FinalCombinerInputNV(disp, glFinalCombinerInputNV);
+ SET_GetCombinerInputParameterfvNV(disp, glGetCombinerInputParameterfvNV);
+ SET_GetCombinerInputParameterivNV(disp, glGetCombinerInputParameterivNV);
+ SET_GetCombinerOutputParameterfvNV(disp, glGetCombinerOutputParameterfvNV);
+ SET_GetCombinerOutputParameterivNV(disp, glGetCombinerOutputParameterivNV);
+ SET_GetFinalCombinerInputParameterfvNV(disp, glGetFinalCombinerInputParameterfvNV);
+ SET_GetFinalCombinerInputParameterivNV(disp, glGetFinalCombinerInputParameterivNV);
+ SET_ResizeBuffersMESA(disp, glResizeBuffersMESA);
+ SET_WindowPos2dMESA(disp, glWindowPos2dMESA);
+ SET_WindowPos2dvMESA(disp, glWindowPos2dvMESA);
+ SET_WindowPos2fMESA(disp, glWindowPos2fMESA);
+ SET_WindowPos2fvMESA(disp, glWindowPos2fvMESA);
+ SET_WindowPos2iMESA(disp, glWindowPos2iMESA);
+ SET_WindowPos2ivMESA(disp, glWindowPos2ivMESA);
+ SET_WindowPos2sMESA(disp, glWindowPos2sMESA);
+ SET_WindowPos2svMESA(disp, glWindowPos2svMESA);
+ SET_WindowPos3dMESA(disp, glWindowPos3dMESA);
+ SET_WindowPos3dvMESA(disp, glWindowPos3dvMESA);
+ SET_WindowPos3fMESA(disp, glWindowPos3fMESA);
+ SET_WindowPos3fvMESA(disp, glWindowPos3fvMESA);
+ SET_WindowPos3iMESA(disp, glWindowPos3iMESA);
+ SET_WindowPos3ivMESA(disp, glWindowPos3ivMESA);
+ SET_WindowPos3sMESA(disp, glWindowPos3sMESA);
+ SET_WindowPos3svMESA(disp, glWindowPos3svMESA);
+ SET_WindowPos4dMESA(disp, glWindowPos4dMESA);
+ SET_WindowPos4dvMESA(disp, glWindowPos4dvMESA);
+ SET_WindowPos4fMESA(disp, glWindowPos4fMESA);
+ SET_WindowPos4fvMESA(disp, glWindowPos4fvMESA);
+ SET_WindowPos4iMESA(disp, glWindowPos4iMESA);
+ SET_WindowPos4ivMESA(disp, glWindowPos4ivMESA);
+ SET_WindowPos4sMESA(disp, glWindowPos4sMESA);
+ SET_WindowPos4svMESA(disp, glWindowPos4svMESA);
+ SET_BlendFuncSeparateEXT(disp, glBlendFuncSeparateEXT);
+ SET_IndexMaterialEXT(disp, glIndexMaterialEXT);
+ SET_IndexFuncEXT(disp, glIndexFuncEXT);
+ SET_LockArraysEXT(disp, glLockArraysEXT);
+ SET_UnlockArraysEXT(disp, glUnlockArraysEXT);
+ SET_CullParameterdvEXT(disp, glCullParameterdvEXT);
+ SET_CullParameterfvEXT(disp, glCullParameterfvEXT);
+ SET_HintPGI(disp, glHintPGI);
+ SET_FogCoordfEXT(disp, glFogCoordfEXT);
+ SET_FogCoordfvEXT(disp, glFogCoordfvEXT);
+ SET_FogCoorddEXT(disp, glFogCoorddEXT);
+ SET_FogCoorddvEXT(disp, glFogCoorddvEXT);
+ SET_FogCoordPointerEXT(disp, glFogCoordPointerEXT);
+ SET_GetColorTableEXT(disp, glGetColorTableEXT);
+ SET_GetColorTableParameterivEXT(disp, glGetColorTableParameterivEXT);
+ SET_GetColorTableParameterfvEXT(disp, glGetColorTableParameterfvEXT);
+ SET_TbufferMask3DFX(disp, glTbufferMask3DFX);
+ SET_CompressedTexImage3DARB(disp, glCompressedTexImage3DARB);
+ SET_CompressedTexImage2DARB(disp, glCompressedTexImage2DARB);
+ SET_CompressedTexImage1DARB(disp, glCompressedTexImage1DARB);
+ SET_CompressedTexSubImage3DARB(disp, glCompressedTexSubImage3DARB);
+ SET_CompressedTexSubImage2DARB(disp, glCompressedTexSubImage2DARB);
+ SET_CompressedTexSubImage1DARB(disp, glCompressedTexSubImage1DARB);
+ SET_GetCompressedTexImageARB(disp, glGetCompressedTexImageARB);
+ SET_SecondaryColor3bEXT(disp, glSecondaryColor3bEXT);
+ SET_SecondaryColor3bvEXT(disp, glSecondaryColor3bvEXT);
+ SET_SecondaryColor3dEXT(disp, glSecondaryColor3dEXT);
+ SET_SecondaryColor3dvEXT(disp, glSecondaryColor3dvEXT);
+ SET_SecondaryColor3fEXT(disp, glSecondaryColor3fEXT);
+ SET_SecondaryColor3fvEXT(disp, glSecondaryColor3fvEXT);
+ SET_SecondaryColor3iEXT(disp, glSecondaryColor3iEXT);
+ SET_SecondaryColor3ivEXT(disp, glSecondaryColor3ivEXT);
+ SET_SecondaryColor3sEXT(disp, glSecondaryColor3sEXT);
+ SET_SecondaryColor3svEXT(disp, glSecondaryColor3svEXT);
+ SET_SecondaryColor3ubEXT(disp, glSecondaryColor3ubEXT);
+ SET_SecondaryColor3ubvEXT(disp, glSecondaryColor3ubvEXT);
+ SET_SecondaryColor3uiEXT(disp, glSecondaryColor3uiEXT);
+ SET_SecondaryColor3uivEXT(disp, glSecondaryColor3uivEXT);
+ SET_SecondaryColor3usEXT(disp, glSecondaryColor3usEXT);
+ SET_SecondaryColor3usvEXT(disp, glSecondaryColor3usvEXT);
+ SET_SecondaryColorPointerEXT(disp, glSecondaryColorPointerEXT);
+ SET_AreProgramsResidentNV(disp, glAreProgramsResidentNV);
+ SET_BindProgramNV(disp, glBindProgramNV);
+ SET_DeleteProgramsNV(disp, glDeleteProgramsNV);
+ SET_ExecuteProgramNV(disp, glExecuteProgramNV);
+ SET_GenProgramsNV(disp, glGenProgramsNV);
+ SET_GetProgramParameterdvNV(disp, glGetProgramParameterdvNV);
+ SET_GetProgramParameterfvNV(disp, glGetProgramParameterfvNV);
+ SET_GetProgramivNV(disp, glGetProgramivNV);
+ SET_GetProgramStringNV(disp, glGetProgramStringNV);
+ SET_GetTrackMatrixivNV(disp, glGetTrackMatrixivNV);
+ SET_GetVertexAttribdvARB(disp, glGetVertexAttribdvARB);
+ SET_GetVertexAttribfvARB(disp, glGetVertexAttribfvARB);
+ SET_GetVertexAttribivARB(disp, glGetVertexAttribivARB);
+ SET_GetVertexAttribPointervNV(disp, glGetVertexAttribPointervNV);
+ SET_IsProgramNV(disp, glIsProgramNV);
+ SET_LoadProgramNV(disp, glLoadProgramNV);
+ SET_ProgramParameter4dNV(disp, glProgramParameter4dNV);
+ SET_ProgramParameter4dvNV(disp, glProgramParameter4dvNV);
+ SET_ProgramParameter4fNV(disp, glProgramParameter4fNV);
+ SET_ProgramParameter4fvNV(disp, glProgramParameter4fvNV);
+ SET_ProgramParameters4dvNV(disp, glProgramParameters4dvNV);
+ SET_ProgramParameters4fvNV(disp, glProgramParameters4fvNV);
+ SET_RequestResidentProgramsNV(disp, glRequestResidentProgramsNV);
+ SET_TrackMatrixNV(disp, glTrackMatrixNV);
+ SET_VertexAttribPointerNV(disp, glVertexAttribPointerNV);
+ SET_VertexAttrib1dARB(disp, glVertexAttrib1dARB);
+ SET_VertexAttrib1dvARB(disp, glVertexAttrib1dvARB);
+ SET_VertexAttrib1fARB(disp, glVertexAttrib1fARB);
+ SET_VertexAttrib1fvARB(disp, glVertexAttrib1fvARB);
+ SET_VertexAttrib1sARB(disp, glVertexAttrib1sARB);
+ SET_VertexAttrib1svARB(disp, glVertexAttrib1svARB);
+ SET_VertexAttrib2dARB(disp, glVertexAttrib2dARB);
+ SET_VertexAttrib2dvARB(disp, glVertexAttrib2dvARB);
+ SET_VertexAttrib2fARB(disp, glVertexAttrib2fARB);
+ SET_VertexAttrib2fvARB(disp, glVertexAttrib2fvARB);
+ SET_VertexAttrib2sARB(disp, glVertexAttrib2sARB);
+ SET_VertexAttrib2svARB(disp, glVertexAttrib2svARB);
+ SET_VertexAttrib3dARB(disp, glVertexAttrib3dARB);
+ SET_VertexAttrib3dvARB(disp, glVertexAttrib3dvARB);
+ SET_VertexAttrib3fARB(disp, glVertexAttrib3fARB);
+ SET_VertexAttrib3fvARB(disp, glVertexAttrib3fvARB);
+ SET_VertexAttrib3sARB(disp, glVertexAttrib3sARB);
+ SET_VertexAttrib3svARB(disp, glVertexAttrib3svARB);
+ SET_VertexAttrib4dARB(disp, glVertexAttrib4dARB);
+ SET_VertexAttrib4dvARB(disp, glVertexAttrib4dvARB);
+ SET_VertexAttrib4fARB(disp, glVertexAttrib4fARB);
+ SET_VertexAttrib4fvARB(disp, glVertexAttrib4fvARB);
+ SET_VertexAttrib4sARB(disp, glVertexAttrib4sARB);
+ SET_VertexAttrib4svARB(disp, glVertexAttrib4svARB);
+ SET_VertexAttrib4NubARB(disp, glVertexAttrib4NubARB);
+ SET_VertexAttrib4NubvARB(disp, glVertexAttrib4NubvARB);
+ SET_VertexAttribs1dvNV(disp, glVertexAttribs1dvNV);
+ SET_VertexAttribs1fvNV(disp, glVertexAttribs1fvNV);
+ SET_VertexAttribs1svNV(disp, glVertexAttribs1svNV);
+ SET_VertexAttribs2dvNV(disp, glVertexAttribs2dvNV);
+ SET_VertexAttribs2fvNV(disp, glVertexAttribs2fvNV);
+ SET_VertexAttribs2svNV(disp, glVertexAttribs2svNV);
+ SET_VertexAttribs3dvNV(disp, glVertexAttribs3dvNV);
+ SET_VertexAttribs3fvNV(disp, glVertexAttribs3fvNV);
+ SET_VertexAttribs3svNV(disp, glVertexAttribs3svNV);
+ SET_VertexAttribs4dvNV(disp, glVertexAttribs4dvNV);
+ SET_VertexAttribs4fvNV(disp, glVertexAttribs4fvNV);
+ SET_VertexAttribs4svNV(disp, glVertexAttribs4svNV);
+ SET_VertexAttribs4ubvNV(disp, glVertexAttribs4ubvNV);
+ SET_PointParameteriNV(disp, glPointParameteriNV);
+ SET_PointParameterivNV(disp, glPointParameterivNV);
+ SET_MultiDrawArraysEXT(disp, glMultiDrawArraysEXT);
+ SET_MultiDrawElementsEXT(disp, glMultiDrawElementsEXT);
+ SET_ActiveStencilFaceEXT(disp, glActiveStencilFaceEXT);
+ SET_DeleteFencesNV(disp, glDeleteFencesNV);
+ SET_GenFencesNV(disp, glGenFencesNV);
+ SET_IsFenceNV(disp, glIsFenceNV);
+ SET_TestFenceNV(disp, glTestFenceNV);
+ SET_GetFenceivNV(disp, glGetFenceivNV);
+ SET_FinishFenceNV(disp, glFinishFenceNV);
+ SET_SetFenceNV(disp, glSetFenceNV);
+ SET_VertexAttrib4bvARB(disp, glVertexAttrib4bvARB);
+ SET_VertexAttrib4ivARB(disp, glVertexAttrib4ivARB);
+ SET_VertexAttrib4ubvARB(disp, glVertexAttrib4ubvARB);
+ SET_VertexAttrib4usvARB(disp, glVertexAttrib4usvARB);
+ SET_VertexAttrib4uivARB(disp, glVertexAttrib4uivARB);
+ SET_VertexAttrib4NbvARB(disp, glVertexAttrib4NbvARB);
+ SET_VertexAttrib4NsvARB(disp, glVertexAttrib4NsvARB);
+ SET_VertexAttrib4NivARB(disp, glVertexAttrib4NivARB);
+ SET_VertexAttrib4NusvARB(disp, glVertexAttrib4NusvARB);
+ SET_VertexAttrib4NuivARB(disp, glVertexAttrib4NuivARB);
+ SET_VertexAttribPointerARB(disp, glVertexAttribPointerARB);
+ SET_EnableVertexAttribArrayARB(disp, glEnableVertexAttribArrayARB);
+ SET_DisableVertexAttribArrayARB(disp, glDisableVertexAttribArrayARB);
+ SET_ProgramStringARB(disp, glProgramStringARB);
+ SET_ProgramEnvParameter4dARB(disp, glProgramEnvParameter4dARB);
+ SET_ProgramEnvParameter4dvARB(disp, glProgramEnvParameter4dvARB);
+ SET_ProgramEnvParameter4fARB(disp, glProgramEnvParameter4fARB);
+ SET_ProgramEnvParameter4fvARB(disp, glProgramEnvParameter4fvARB);
+ SET_ProgramLocalParameter4dARB(disp, glProgramLocalParameter4dARB);
+ SET_ProgramLocalParameter4dvARB(disp, glProgramLocalParameter4dvARB);
+ SET_ProgramLocalParameter4fARB(disp, glProgramLocalParameter4fARB);
+ SET_ProgramLocalParameter4fvARB(disp, glProgramLocalParameter4fvARB);
+ SET_GetProgramEnvParameterdvARB(disp, glGetProgramEnvParameterdvARB);
+ SET_GetProgramEnvParameterfvARB(disp, glGetProgramEnvParameterfvARB);
+ SET_GetProgramLocalParameterdvARB(disp, glGetProgramLocalParameterdvARB);
+ SET_GetProgramLocalParameterfvARB(disp, glGetProgramLocalParameterfvARB);
+ SET_GetProgramivARB(disp, glGetProgramivARB);
+ SET_GetProgramStringARB(disp, glGetProgramStringARB);
+ SET_ProgramNamedParameter4fNV(disp, glProgramNamedParameter4fNV);
+ SET_ProgramNamedParameter4dNV(disp, glProgramNamedParameter4dNV);
+ SET_ProgramNamedParameter4fvNV(disp, glProgramNamedParameter4fvNV);
+ SET_ProgramNamedParameter4dvNV(disp, glProgramNamedParameter4dvNV);
+ SET_GetProgramNamedParameterfvNV(disp, glGetProgramNamedParameterfvNV);
+ SET_GetProgramNamedParameterdvNV(disp, glGetProgramNamedParameterdvNV);
+ SET_BindBufferARB(disp, glBindBufferARB);
+ SET_BufferDataARB(disp, glBufferDataARB);
+ SET_BufferSubDataARB(disp, glBufferSubDataARB);
+ SET_DeleteBuffersARB(disp, glDeleteBuffersARB);
+ SET_GenBuffersARB(disp, glGenBuffersARB);
+ SET_GetBufferParameterivARB(disp, glGetBufferParameterivARB);
+ SET_GetBufferPointervARB(disp, glGetBufferPointervARB);
+ SET_GetBufferSubDataARB(disp, glGetBufferSubDataARB);
+ SET_IsBufferARB(disp, glIsBufferARB);
+ SET_MapBufferARB(disp, glMapBufferARB);
+ SET_UnmapBufferARB(disp, glUnmapBufferARB);
+ SET_DepthBoundsEXT(disp, glDepthBoundsEXT);
+ SET_GenQueriesARB(disp, glGenQueriesARB);
+ SET_DeleteQueriesARB(disp, glDeleteQueriesARB);
+ SET_IsQueryARB(disp, glIsQueryARB);
+ SET_BeginQueryARB(disp, glBeginQueryARB);
+ SET_EndQueryARB(disp, glEndQueryARB);
+ SET_GetQueryivARB(disp, glGetQueryivARB);
+ SET_GetQueryObjectivARB(disp, glGetQueryObjectivARB);
+ SET_GetQueryObjectuivARB(disp, glGetQueryObjectuivARB);
+ SET_MultiModeDrawArraysIBM(disp, glMultiModeDrawArraysIBM);
+ SET_MultiModeDrawElementsIBM(disp, glMultiModeDrawElementsIBM);
+ SET_BlendEquationSeparateEXT(disp, glBlendEquationSeparateEXT);
+ SET_DeleteObjectARB(disp, glDeleteObjectARB);
+ SET_GetHandleARB(disp, glGetHandleARB);
+ SET_DetachObjectARB(disp, glDetachObjectARB);
+ SET_CreateShaderObjectARB(disp, glCreateShaderObjectARB);
+ SET_ShaderSourceARB(disp, glShaderSourceARB);
+ SET_CompileShaderARB(disp, glCompileShaderARB);
+ SET_CreateProgramObjectARB(disp, glCreateProgramObjectARB);
+ SET_AttachObjectARB(disp, glAttachObjectARB);
+ SET_LinkProgramARB(disp, glLinkProgramARB);
+ SET_UseProgramObjectARB(disp, glUseProgramObjectARB);
+ SET_ValidateProgramARB(disp, glValidateProgramARB);
+ SET_Uniform1fARB(disp, glUniform1fARB);
+ SET_Uniform2fARB(disp, glUniform2fARB);
+ SET_Uniform3fARB(disp, glUniform3fARB);
+ SET_Uniform4fARB(disp, glUniform4fARB);
+ SET_Uniform1iARB(disp, glUniform1iARB);
+ SET_Uniform2iARB(disp, glUniform2iARB);
+ SET_Uniform3iARB(disp, glUniform3iARB);
+ SET_Uniform4iARB(disp, glUniform4iARB);
+ SET_Uniform1fvARB(disp, glUniform1fvARB);
+ SET_Uniform2fvARB(disp, glUniform2fvARB);
+ SET_Uniform3fvARB(disp, glUniform3fvARB);
+ SET_Uniform4fvARB(disp, glUniform4fvARB);
+ SET_Uniform1ivARB(disp, glUniform1ivARB);
+ SET_Uniform2ivARB(disp, glUniform2ivARB);
+ SET_Uniform3ivARB(disp, glUniform3ivARB);
+ SET_Uniform4ivARB(disp, glUniform4ivARB);
+ SET_UniformMatrix2fvARB(disp, glUniformMatrix2fvARB);
+ SET_UniformMatrix3fvARB(disp, glUniformMatrix3fvARB);
+ SET_UniformMatrix4fvARB(disp, glUniformMatrix4fvARB);
+ SET_GetObjectParameterfvARB(disp, glGetObjectParameterfvARB);
+ SET_GetObjectParameterivARB(disp, glGetObjectParameterivARB);
+ SET_GetInfoLogARB(disp, glGetInfoLogARB);
+ SET_GetAttachedObjectsARB(disp, glGetAttachedObjectsARB);
+ SET_GetUniformLocationARB(disp, glGetUniformLocationARB);
+ SET_GetActiveUniformARB(disp, glGetActiveUniformARB);
+ SET_GetUniformfvARB(disp, glGetUniformfvARB);
+ SET_GetUniformivARB(disp, glGetUniformivARB);
+ SET_GetShaderSourceARB(disp, glGetShaderSourceARB);
+ SET_BindAttribLocationARB(disp, glBindAttribLocationARB);
+ SET_GetActiveAttribARB(disp, glGetActiveAttribARB);
+ SET_GetAttribLocationARB(disp, glGetAttribLocationARB);
+ SET_GetVertexAttribdvNV(disp, glGetVertexAttribdvNV);
+ SET_GetVertexAttribfvNV(disp, glGetVertexAttribfvNV);
+ SET_GetVertexAttribivNV(disp, glGetVertexAttribivNV);
+ SET_VertexAttrib1dNV(disp, glVertexAttrib1dNV);
+ SET_VertexAttrib1dvNV(disp, glVertexAttrib1dvNV);
+ SET_VertexAttrib1fNV(disp, glVertexAttrib1fNV);
+ SET_VertexAttrib1fvNV(disp, glVertexAttrib1fvNV);
+ SET_VertexAttrib1sNV(disp, glVertexAttrib1sNV);
+ SET_VertexAttrib1svNV(disp, glVertexAttrib1svNV);
+ SET_VertexAttrib2dNV(disp, glVertexAttrib2dNV);
+ SET_VertexAttrib2dvNV(disp, glVertexAttrib2dvNV);
+ SET_VertexAttrib2fNV(disp, glVertexAttrib2fNV);
+ SET_VertexAttrib2fvNV(disp, glVertexAttrib2fvNV);
+ SET_VertexAttrib2sNV(disp, glVertexAttrib2sNV);
+ SET_VertexAttrib2svNV(disp, glVertexAttrib2svNV);
+ SET_VertexAttrib3dNV(disp, glVertexAttrib3dNV);
+ SET_VertexAttrib3dvNV(disp, glVertexAttrib3dvNV);
+ SET_VertexAttrib3fNV(disp, glVertexAttrib3fNV);
+ SET_VertexAttrib3fvNV(disp, glVertexAttrib3fvNV);
+ SET_VertexAttrib3sNV(disp, glVertexAttrib3sNV);
+ SET_VertexAttrib3svNV(disp, glVertexAttrib3svNV);
+ SET_VertexAttrib4dNV(disp, glVertexAttrib4dNV);
+ SET_VertexAttrib4dvNV(disp, glVertexAttrib4dvNV);
+ SET_VertexAttrib4fNV(disp, glVertexAttrib4fNV);
+ SET_VertexAttrib4fvNV(disp, glVertexAttrib4fvNV);
+ SET_VertexAttrib4sNV(disp, glVertexAttrib4sNV);
+ SET_VertexAttrib4svNV(disp, glVertexAttrib4svNV);
+ SET_VertexAttrib4ubNV(disp, glVertexAttrib4ubNV);
+ SET_VertexAttrib4ubvNV(disp, glVertexAttrib4ubvNV);
+ SET_GenFragmentShadersATI(disp, glGenFragmentShadersATI);
+ SET_BindFragmentShaderATI(disp, glBindFragmentShaderATI);
+ SET_DeleteFragmentShaderATI(disp, glDeleteFragmentShaderATI);
+ SET_BeginFragmentShaderATI(disp, glBeginFragmentShaderATI);
+ SET_EndFragmentShaderATI(disp, glEndFragmentShaderATI);
+ SET_PassTexCoordATI(disp, glPassTexCoordATI);
+ SET_SampleMapATI(disp, glSampleMapATI);
+ SET_ColorFragmentOp1ATI(disp, glColorFragmentOp1ATI);
+ SET_ColorFragmentOp2ATI(disp, glColorFragmentOp2ATI);
+ SET_ColorFragmentOp3ATI(disp, glColorFragmentOp3ATI);
+ SET_AlphaFragmentOp1ATI(disp, glAlphaFragmentOp1ATI);
+ SET_AlphaFragmentOp2ATI(disp, glAlphaFragmentOp2ATI);
+ SET_AlphaFragmentOp3ATI(disp, glAlphaFragmentOp3ATI);
+ SET_SetFragmentShaderConstantATI(disp, glSetFragmentShaderConstantATI);
+ SET_IsRenderbufferEXT(disp, glIsRenderbufferEXT);
+ SET_BindRenderbufferEXT(disp, glBindRenderbufferEXT);
+ SET_DeleteRenderbuffersEXT(disp, glDeleteRenderbuffersEXT);
+ SET_GenRenderbuffersEXT(disp, glGenRenderbuffersEXT);
+ SET_RenderbufferStorageEXT(disp, glRenderbufferStorageEXT);
+ SET_GetRenderbufferParameterivEXT(disp, glGetRenderbufferParameterivEXT);
+ SET_IsFramebufferEXT(disp, glIsFramebufferEXT);
+ SET_BindFramebufferEXT(disp, glBindFramebufferEXT);
+ SET_DeleteFramebuffersEXT(disp, glDeleteFramebuffersEXT);
+ SET_GenFramebuffersEXT(disp, glGenFramebuffersEXT);
+ SET_CheckFramebufferStatusEXT(disp, glCheckFramebufferStatusEXT);
+ SET_FramebufferTexture1DEXT(disp, glFramebufferTexture1DEXT);
+ SET_FramebufferTexture2DEXT(disp, glFramebufferTexture2DEXT);
+ SET_FramebufferTexture3DEXT(disp, glFramebufferTexture3DEXT);
+ SET_FramebufferRenderbufferEXT(disp, glFramebufferRenderbufferEXT);
+ SET_GetFramebufferAttachmentParameterivEXT(disp, glGetFramebufferAttachmentParameterivEXT);
+ SET_GenerateMipmapEXT(disp, glGenerateMipmapEXT);
+ SET_StencilFuncSeparate(disp, glStencilFuncSeparate);
+ SET_StencilOpSeparate(disp, glStencilOpSeparate);
+ SET_StencilMaskSeparate(disp, glStencilMaskSeparate);
+ SET_GetQueryObjecti64vEXT(disp, glGetQueryObjecti64vEXT);
+ SET_GetQueryObjectui64vEXT(disp, glGetQueryObjectui64vEXT);
+ SET_BlitFramebufferEXT(disp, glBlitFramebufferEXT);
+ SET_LoadTransposeMatrixfARB(disp, glLoadTransposeMatrixfARB);
+ SET_LoadTransposeMatrixdARB(disp, glLoadTransposeMatrixdARB);
+ SET_MultTransposeMatrixfARB(disp, glMultTransposeMatrixfARB);
+ SET_MultTransposeMatrixdARB(disp, glMultTransposeMatrixdARB);
+ SET_SampleCoverageARB(disp, glSampleCoverageARB);
+ SET_DrawBuffersARB(disp, glDrawBuffersARB);
+ SET_PolygonOffsetEXT(disp, glPolygonOffsetEXT);
+ SET_GetTexFilterFuncSGIS(disp, glGetTexFilterFuncSGIS);
+ SET_TexFilterFuncSGIS(disp, glTexFilterFuncSGIS);
+ SET_GetHistogramEXT(disp, glGetHistogramEXT);
+ SET_GetHistogramParameterfvEXT(disp, glGetHistogramParameterfvEXT);
+ SET_GetHistogramParameterivEXT(disp, glGetHistogramParameterivEXT);
+ SET_GetMinmaxEXT(disp, glGetMinmaxEXT);
+ SET_GetMinmaxParameterfvEXT(disp, glGetMinmaxParameterfvEXT);
+ SET_GetMinmaxParameterivEXT(disp, glGetMinmaxParameterivEXT);
+ SET_GetConvolutionFilterEXT(disp, glGetConvolutionFilterEXT);
+ SET_GetConvolutionParameterfvEXT(disp, glGetConvolutionParameterfvEXT);
+ SET_GetConvolutionParameterivEXT(disp, glGetConvolutionParameterivEXT);
+ SET_GetSeparableFilterEXT(disp, glGetSeparableFilterEXT);
+ SET_GetColorTableSGI(disp, glGetColorTableSGI);
+ SET_GetColorTableParameterfvSGI(disp, glGetColorTableParameterfvSGI);
+ SET_GetColorTableParameterivSGI(disp, glGetColorTableParameterivSGI);
+ SET_PixelTexGenSGIX(disp, glPixelTexGenSGIX);
+ SET_PixelTexGenParameteriSGIS(disp, glPixelTexGenParameteriSGIS);
+ SET_PixelTexGenParameterivSGIS(disp, glPixelTexGenParameterivSGIS);
+ SET_PixelTexGenParameterfSGIS(disp, glPixelTexGenParameterfSGIS);
+ SET_PixelTexGenParameterfvSGIS(disp, glPixelTexGenParameterfvSGIS);
+ SET_GetPixelTexGenParameterivSGIS(disp, glGetPixelTexGenParameterivSGIS);
+ SET_GetPixelTexGenParameterfvSGIS(disp, glGetPixelTexGenParameterfvSGIS);
+ SET_TexImage4DSGIS(disp, glTexImage4DSGIS);
+ SET_TexSubImage4DSGIS(disp, glTexSubImage4DSGIS);
+ SET_AreTexturesResidentEXT(disp, glAreTexturesResidentEXT);
+ SET_GenTexturesEXT(disp, glGenTexturesEXT);
+ SET_IsTextureEXT(disp, glIsTextureEXT);
+ SET_DetailTexFuncSGIS(disp, glDetailTexFuncSGIS);
+ SET_GetDetailTexFuncSGIS(disp, glGetDetailTexFuncSGIS);
+ SET_SharpenTexFuncSGIS(disp, glSharpenTexFuncSGIS);
+ SET_GetSharpenTexFuncSGIS(disp, glGetSharpenTexFuncSGIS);
+ SET_SampleMaskSGIS(disp, glSampleMaskSGIS);
+ SET_SamplePatternSGIS(disp, glSamplePatternSGIS);
+ SET_ColorPointerEXT(disp, glColorPointerEXT);
+ SET_EdgeFlagPointerEXT(disp, glEdgeFlagPointerEXT);
+ SET_IndexPointerEXT(disp, glIndexPointerEXT);
+ SET_NormalPointerEXT(disp, glNormalPointerEXT);
+ SET_TexCoordPointerEXT(disp, glTexCoordPointerEXT);
+ SET_VertexPointerEXT(disp, glVertexPointerEXT);
+ SET_SpriteParameterfSGIX(disp, glSpriteParameterfSGIX);
+ SET_SpriteParameterfvSGIX(disp, glSpriteParameterfvSGIX);
+ SET_SpriteParameteriSGIX(disp, glSpriteParameteriSGIX);
+ SET_SpriteParameterivSGIX(disp, glSpriteParameterivSGIX);
+ SET_PointParameterfEXT(disp, glPointParameterfEXT);
+ SET_PointParameterfvEXT(disp, glPointParameterfvEXT);
+ SET_GetInstrumentsSGIX(disp, glGetInstrumentsSGIX);
+ SET_InstrumentsBufferSGIX(disp, glInstrumentsBufferSGIX);
+ SET_PollInstrumentsSGIX(disp, glPollInstrumentsSGIX);
+ SET_ReadInstrumentsSGIX(disp, glReadInstrumentsSGIX);
+ SET_StartInstrumentsSGIX(disp, glStartInstrumentsSGIX);
+ SET_StopInstrumentsSGIX(disp, glStopInstrumentsSGIX);
+ SET_FrameZoomSGIX(disp, glFrameZoomSGIX);
+ SET_TagSampleBufferSGIX(disp, glTagSampleBufferSGIX);
+ SET_ReferencePlaneSGIX(disp, glReferencePlaneSGIX);
+ SET_FlushRasterSGIX(disp, glFlushRasterSGIX);
+ SET_GetListParameterfvSGIX(disp, glGetListParameterfvSGIX);
+ SET_GetListParameterivSGIX(disp, glGetListParameterivSGIX);
+ SET_ListParameterfSGIX(disp, glListParameterfSGIX);
+ SET_ListParameterfvSGIX(disp, glListParameterfvSGIX);
+ SET_ListParameteriSGIX(disp, glListParameteriSGIX);
+ SET_ListParameterivSGIX(disp, glListParameterivSGIX);
+ SET_FragmentColorMaterialSGIX(disp, glFragmentColorMaterialSGIX);
+ SET_FragmentLightfSGIX(disp, glFragmentLightfSGIX);
+ SET_FragmentLightfvSGIX(disp, glFragmentLightfvSGIX);
+ SET_FragmentLightiSGIX(disp, glFragmentLightiSGIX);
+ SET_FragmentLightivSGIX(disp, glFragmentLightivSGIX);
+ SET_FragmentLightModelfSGIX(disp, glFragmentLightModelfSGIX);
+ SET_FragmentLightModelfvSGIX(disp, glFragmentLightModelfvSGIX);
+ SET_FragmentLightModeliSGIX(disp, glFragmentLightModeliSGIX);
+ SET_FragmentLightModelivSGIX(disp, glFragmentLightModelivSGIX);
+ SET_FragmentMaterialfSGIX(disp, glFragmentMaterialfSGIX);
+ SET_FragmentMaterialfvSGIX(disp, glFragmentMaterialfvSGIX);
+ SET_FragmentMaterialiSGIX(disp, glFragmentMaterialiSGIX);
+ SET_FragmentMaterialivSGIX(disp, glFragmentMaterialivSGIX);
+ SET_GetFragmentLightfvSGIX(disp, glGetFragmentLightfvSGIX);
+ SET_GetFragmentLightivSGIX(disp, glGetFragmentLightivSGIX);
+ SET_GetFragmentMaterialfvSGIX(disp, glGetFragmentMaterialfvSGIX);
+ SET_GetFragmentMaterialivSGIX(disp, glGetFragmentMaterialivSGIX);
+ SET_LightEnviSGIX(disp, glLightEnviSGIX);
+ SET_VertexWeightfEXT(disp, glVertexWeightfEXT);
+ SET_VertexWeightfvEXT(disp, glVertexWeightfvEXT);
+ SET_VertexWeightPointerEXT(disp, glVertexWeightPointerEXT);
+ SET_FlushVertexArrayRangeNV(disp, glFlushVertexArrayRangeNV);
+ SET_VertexArrayRangeNV(disp, glVertexArrayRangeNV);
+ SET_CombinerParameterfvNV(disp, glCombinerParameterfvNV);
+ SET_CombinerParameterfNV(disp, glCombinerParameterfNV);
+ SET_CombinerParameterivNV(disp, glCombinerParameterivNV);
+ SET_CombinerParameteriNV(disp, glCombinerParameteriNV);
+ SET_CombinerInputNV(disp, glCombinerInputNV);
+ SET_CombinerOutputNV(disp, glCombinerOutputNV);
+ SET_FinalCombinerInputNV(disp, glFinalCombinerInputNV);
+ SET_GetCombinerInputParameterfvNV(disp, glGetCombinerInputParameterfvNV);
+ SET_GetCombinerInputParameterivNV(disp, glGetCombinerInputParameterivNV);
+ SET_GetCombinerOutputParameterfvNV(disp, glGetCombinerOutputParameterfvNV);
+ SET_GetCombinerOutputParameterivNV(disp, glGetCombinerOutputParameterivNV);
+ SET_GetFinalCombinerInputParameterfvNV(disp, glGetFinalCombinerInputParameterfvNV);
+ SET_GetFinalCombinerInputParameterivNV(disp, glGetFinalCombinerInputParameterivNV);
+ SET_ResizeBuffersMESA(disp, glResizeBuffersMESA);
+ SET_WindowPos2dMESA(disp, glWindowPos2dMESA);
+ SET_WindowPos2dvMESA(disp, glWindowPos2dvMESA);
+ SET_WindowPos2fMESA(disp, glWindowPos2fMESA);
+ SET_WindowPos2fvMESA(disp, glWindowPos2fvMESA);
+ SET_WindowPos2iMESA(disp, glWindowPos2iMESA);
+ SET_WindowPos2ivMESA(disp, glWindowPos2ivMESA);
+ SET_WindowPos2sMESA(disp, glWindowPos2sMESA);
+ SET_WindowPos2svMESA(disp, glWindowPos2svMESA);
+ SET_WindowPos3dMESA(disp, glWindowPos3dMESA);
+ SET_WindowPos3dvMESA(disp, glWindowPos3dvMESA);
+ SET_WindowPos3fMESA(disp, glWindowPos3fMESA);
+ SET_WindowPos3fvMESA(disp, glWindowPos3fvMESA);
+ SET_WindowPos3iMESA(disp, glWindowPos3iMESA);
+ SET_WindowPos3ivMESA(disp, glWindowPos3ivMESA);
+ SET_WindowPos3sMESA(disp, glWindowPos3sMESA);
+ SET_WindowPos3svMESA(disp, glWindowPos3svMESA);
+ SET_WindowPos4dMESA(disp, glWindowPos4dMESA);
+ SET_WindowPos4dvMESA(disp, glWindowPos4dvMESA);
+ SET_WindowPos4fMESA(disp, glWindowPos4fMESA);
+ SET_WindowPos4fvMESA(disp, glWindowPos4fvMESA);
+ SET_WindowPos4iMESA(disp, glWindowPos4iMESA);
+ SET_WindowPos4ivMESA(disp, glWindowPos4ivMESA);
+ SET_WindowPos4sMESA(disp, glWindowPos4sMESA);
+ SET_WindowPos4svMESA(disp, glWindowPos4svMESA);
+ SET_BlendFuncSeparateEXT(disp, glBlendFuncSeparateEXT);
+ SET_IndexMaterialEXT(disp, glIndexMaterialEXT);
+ SET_IndexFuncEXT(disp, glIndexFuncEXT);
+ SET_LockArraysEXT(disp, glLockArraysEXT);
+ SET_UnlockArraysEXT(disp, glUnlockArraysEXT);
+ SET_CullParameterdvEXT(disp, glCullParameterdvEXT);
+ SET_CullParameterfvEXT(disp, glCullParameterfvEXT);
+ SET_HintPGI(disp, glHintPGI);
+ SET_FogCoordfEXT(disp, glFogCoordfEXT);
+ SET_FogCoordfvEXT(disp, glFogCoordfvEXT);
+ SET_FogCoorddEXT(disp, glFogCoorddEXT);
+ SET_FogCoorddvEXT(disp, glFogCoorddvEXT);
+ SET_FogCoordPointerEXT(disp, glFogCoordPointerEXT);
+ SET_GetColorTableEXT(disp, glGetColorTableEXT);
+ SET_GetColorTableParameterivEXT(disp, glGetColorTableParameterivEXT);
+ SET_GetColorTableParameterfvEXT(disp, glGetColorTableParameterfvEXT);
+ SET_TbufferMask3DFX(disp, glTbufferMask3DFX);
+ SET_CompressedTexImage3DARB(disp, glCompressedTexImage3DARB);
+ SET_CompressedTexImage2DARB(disp, glCompressedTexImage2DARB);
+ SET_CompressedTexImage1DARB(disp, glCompressedTexImage1DARB);
+ SET_CompressedTexSubImage3DARB(disp, glCompressedTexSubImage3DARB);
+ SET_CompressedTexSubImage2DARB(disp, glCompressedTexSubImage2DARB);
+ SET_CompressedTexSubImage1DARB(disp, glCompressedTexSubImage1DARB);
+ SET_GetCompressedTexImageARB(disp, glGetCompressedTexImageARB);
+ SET_SecondaryColor3bEXT(disp, glSecondaryColor3bEXT);
+ SET_SecondaryColor3bvEXT(disp, glSecondaryColor3bvEXT);
+ SET_SecondaryColor3dEXT(disp, glSecondaryColor3dEXT);
+ SET_SecondaryColor3dvEXT(disp, glSecondaryColor3dvEXT);
+ SET_SecondaryColor3fEXT(disp, glSecondaryColor3fEXT);
+ SET_SecondaryColor3fvEXT(disp, glSecondaryColor3fvEXT);
+ SET_SecondaryColor3iEXT(disp, glSecondaryColor3iEXT);
+ SET_SecondaryColor3ivEXT(disp, glSecondaryColor3ivEXT);
+ SET_SecondaryColor3sEXT(disp, glSecondaryColor3sEXT);
+ SET_SecondaryColor3svEXT(disp, glSecondaryColor3svEXT);
+ SET_SecondaryColor3ubEXT(disp, glSecondaryColor3ubEXT);
+ SET_SecondaryColor3ubvEXT(disp, glSecondaryColor3ubvEXT);
+ SET_SecondaryColor3uiEXT(disp, glSecondaryColor3uiEXT);
+ SET_SecondaryColor3uivEXT(disp, glSecondaryColor3uivEXT);
+ SET_SecondaryColor3usEXT(disp, glSecondaryColor3usEXT);
+ SET_SecondaryColor3usvEXT(disp, glSecondaryColor3usvEXT);
+ SET_SecondaryColorPointerEXT(disp, glSecondaryColorPointerEXT);
+ SET_AreProgramsResidentNV(disp, glAreProgramsResidentNV);
+ SET_BindProgramNV(disp, glBindProgramNV);
+ SET_DeleteProgramsNV(disp, glDeleteProgramsNV);
+ SET_ExecuteProgramNV(disp, glExecuteProgramNV);
+ SET_GenProgramsNV(disp, glGenProgramsNV);
+ SET_GetProgramParameterdvNV(disp, glGetProgramParameterdvNV);
+ SET_GetProgramParameterfvNV(disp, glGetProgramParameterfvNV);
+ SET_GetProgramivNV(disp, glGetProgramivNV);
+ SET_GetProgramStringNV(disp, glGetProgramStringNV);
+ SET_GetTrackMatrixivNV(disp, glGetTrackMatrixivNV);
+ SET_GetVertexAttribdvARB(disp, glGetVertexAttribdvARB);
+ SET_GetVertexAttribfvARB(disp, glGetVertexAttribfvARB);
+ SET_GetVertexAttribivARB(disp, glGetVertexAttribivARB);
+ SET_GetVertexAttribPointervNV(disp, glGetVertexAttribPointervNV);
+ SET_IsProgramNV(disp, glIsProgramNV);
+ SET_LoadProgramNV(disp, glLoadProgramNV);
+ SET_ProgramParameter4dNV(disp, glProgramParameter4dNV);
+ SET_ProgramParameter4dvNV(disp, glProgramParameter4dvNV);
+ SET_ProgramParameter4fNV(disp, glProgramParameter4fNV);
+ SET_ProgramParameter4fvNV(disp, glProgramParameter4fvNV);
+ SET_ProgramParameters4dvNV(disp, glProgramParameters4dvNV);
+ SET_ProgramParameters4fvNV(disp, glProgramParameters4fvNV);
+ SET_RequestResidentProgramsNV(disp, glRequestResidentProgramsNV);
+ SET_TrackMatrixNV(disp, glTrackMatrixNV);
+ SET_VertexAttribPointerNV(disp, glVertexAttribPointerNV);
+ SET_VertexAttrib1dARB(disp, glVertexAttrib1dARB);
+ SET_VertexAttrib1dvARB(disp, glVertexAttrib1dvARB);
+ SET_VertexAttrib1fARB(disp, glVertexAttrib1fARB);
+ SET_VertexAttrib1fvARB(disp, glVertexAttrib1fvARB);
+ SET_VertexAttrib1sARB(disp, glVertexAttrib1sARB);
+ SET_VertexAttrib1svARB(disp, glVertexAttrib1svARB);
+ SET_VertexAttrib2dARB(disp, glVertexAttrib2dARB);
+ SET_VertexAttrib2dvARB(disp, glVertexAttrib2dvARB);
+ SET_VertexAttrib2fARB(disp, glVertexAttrib2fARB);
+ SET_VertexAttrib2fvARB(disp, glVertexAttrib2fvARB);
+ SET_VertexAttrib2sARB(disp, glVertexAttrib2sARB);
+ SET_VertexAttrib2svARB(disp, glVertexAttrib2svARB);
+ SET_VertexAttrib3dARB(disp, glVertexAttrib3dARB);
+ SET_VertexAttrib3dvARB(disp, glVertexAttrib3dvARB);
+ SET_VertexAttrib3fARB(disp, glVertexAttrib3fARB);
+ SET_VertexAttrib3fvARB(disp, glVertexAttrib3fvARB);
+ SET_VertexAttrib3sARB(disp, glVertexAttrib3sARB);
+ SET_VertexAttrib3svARB(disp, glVertexAttrib3svARB);
+ SET_VertexAttrib4dARB(disp, glVertexAttrib4dARB);
+ SET_VertexAttrib4dvARB(disp, glVertexAttrib4dvARB);
+ SET_VertexAttrib4fARB(disp, glVertexAttrib4fARB);
+ SET_VertexAttrib4fvARB(disp, glVertexAttrib4fvARB);
+ SET_VertexAttrib4sARB(disp, glVertexAttrib4sARB);
+ SET_VertexAttrib4svARB(disp, glVertexAttrib4svARB);
+ SET_VertexAttrib4NubARB(disp, glVertexAttrib4NubARB);
+ SET_VertexAttrib4NubvARB(disp, glVertexAttrib4NubvARB);
+ SET_VertexAttribs1dvNV(disp, glVertexAttribs1dvNV);
+ SET_VertexAttribs1fvNV(disp, glVertexAttribs1fvNV);
+ SET_VertexAttribs1svNV(disp, glVertexAttribs1svNV);
+ SET_VertexAttribs2dvNV(disp, glVertexAttribs2dvNV);
+ SET_VertexAttribs2fvNV(disp, glVertexAttribs2fvNV);
+ SET_VertexAttribs2svNV(disp, glVertexAttribs2svNV);
+ SET_VertexAttribs3dvNV(disp, glVertexAttribs3dvNV);
+ SET_VertexAttribs3fvNV(disp, glVertexAttribs3fvNV);
+ SET_VertexAttribs3svNV(disp, glVertexAttribs3svNV);
+ SET_VertexAttribs4dvNV(disp, glVertexAttribs4dvNV);
+ SET_VertexAttribs4fvNV(disp, glVertexAttribs4fvNV);
+ SET_VertexAttribs4svNV(disp, glVertexAttribs4svNV);
+ SET_VertexAttribs4ubvNV(disp, glVertexAttribs4ubvNV);
+ SET_PointParameteriNV(disp, glPointParameteriNV);
+ SET_PointParameterivNV(disp, glPointParameterivNV);
+ SET_MultiDrawArraysEXT(disp, glMultiDrawArraysEXT);
+ SET_MultiDrawElementsEXT(disp, glMultiDrawElementsEXT);
+ SET_ActiveStencilFaceEXT(disp, glActiveStencilFaceEXT);
+ SET_DeleteFencesNV(disp, glDeleteFencesNV);
+ SET_GenFencesNV(disp, glGenFencesNV);
+ SET_IsFenceNV(disp, glIsFenceNV);
+ SET_TestFenceNV(disp, glTestFenceNV);
+ SET_GetFenceivNV(disp, glGetFenceivNV);
+ SET_FinishFenceNV(disp, glFinishFenceNV);
+ SET_SetFenceNV(disp, glSetFenceNV);
+ SET_VertexAttrib4bvARB(disp, glVertexAttrib4bvARB);
+ SET_VertexAttrib4ivARB(disp, glVertexAttrib4ivARB);
+ SET_VertexAttrib4ubvARB(disp, glVertexAttrib4ubvARB);
+ SET_VertexAttrib4usvARB(disp, glVertexAttrib4usvARB);
+ SET_VertexAttrib4uivARB(disp, glVertexAttrib4uivARB);
+ SET_VertexAttrib4NbvARB(disp, glVertexAttrib4NbvARB);
+ SET_VertexAttrib4NsvARB(disp, glVertexAttrib4NsvARB);
+ SET_VertexAttrib4NivARB(disp, glVertexAttrib4NivARB);
+ SET_VertexAttrib4NusvARB(disp, glVertexAttrib4NusvARB);
+ SET_VertexAttrib4NuivARB(disp, glVertexAttrib4NuivARB);
+ SET_VertexAttribPointerARB(disp, glVertexAttribPointerARB);
+ SET_EnableVertexAttribArrayARB(disp, glEnableVertexAttribArrayARB);
+ SET_DisableVertexAttribArrayARB(disp, glDisableVertexAttribArrayARB);
+ SET_ProgramStringARB(disp, glProgramStringARB);
+ SET_ProgramEnvParameter4dARB(disp, glProgramEnvParameter4dARB);
+ SET_ProgramEnvParameter4dvARB(disp, glProgramEnvParameter4dvARB);
+ SET_ProgramEnvParameter4fARB(disp, glProgramEnvParameter4fARB);
+ SET_ProgramEnvParameter4fvARB(disp, glProgramEnvParameter4fvARB);
+ SET_ProgramLocalParameter4dARB(disp, glProgramLocalParameter4dARB);
+ SET_ProgramLocalParameter4dvARB(disp, glProgramLocalParameter4dvARB);
+ SET_ProgramLocalParameter4fARB(disp, glProgramLocalParameter4fARB);
+ SET_ProgramLocalParameter4fvARB(disp, glProgramLocalParameter4fvARB);
+ SET_GetProgramEnvParameterdvARB(disp, glGetProgramEnvParameterdvARB);
+ SET_GetProgramEnvParameterfvARB(disp, glGetProgramEnvParameterfvARB);
+ SET_GetProgramLocalParameterdvARB(disp, glGetProgramLocalParameterdvARB);
+ SET_GetProgramLocalParameterfvARB(disp, glGetProgramLocalParameterfvARB);
+ SET_GetProgramivARB(disp, glGetProgramivARB);
+ SET_GetProgramStringARB(disp, glGetProgramStringARB);
+ SET_ProgramNamedParameter4fNV(disp, glProgramNamedParameter4fNV);
+ SET_ProgramNamedParameter4dNV(disp, glProgramNamedParameter4dNV);
+ SET_ProgramNamedParameter4fvNV(disp, glProgramNamedParameter4fvNV);
+ SET_ProgramNamedParameter4dvNV(disp, glProgramNamedParameter4dvNV);
+ SET_GetProgramNamedParameterfvNV(disp, glGetProgramNamedParameterfvNV);
+ SET_GetProgramNamedParameterdvNV(disp, glGetProgramNamedParameterdvNV);
+ SET_BindBufferARB(disp, glBindBufferARB);
+ SET_BufferDataARB(disp, glBufferDataARB);
+ SET_BufferSubDataARB(disp, glBufferSubDataARB);
+ SET_DeleteBuffersARB(disp, glDeleteBuffersARB);
+ SET_GenBuffersARB(disp, glGenBuffersARB);
+ SET_GetBufferParameterivARB(disp, glGetBufferParameterivARB);
+ SET_GetBufferPointervARB(disp, glGetBufferPointervARB);
+ SET_GetBufferSubDataARB(disp, glGetBufferSubDataARB);
+ SET_IsBufferARB(disp, glIsBufferARB);
+ SET_MapBufferARB(disp, glMapBufferARB);
+ SET_UnmapBufferARB(disp, glUnmapBufferARB);
+ SET_DepthBoundsEXT(disp, glDepthBoundsEXT);
+ SET_GenQueriesARB(disp, glGenQueriesARB);
+ SET_DeleteQueriesARB(disp, glDeleteQueriesARB);
+ SET_IsQueryARB(disp, glIsQueryARB);
+ SET_BeginQueryARB(disp, glBeginQueryARB);
+ SET_EndQueryARB(disp, glEndQueryARB);
+ SET_GetQueryivARB(disp, glGetQueryivARB);
+ SET_GetQueryObjectivARB(disp, glGetQueryObjectivARB);
+ SET_GetQueryObjectuivARB(disp, glGetQueryObjectuivARB);
+ SET_MultiModeDrawArraysIBM(disp, glMultiModeDrawArraysIBM);
+ SET_MultiModeDrawElementsIBM(disp, glMultiModeDrawElementsIBM);
+ SET_BlendEquationSeparateEXT(disp, glBlendEquationSeparateEXT);
+ SET_DeleteObjectARB(disp, glDeleteObjectARB);
+ SET_GetHandleARB(disp, glGetHandleARB);
+ SET_DetachObjectARB(disp, glDetachObjectARB);
+ SET_CreateShaderObjectARB(disp, glCreateShaderObjectARB);
+ SET_ShaderSourceARB(disp, glShaderSourceARB);
+ SET_CompileShaderARB(disp, glCompileShaderARB);
+ SET_CreateProgramObjectARB(disp, glCreateProgramObjectARB);
+ SET_AttachObjectARB(disp, glAttachObjectARB);
+ SET_LinkProgramARB(disp, glLinkProgramARB);
+ SET_UseProgramObjectARB(disp, glUseProgramObjectARB);
+ SET_ValidateProgramARB(disp, glValidateProgramARB);
+ SET_Uniform1fARB(disp, glUniform1fARB);
+ SET_Uniform2fARB(disp, glUniform2fARB);
+ SET_Uniform3fARB(disp, glUniform3fARB);
+ SET_Uniform4fARB(disp, glUniform4fARB);
+ SET_Uniform1iARB(disp, glUniform1iARB);
+ SET_Uniform2iARB(disp, glUniform2iARB);
+ SET_Uniform3iARB(disp, glUniform3iARB);
+ SET_Uniform4iARB(disp, glUniform4iARB);
+ SET_Uniform1fvARB(disp, glUniform1fvARB);
+ SET_Uniform2fvARB(disp, glUniform2fvARB);
+ SET_Uniform3fvARB(disp, glUniform3fvARB);
+ SET_Uniform4fvARB(disp, glUniform4fvARB);
+ SET_Uniform1ivARB(disp, glUniform1ivARB);
+ SET_Uniform2ivARB(disp, glUniform2ivARB);
+ SET_Uniform3ivARB(disp, glUniform3ivARB);
+ SET_Uniform4ivARB(disp, glUniform4ivARB);
+ SET_UniformMatrix2fvARB(disp, glUniformMatrix2fvARB);
+ SET_UniformMatrix3fvARB(disp, glUniformMatrix3fvARB);
+ SET_UniformMatrix4fvARB(disp, glUniformMatrix4fvARB);
+ SET_GetObjectParameterfvARB(disp, glGetObjectParameterfvARB);
+ SET_GetObjectParameterivARB(disp, glGetObjectParameterivARB);
+ SET_GetInfoLogARB(disp, glGetInfoLogARB);
+ SET_GetAttachedObjectsARB(disp, glGetAttachedObjectsARB);
+ SET_GetUniformLocationARB(disp, glGetUniformLocationARB);
+ SET_GetActiveUniformARB(disp, glGetActiveUniformARB);
+ SET_GetUniformfvARB(disp, glGetUniformfvARB);
+ SET_GetUniformivARB(disp, glGetUniformivARB);
+ SET_GetShaderSourceARB(disp, glGetShaderSourceARB);
+ SET_BindAttribLocationARB(disp, glBindAttribLocationARB);
+ SET_GetActiveAttribARB(disp, glGetActiveAttribARB);
+ SET_GetAttribLocationARB(disp, glGetAttribLocationARB);
+ SET_GetVertexAttribdvNV(disp, glGetVertexAttribdvNV);
+ SET_GetVertexAttribfvNV(disp, glGetVertexAttribfvNV);
+ SET_GetVertexAttribivNV(disp, glGetVertexAttribivNV);
+ SET_VertexAttrib1dNV(disp, glVertexAttrib1dNV);
+ SET_VertexAttrib1dvNV(disp, glVertexAttrib1dvNV);
+ SET_VertexAttrib1fNV(disp, glVertexAttrib1fNV);
+ SET_VertexAttrib1fvNV(disp, glVertexAttrib1fvNV);
+ SET_VertexAttrib1sNV(disp, glVertexAttrib1sNV);
+ SET_VertexAttrib1svNV(disp, glVertexAttrib1svNV);
+ SET_VertexAttrib2dNV(disp, glVertexAttrib2dNV);
+ SET_VertexAttrib2dvNV(disp, glVertexAttrib2dvNV);
+ SET_VertexAttrib2fNV(disp, glVertexAttrib2fNV);
+ SET_VertexAttrib2fvNV(disp, glVertexAttrib2fvNV);
+ SET_VertexAttrib2sNV(disp, glVertexAttrib2sNV);
+ SET_VertexAttrib2svNV(disp, glVertexAttrib2svNV);
+ SET_VertexAttrib3dNV(disp, glVertexAttrib3dNV);
+ SET_VertexAttrib3dvNV(disp, glVertexAttrib3dvNV);
+ SET_VertexAttrib3fNV(disp, glVertexAttrib3fNV);
+ SET_VertexAttrib3fvNV(disp, glVertexAttrib3fvNV);
+ SET_VertexAttrib3sNV(disp, glVertexAttrib3sNV);
+ SET_VertexAttrib3svNV(disp, glVertexAttrib3svNV);
+ SET_VertexAttrib4dNV(disp, glVertexAttrib4dNV);
+ SET_VertexAttrib4dvNV(disp, glVertexAttrib4dvNV);
+ SET_VertexAttrib4fNV(disp, glVertexAttrib4fNV);
+ SET_VertexAttrib4fvNV(disp, glVertexAttrib4fvNV);
+ SET_VertexAttrib4sNV(disp, glVertexAttrib4sNV);
+ SET_VertexAttrib4svNV(disp, glVertexAttrib4svNV);
+ SET_VertexAttrib4ubNV(disp, glVertexAttrib4ubNV);
+ SET_VertexAttrib4ubvNV(disp, glVertexAttrib4ubvNV);
+ SET_GenFragmentShadersATI(disp, glGenFragmentShadersATI);
+ SET_BindFragmentShaderATI(disp, glBindFragmentShaderATI);
+ SET_DeleteFragmentShaderATI(disp, glDeleteFragmentShaderATI);
+ SET_BeginFragmentShaderATI(disp, glBeginFragmentShaderATI);
+ SET_EndFragmentShaderATI(disp, glEndFragmentShaderATI);
+ SET_PassTexCoordATI(disp, glPassTexCoordATI);
+ SET_SampleMapATI(disp, glSampleMapATI);
+ SET_ColorFragmentOp1ATI(disp, glColorFragmentOp1ATI);
+ SET_ColorFragmentOp2ATI(disp, glColorFragmentOp2ATI);
+ SET_ColorFragmentOp3ATI(disp, glColorFragmentOp3ATI);
+ SET_AlphaFragmentOp1ATI(disp, glAlphaFragmentOp1ATI);
+ SET_AlphaFragmentOp2ATI(disp, glAlphaFragmentOp2ATI);
+ SET_AlphaFragmentOp3ATI(disp, glAlphaFragmentOp3ATI);
+ SET_SetFragmentShaderConstantATI(disp, glSetFragmentShaderConstantATI);
+ SET_IsRenderbufferEXT(disp, glIsRenderbufferEXT);
+ SET_BindRenderbufferEXT(disp, glBindRenderbufferEXT);
+ SET_DeleteRenderbuffersEXT(disp, glDeleteRenderbuffersEXT);
+ SET_GenRenderbuffersEXT(disp, glGenRenderbuffersEXT);
+ SET_RenderbufferStorageEXT(disp, glRenderbufferStorageEXT);
+ SET_GetRenderbufferParameterivEXT(disp, glGetRenderbufferParameterivEXT);
+ SET_IsFramebufferEXT(disp, glIsFramebufferEXT);
+ SET_BindFramebufferEXT(disp, glBindFramebufferEXT);
+ SET_DeleteFramebuffersEXT(disp, glDeleteFramebuffersEXT);
+ SET_GenFramebuffersEXT(disp, glGenFramebuffersEXT);
+ SET_CheckFramebufferStatusEXT(disp, glCheckFramebufferStatusEXT);
+ SET_FramebufferTexture1DEXT(disp, glFramebufferTexture1DEXT);
+ SET_FramebufferTexture2DEXT(disp, glFramebufferTexture2DEXT);
+ SET_FramebufferTexture3DEXT(disp, glFramebufferTexture3DEXT);
+ SET_FramebufferRenderbufferEXT(disp, glFramebufferRenderbufferEXT);
+ SET_GetFramebufferAttachmentParameterivEXT(disp, glGetFramebufferAttachmentParameterivEXT);
+ SET_GenerateMipmapEXT(disp, glGenerateMipmapEXT);
+ SET_StencilFuncSeparate(disp, glStencilFuncSeparate);
+ SET_StencilOpSeparate(disp, glStencilOpSeparate);
+ SET_StencilMaskSeparate(disp, glStencilMaskSeparate);
+ SET_GetQueryObjecti64vEXT(disp, glGetQueryObjecti64vEXT);
+ SET_GetQueryObjectui64vEXT(disp, glGetQueryObjectui64vEXT);
+ SET_BlitFramebufferEXT(disp, glBlitFramebufferEXT); */
+
+}
diff --git a/GL/glx/Makefile.am b/GL/glx/Makefile.am
index 8184f60..7c1730e 100644
--- a/GL/glx/Makefile.am
+++ b/GL/glx/Makefile.am
@@ -14,7 +14,6 @@ AM_CFLAGS = \
 	-I@MESA_SOURCE@/src/mesa/glapi \
 	-I@MESA_SOURCE@/src/mesa/main \
 	-DXFree86Server \
-	-DNO_LIBCWRAPPER \
 	@GLX_DEFINES@
 
 # none yet
@@ -41,18 +40,20 @@ libglxdri_la_SOURCES = \
 
 libglx_la_SOURCES = \
         g_disptab.h \
+        glxbyteorder.h \
         glxcmds.c \
         glxcmdsswap.c \
         glxcontext.h \
         glxdrawable.h \
         glxext.c \
         glxext.h \
-	glxvisuals.c \
+        glxglcore.c \
         glxscreens.c \
         glxscreens.h \
         glxserver.h \
         glxutil.c \
         glxutil.h \
+        glxvisuals.c \
         indirect_dispatch.c \
         indirect_dispatch.h \
         indirect_dispatch_swap.c \
diff --git a/GL/glx/glxbyteorder.h b/GL/glx/glxbyteorder.h
new file mode 100644
index 0000000..cdf6b15
--- /dev/null
+++ b/GL/glx/glxbyteorder.h
@@ -0,0 +1,61 @@
+/*
+ * (C) Copyright IBM Corporation 2006, 2007
+ * All Rights Reserved.
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice (including the next
+ * paragraph) shall be included in all copies or substantial portions of the
+ * Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDERS, THE AUTHORS, AND/OR THEIR SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
+ * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/**
+ * \file glxbyteorder.h
+ * Platform glue for handling byte-ordering issues in GLX protocol.
+ * 
+ * \author Ian Romanick <idr@us.ibm.com>
+ */
+#if !defined(__GLXBYTEORDER_H__)
+#define __GLXBYTEORDER_H__
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#if HAVE_BYTESWAP_H
+#include <byteswap.h>
+#elif defined(USE_SYS_ENDIAN_H)
+#include <sys/endian.h>
+#elif defined(__APPLE__)
+#include <libkern/OSByteOrder.h>
+#define bswap_16 OSSwapInt16
+#define bswap_32 OSSwapInt32
+#define bswap_64 OSSwapInt64
+#else
+#define	bswap_16(value)  \
+ 	((((value) & 0xff) << 8) | ((value) >> 8))
+
+#define	bswap_32(value)	\
+ 	(((uint32_t)bswap_16((uint16_t)((value) & 0xffff)) << 16) | \
+ 	(uint32_t)bswap_16((uint16_t)((value) >> 16)))
+ 
+#define	bswap_64(value)	\
+ 	(((uint64_t)bswap_32((uint32_t)((value) & 0xffffffff)) \
+ 	    << 32) | \
+ 	(uint64_t)bswap_32((uint32_t)((value) >> 32)))
+#endif
+
+#endif /* !defined(__GLXBYTEORDER_H__) */
diff --git a/GL/glx/glxcmds.c b/GL/glx/glxcmds.c
index 1585b36..900a347 100644
--- a/GL/glx/glxcmds.c
+++ b/GL/glx/glxcmds.c
@@ -59,19 +59,6 @@
 #include "indirect_table.h"
 #include "indirect_util.h"
 
-_X_HIDDEN int
-glxCountBits(int word)
-{
-    int ret = 0;
-
-    while (word) {
-        ret += (word & 1);
-        word >>= 1;
-    }
-
-    return ret;
-}
-
 /************************************************************************/
 
 void
@@ -1031,6 +1019,7 @@ __glXCreateARGBConfig(__GLXscreen *screen)
     VisualPtr visual;
     int i;
 
+    /* search for a 32-bit visual */
     visual = NULL;
     for (i = 0; i < screen->pScreen->numVisuals; i++) 
 	if (screen->pScreen->visuals[i].nplanes == 32) {
@@ -1049,8 +1038,22 @@ __glXCreateARGBConfig(__GLXscreen *screen)
     if (modes == NULL)
 	return;
 
-    modes->next = screen->modes;
-    screen->modes = modes;
+    /* Insert this new mode at the TAIL of the linked list.
+     * Previously, the mode was incorrectly inserted at the head of the
+     * list, causing find_mesa_visual() to be off by one.  This would
+     * GLX clients to blow up if they attempted to use the last mode
+     * in the list!
+     */
+    {
+        __GLcontextModes *prev = NULL, *m;
+        for (m = screen->modes; m; m = m->next)
+            prev = m;
+        if (prev)
+            prev->next = modes;
+        else
+            screen->modes = modes;
+    }
+
     screen->numUsableVisuals++;
     screen->numVisuals++;
 
@@ -1116,6 +1119,9 @@ int DoGetFBConfigs(__GLXclientState *cl, unsigned screen, GLboolean do_swap)
     }
     pGlxScreen = __glXActiveScreens[screen];
 
+    /* Create the "extra" 32bpp ARGB visual, if not already added.
+     * XXX This is questionable place to do so!  Re-examine this someday.
+     */
     __glXCreateARGBConfig(pGlxScreen);
 
     reply.numFBConfigs = pGlxScreen->numUsableVisuals;
@@ -1254,13 +1260,15 @@ static int ValidateCreateDrawable(ClientPtr client,
 ** Create a GLX Pixmap from an X Pixmap.
 */
 int DoCreateGLXPixmap(__GLXclientState *cl, XID fbconfigId,
-		      GLuint screenNum, XID pixmapId, XID glxPixmapId)
+		      GLuint screenNum, XID pixmapId, XID glxPixmapId,
+		      CARD32 *attribs, CARD32 numAttribs)
 {
     ClientPtr client = cl->client;
     DrawablePtr pDraw;
     __GLXpixmap *pGlxPixmap;
     __GLcontextModes *modes;
-    int retval;
+    GLenum target = 0;
+    int retval, i;
 
     retval = ValidateCreateDrawable (client, screenNum, fbconfigId,
 				     pixmapId, glxPixmapId,
@@ -1279,11 +1287,37 @@ int DoCreateGLXPixmap(__GLXclientState *cl, XID fbconfigId,
     pGlxPixmap->pGlxScreen = __glXgetActiveScreen(screenNum);
     pGlxPixmap->pScreen = pDraw->pScreen;
     pGlxPixmap->idExists = True;
+#ifdef XF86DRI
     pGlxPixmap->pDamage = NULL;
+#endif
     pGlxPixmap->refcnt = 0;
 
     pGlxPixmap->modes = modes;
 
+    for (i = 0; i < numAttribs; i++) {
+	if (attribs[2 * i] == GLX_TEXTURE_TARGET_EXT) {
+	    switch (attribs[2 * i + 1]) {
+	    case GLX_TEXTURE_2D_EXT:
+		target = GL_TEXTURE_2D;
+		break;
+	    case GLX_TEXTURE_RECTANGLE_EXT:
+		target = GL_TEXTURE_RECTANGLE_ARB;
+		break;
+	    }
+	}
+    }
+
+    if (!target) {
+	int w = pDraw->width, h = pDraw->height;
+
+	if (h & (h - 1) || w & (w - 1))
+	    target = GL_TEXTURE_RECTANGLE_ARB;
+	else
+	    target = GL_TEXTURE_2D;
+    }
+
+    pGlxPixmap->target = target;
+
     /*
     ** Bump the ref count on the X pixmap so it won't disappear.
     */
@@ -1296,14 +1330,16 @@ int __glXDisp_CreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)
 {
     xGLXCreateGLXPixmapReq *req = (xGLXCreateGLXPixmapReq *) pc;
     return DoCreateGLXPixmap( cl, req->visual, req->screen,
-			      req->pixmap, req->glxpixmap );
+			      req->pixmap, req->glxpixmap, NULL, 0 );
 }
 
 int __glXDisp_CreatePixmap(__GLXclientState *cl, GLbyte *pc)
 {
     xGLXCreatePixmapReq *req = (xGLXCreatePixmapReq *) pc;
     return DoCreateGLXPixmap( cl, req->fbconfig, req->screen,
-			      req->pixmap, req->glxpixmap );
+			      req->pixmap, req->glxpixmap,
+			      (CARD32*)(req + 1),
+			      req->numAttribs );
 }
 
 int __glXDisp_CreateGLXPixmapWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)
@@ -1311,7 +1347,7 @@ int __glXDisp_CreateGLXPixmapWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)
     xGLXCreateGLXPixmapWithConfigSGIXReq *req = 
 	(xGLXCreateGLXPixmapWithConfigSGIXReq *) pc;
     return DoCreateGLXPixmap( cl, req->fbconfig, req->screen,
-			      req->pixmap, req->glxpixmap );
+			      req->pixmap, req->glxpixmap, NULL, 0 );
 }
 
 
@@ -1673,7 +1709,6 @@ DoGetDrawableAttributes(__GLXclientState *cl, XID drawId)
     xGLXGetDrawableAttributesReply reply;
     CARD32 attributes[4];
     int numAttribs;
-    PixmapPtr	pixmap;
 
     glxPixmap = (__GLXpixmap *)LookupIDByType(drawId, __glXPixmapRes);
     if (!glxPixmap) {
@@ -1688,19 +1723,11 @@ DoGetDrawableAttributes(__GLXclientState *cl, XID drawId)
     reply.numAttribs = numAttribs;
 
     attributes[0] = GLX_TEXTURE_TARGET_EXT;
+    attributes[1] = glxPixmap->target == GL_TEXTURE_2D ? GLX_TEXTURE_2D_EXT :
+	GLX_TEXTURE_RECTANGLE_EXT;
     attributes[2] = GLX_Y_INVERTED_EXT;
     attributes[3] = GL_FALSE;
 
-    /* XXX this is merely less wrong, see fdo bug #8991 */
-    pixmap = (PixmapPtr) glxPixmap->pDraw;
-    if (!(glxCountBits(pixmap->drawable.width) == 1 &&
-	  glxCountBits(pixmap->drawable.height) == 1)
-	/* || strstr(CALL_GetString(GL_EXTENSIONS,
-	             "GL_ARB_texture_non_power_of_two")) */)
-	attributes[1] = GLX_TEXTURE_RECTANGLE_EXT;
-    else
-	attributes[1] = GLX_TEXTURE_2D_EXT;
-
     if (client->swapped) {
 	__glXSwapGetDrawableAttributesReply(client, &reply, attributes);
     } else {
diff --git a/GL/glx/glxcmdsswap.c b/GL/glx/glxcmdsswap.c
index d59dfdb..12bc030 100644
--- a/GL/glx/glxcmdsswap.c
+++ b/GL/glx/glxcmdsswap.c
@@ -266,7 +266,7 @@ int __glXDispSwap_CreateGLXPixmap(__GLXclientState *cl, GLbyte *pc)
     __GLX_SWAP_INT(&req->glxpixmap);
 
     return DoCreateGLXPixmap( cl, req->visual, req->screen,
-			      req->pixmap, req->glxpixmap );
+			      req->pixmap, req->glxpixmap, NULL, 0 );
 }
 
 int __glXDispSwap_CreatePixmap(__GLXclientState *cl, GLbyte *pc)
@@ -279,9 +279,12 @@ int __glXDispSwap_CreatePixmap(__GLXclientState *cl, GLbyte *pc)
     __GLX_SWAP_INT(&req->fbconfig);
     __GLX_SWAP_INT(&req->pixmap);
     __GLX_SWAP_INT(&req->glxpixmap);
+    __GLX_SWAP_INT(&req->numAttribs);
 
     return DoCreateGLXPixmap( cl, req->fbconfig, req->screen,
-			      req->pixmap, req->glxpixmap );
+			      req->pixmap, req->glxpixmap,
+			      (CARD32*)(req + 1),
+			      req->numAttribs );
 }
 
 int __glXDispSwap_CreateGLXPixmapWithConfigSGIX(__GLXclientState *cl, GLbyte *pc)
@@ -297,7 +300,7 @@ int __glXDispSwap_CreateGLXPixmapWithConfigSGIX(__GLXclientState *cl, GLbyte *pc
     __GLX_SWAP_INT(&req->glxpixmap);
 
     return DoCreateGLXPixmap( cl, req->fbconfig, req->screen,
-			      req->pixmap, req->glxpixmap );
+			      req->pixmap, req->glxpixmap, NULL, 0 );
 }
 
 int __glXDispSwap_DestroyGLXPixmap(__GLXclientState *cl, GLbyte *pc)
@@ -496,11 +499,11 @@ int __glXDispSwap_CopySubBufferMESA(__GLXclientState *cl, GLbyte *pc)
     GLXDrawable		 *drawId;
     int			 *buffer;
 
+    __GLX_DECLARE_SWAP_VARIABLES;
+
     (void) drawId;
     (void) buffer;
 
-    __GLX_DECLARE_SWAP_VARIABLES;
-
     pc += __GLX_VENDPRIV_HDR_SIZE;
 
     __GLX_SWAP_SHORT(&req->length);
diff --git a/GL/glx/glxcontext.h b/GL/glx/glxcontext.h
index a54e323..eb10ee2 100644
--- a/GL/glx/glxcontext.h
+++ b/GL/glx/glxcontext.h
@@ -40,9 +40,6 @@
 **
 */
 
-/* XXX: should be defined somewhere globally */
-#define CAPI
-
 #include "GL/internal/glcore.h"
 
 typedef struct __GLXtextureFromPixmap __GLXtextureFromPixmap;
diff --git a/GL/glx/glxdrawable.h b/GL/glx/glxdrawable.h
index 20e9b43..b7ecad9 100644
--- a/GL/glx/glxdrawable.h
+++ b/GL/glx/glxdrawable.h
@@ -42,6 +42,10 @@
 
 #include <damage.h>
 
+#ifdef XF86DRI
+#include <GL/internal/dri_interface.h>
+#endif
+
 typedef struct {
 
     DrawablePtr pDraw;
@@ -50,7 +54,13 @@ typedef struct {
     ScreenPtr pScreen;
     Bool idExists;
     int refcnt;
+    GLenum target;
+#ifdef XF86DRI
     DamagePtr pDamage;
+    __DRIcontext *pDRICtx;
+    GLint texname;
+    unsigned long offset;
+#endif
 } __GLXpixmap;
 
 struct __GLXdrawable {
diff --git a/GL/glx/glxdri.c b/GL/glx/glxdri.c
index 788b87d..685683d 100644
--- a/GL/glx/glxdri.c
+++ b/GL/glx/glxdri.c
@@ -76,6 +76,11 @@ struct __GLXDRIscreen {
     xf86EnterVTProc *enterVT;
     xf86LeaveVTProc *leaveVT;
 
+    DRITexOffsetStartProcPtr texOffsetStart;
+    DRITexOffsetFinishProcPtr texOffsetFinish;
+    __GLXpixmap* texOffsetOverride[16];
+    GLuint lastTexOffsetOverride;
+
     unsigned char glx_enable_bits[__GLX_EXT_BYTES];
 };
 
@@ -125,30 +130,75 @@ struct __GLXDRIdrawable {
 static const char CREATE_NEW_SCREEN_FUNC[] =
     "__driCreateNewScreen_" STRINGIFY (INTERNAL_VERSION);
 
-/* The DRI driver entry point version wasn't bumped when the
- * copySubBuffer functionality was added to the DRI drivers, but the
- * functionality is still conditional on the value of the
- * internal_api_version passed to __driCreateNewScreen.  However, the
- * screen constructor doesn't fail for a DRI driver that's older than
- * the passed in version number, so there's no way we can know for
- * sure that we can actually use the copySubBuffer functionality.  But
- * since the earliest (and at this point only) released mesa version
- * (6.5) that uses the 20050727 entry point does have copySubBuffer,
- * we'll just settle for that.  We still have to pass in a higher to
- * the screen constructor to enable the functionality.
- */
-#define COPY_SUB_BUFFER_INTERNAL_VERSION 20060314
 
 static void
-__glXDRIleaveServer(void)
+__glXDRIleaveServer(GLboolean rendering)
 {
-  DRIBlockHandler(NULL, NULL, NULL);
+    int i;
+
+    for (i = 0; rendering && i < screenInfo.numScreens; i++) {
+	__GLXDRIscreen * const screen =
+	    (__GLXDRIscreen *) __glXgetActiveScreen(i);
+	GLuint lastOverride = screen->lastTexOffsetOverride;
+
+	if (lastOverride) {
+	    __GLXpixmap **texOffsetOverride = screen->texOffsetOverride;
+	    int j;
+
+	    for (j = 0; j < lastOverride; j++) {
+		__GLXpixmap *pGlxPix = texOffsetOverride[j];
+
+		if (pGlxPix && pGlxPix->texname) {
+		    pGlxPix->offset =
+			screen->texOffsetStart((PixmapPtr)pGlxPix->pDraw);
+		}
+	    }
+	}
+    }
+
+    DRIBlockHandler(NULL, NULL, NULL);
+
+    for (i = 0; rendering && i < screenInfo.numScreens; i++) {
+	__GLXDRIscreen * const screen =
+	    (__GLXDRIscreen *) __glXgetActiveScreen(i);
+	GLuint lastOverride = screen->lastTexOffsetOverride;
+
+	if (lastOverride) {
+	    __GLXpixmap **texOffsetOverride = screen->texOffsetOverride;
+	    int j;
+
+	    for (j = 0; j < lastOverride; j++) {
+		__GLXpixmap *pGlxPix = texOffsetOverride[j];
+
+		if (pGlxPix && pGlxPix->texname) {
+		    screen->driScreen.setTexOffset(pGlxPix->pDRICtx,
+						   pGlxPix->texname,
+						   pGlxPix->offset,
+						   pGlxPix->pDraw->depth,
+						   ((PixmapPtr)pGlxPix->pDraw)->
+						   devKind);
+		}
+	    }
+	}
+    }
 }
     
 static void
-__glXDRIenterServer(void)
+__glXDRIenterServer(GLboolean rendering)
 {
-  DRIWakeupHandler(NULL, 0, NULL);
+    int i;
+
+    for (i = 0; rendering && i < screenInfo.numScreens; i++) {
+	__GLXDRIscreen * const screen =
+	    (__GLXDRIscreen *) __glXgetActiveScreen(i);
+
+	if (screen->lastTexOffsetOverride) {
+	    CALL_Flush(GET_DISPATCH(), ());
+	    break;
+	}
+    }
+
+    DRIWakeupHandler(NULL, 0, NULL);
 }
 
 /**
@@ -322,19 +372,68 @@ __glXDRIbindTexImage(__GLXcontext *baseContext,
 		     int buffer,
 		     __GLXpixmap *glxPixmap)
 {
-    RegionPtr	pRegion;
+    RegionPtr	pRegion = NULL;
     PixmapPtr	pixmap;
-    int		bpp;
-    GLenum	target, format, type;
+    int		bpp, override = 0;
+    GLenum	format, type;
+    ScreenPtr pScreen = glxPixmap->pScreen;
+    __GLXDRIscreen * const screen =
+	(__GLXDRIscreen *) __glXgetActiveScreen(pScreen->myNum);
 
     pixmap = (PixmapPtr) glxPixmap->pDraw;
+
+    if (screen->texOffsetStart && screen->driScreen.setTexOffset) {
+	__GLXpixmap **texOffsetOverride = screen->texOffsetOverride;
+	int i, firstEmpty = 16, texname;
+
+	for (i = 0; i < 16; i++) {
+	    if (texOffsetOverride[i] == glxPixmap)
+		goto alreadyin; 
+
+	    if (firstEmpty == 16 && !texOffsetOverride[i])
+		firstEmpty = i;
+	}
+
+	if (firstEmpty == 16) {
+	    ErrorF("%s: Failed to register texture offset override\n", __func__);
+	    goto nooverride;
+	}
+
+	if (firstEmpty >= screen->lastTexOffsetOverride)
+	    screen->lastTexOffsetOverride = firstEmpty + 1;
+
+	texOffsetOverride[firstEmpty] = glxPixmap;
+
+alreadyin:
+	override = 1;
+
+	glxPixmap->pDRICtx = &((__GLXDRIcontext*)baseContext)->driContext;
+
+	CALL_GetIntegerv(GET_DISPATCH(), (glxPixmap->target == GL_TEXTURE_2D ?
+					  GL_TEXTURE_BINDING_2D :
+					  GL_TEXTURE_BINDING_RECTANGLE_NV,
+					  &texname));
+
+	if (texname == glxPixmap->texname)
+	    return Success;
+
+	glxPixmap->texname = texname;
+
+	screen->driScreen.setTexOffset(glxPixmap->pDRICtx, texname, 0,
+				       pixmap->drawable.depth, pixmap->devKind);
+    }
+nooverride:
+
     if (!glxPixmap->pDamage) {
-        glxPixmap->pDamage = DamageCreate(NULL, NULL, DamageReportNone,
-					  TRUE, glxPixmap->pScreen, NULL);
-	if (!glxPixmap->pDamage)
-            return BadAlloc;
+	if (!override) {
+	    glxPixmap->pDamage = DamageCreate(NULL, NULL, DamageReportNone,
+					      TRUE, pScreen, NULL);
+	    if (!glxPixmap->pDamage)
+		return BadAlloc;
+
+	    DamageRegister ((DrawablePtr) pixmap, glxPixmap->pDamage);
+	}
 
-	DamageRegister ((DrawablePtr) pixmap, glxPixmap->pDamage);
 	pRegion = NULL;
     } else {
 	pRegion = DamageRegion(glxPixmap->pDamage);
@@ -347,30 +446,22 @@ __glXDRIbindTexImage(__GLXcontext *baseContext,
 	bpp = 4;
 	format = GL_BGRA;
 	type =
-#if X_BYTE_ORDER == X_LITTLE_ENDIAN
-	    GL_UNSIGNED_BYTE;
-#else
-	    GL_UNSIGNED_INT_8_8_8_8_REV;
+#if X_BYTE_ORDER == X_BIG_ENDIAN
+	    !override ? GL_UNSIGNED_INT_8_8_8_8_REV :
 #endif
+	    GL_UNSIGNED_BYTE;
     } else {
 	bpp = 2;
 	format = GL_RGB;
 	type = GL_UNSIGNED_SHORT_5_6_5;
     }
 
-    if (!(glxCountBits(pixmap->drawable.width) == 1 &&
-	  glxCountBits(pixmap->drawable.height) == 1)
-	/* || strstr(CALL_GetString(GL_EXTENSIONS,
-	             "GL_ARB_texture_non_power_of_two")) */)
-	target = GL_TEXTURE_RECTANGLE_ARB;
-    else
-	target = GL_TEXTURE_2D;
-
     CALL_PixelStorei( GET_DISPATCH(), (GL_UNPACK_ROW_LENGTH,
 				       pixmap->devKind / bpp) );
+
     if (pRegion == NULL)
     {
-	if (pixmap->drawable.depth == 24)
+	if (!override && pixmap->drawable.depth == 24)
 	    glxFillAlphaChannel(pixmap,
 				pixmap->drawable.x,
 				pixmap->drawable.y,
@@ -383,7 +474,7 @@ __glXDRIbindTexImage(__GLXcontext *baseContext,
 					   pixmap->drawable.y) );
 
 	CALL_TexImage2D( GET_DISPATCH(),
-			 (target,
+			 (glxPixmap->target,
 			  0,
 			  bpp == 4 ? 4 : 3,
 			  pixmap->drawable.width,
@@ -391,8 +482,8 @@ __glXDRIbindTexImage(__GLXcontext *baseContext,
 			  0,
 			  format,
 			  type,
-			  pixmap->devPrivate.ptr) );
-    } else {
+			  override ? NULL : pixmap->devPrivate.ptr) );
+    } else if (!override) {
         int i, numRects;
 	BoxPtr p;
 
@@ -413,7 +504,7 @@ __glXDRIbindTexImage(__GLXcontext *baseContext,
 					       pixmap->drawable.y + p[i].y1) );
 
 	    CALL_TexSubImage2D( GET_DISPATCH(),
-				(target,
+				(glxPixmap->target,
 				 0,
 				 p[i].x1, p[i].y1,
 				 p[i].x2 - p[i].x1, p[i].y2 - p[i].y1,
@@ -423,7 +514,8 @@ __glXDRIbindTexImage(__GLXcontext *baseContext,
 	}
     }
 
-    DamageEmpty(glxPixmap->pDamage);
+    if (!override)
+	DamageEmpty(glxPixmap->pDamage);
 
     return Success;
 }
@@ -433,6 +525,40 @@ __glXDRIreleaseTexImage(__GLXcontext *baseContext,
 			int buffer,
 			__GLXpixmap *pixmap)
 {
+    ScreenPtr pScreen = pixmap->pScreen;
+    __GLXDRIscreen * const screen =
+	(__GLXDRIscreen *) __glXgetActiveScreen(pScreen->myNum);
+    GLuint lastOverride = screen->lastTexOffsetOverride;
+
+    if (lastOverride) {
+	__GLXpixmap **texOffsetOverride = screen->texOffsetOverride;
+	int i;
+
+	for (i = 0; i < lastOverride; i++) {
+	    if (texOffsetOverride[i] == pixmap) {
+		if (screen->texOffsetFinish)
+		    screen->texOffsetFinish((PixmapPtr)pixmap->pDraw);
+
+		texOffsetOverride[i] = NULL;
+
+		if (i + 1 == lastOverride) {
+		    lastOverride = 0;
+
+		    while (i--) {
+			if (texOffsetOverride[i]) {
+			    lastOverride = i + 1;
+			    break;
+			}
+		    }
+
+		    screen->lastTexOffsetOverride = lastOverride;
+
+		    break;
+		}
+	    }
+	}
+    }
+
     return Success;
 }
 
@@ -482,6 +608,7 @@ __glXDRIscreenCreateContext(__GLXscreen *baseScreen,
     context->base.loseCurrent       = __glXDRIcontextLoseCurrent;
     context->base.copy              = __glXDRIcontextCopy;
     context->base.forceCurrent      = __glXDRIcontextForceCurrent;
+    context->base.pScreen           = screen->base.pScreen;
 
     context->base.textureFromPixmap = &__glXDRItextureFromPixmap;
 
@@ -624,9 +751,16 @@ static __DRIscreen *findScreen(__DRInativeDisplay *dpy, int scrn)
 
 static GLboolean windowExists(__DRInativeDisplay *dpy, __DRIid draw)
 {
-    WindowPtr pWin = (WindowPtr) LookupIDByType(draw, RT_WINDOW);
-
-    return pWin == NULL ? GL_FALSE : GL_TRUE;
+    DrawablePtr pDrawable = (DrawablePtr) LookupIDByType(draw, RT_WINDOW);
+    int unused;
+    drm_clip_rect_t *pRects;
+
+    return pDrawable ? DRIGetDrawableInfo(pDrawable->pScreen, pDrawable,
+					  (unsigned*)&unused, (unsigned*)&unused,
+					  &unused, &unused, &unused, &unused,
+					  &unused, &pRects, &unused, &unused,
+					  &unused, &pRects)
+		     : GL_FALSE;
 }
 
 static GLboolean createContext(__DRInativeDisplay *dpy, int screen,
@@ -652,9 +786,9 @@ static GLboolean createContext(__DRInativeDisplay *dpy, int screen,
     fakeID = FakeClientID(0);
     *(XID *) contextID = fakeID;
 
-    __glXDRIenterServer();
+    __glXDRIenterServer(GL_FALSE);
     retval = DRICreateContext(pScreen, visual, fakeID, hw_context);
-    __glXDRIleaveServer();
+    __glXDRIleaveServer(GL_FALSE);
     return retval;
 }
 
@@ -663,9 +797,9 @@ static GLboolean destroyContext(__DRInativeDisplay *dpy, int screen,
 {
     GLboolean retval;
 
-    __glXDRIenterServer();
+    __glXDRIenterServer(GL_FALSE);
     retval = DRIDestroyContext(screenInfo.screens[screen], context);
-    __glXDRIleaveServer();
+    __glXDRIleaveServer(GL_FALSE);
     return retval;
 }
 
@@ -680,12 +814,10 @@ createDrawable(__DRInativeDisplay *dpy, int screen,
     if (!pDrawable)
 	return GL_FALSE;
 
-    __glXDRIenterServer();
-    retval = DRICreateDrawable(screenInfo.screens[screen],
-			    drawable,
-			    pDrawable,
-			    hHWDrawable);
-    __glXDRIleaveServer();
+    __glXDRIenterServer(GL_FALSE);
+    retval = DRICreateDrawable(screenInfo.screens[screen], __pGlxClient,
+			       pDrawable, hHWDrawable);
+    __glXDRIleaveServer(GL_FALSE);
     return retval;
 }
 
@@ -699,11 +831,10 @@ destroyDrawable(__DRInativeDisplay *dpy, int screen, __DRIid drawable)
     if (!pDrawable)
 	return GL_FALSE;
 
-    __glXDRIenterServer();
-    retval = DRIDestroyDrawable(screenInfo.screens[screen],
-			     drawable,
-			     pDrawable);
-    __glXDRIleaveServer();
+    __glXDRIenterServer(GL_FALSE);
+    retval = DRIDestroyDrawable(screenInfo.screens[screen], __pGlxClient,
+				pDrawable);
+    __glXDRIleaveServer(GL_FALSE);
     return retval;
 }
 
@@ -740,20 +871,44 @@ getDrawableInfo(__DRInativeDisplay *dpy, int screen,
 	return GL_FALSE;
     }
 
-    __glXDRIenterServer();
+    __glXDRIenterServer(GL_FALSE);
     retval = DRIGetDrawableInfo(screenInfo.screens[screen],
 				pDrawable, index, stamp,
 				x, y, width, height,
 				numClipRects, &pClipRects,
 				backX, backY,
 				numBackClipRects, &pBackClipRects);
-    __glXDRIleaveServer();
+    __glXDRIleaveServer(GL_FALSE);
 
     if (*numClipRects > 0) {
 	size = sizeof (drm_clip_rect_t) * *numClipRects;
 	*ppClipRects = xalloc (size);
-	if (*ppClipRects != NULL)
-	    memcpy (*ppClipRects, pClipRects, size);
+
+	/* Clip cliprects to screen dimensions (redirected windows) */
+	if (*ppClipRects != NULL) {
+	    ScreenPtr pScreen = screenInfo.screens[screen];
+	    int i, j;
+
+	    for (i = 0, j = 0; i < *numClipRects; i++) {
+	        (*ppClipRects)[j].x1 = max(pClipRects[i].x1, 0);
+		(*ppClipRects)[j].y1 = max(pClipRects[i].y1, 0);
+		(*ppClipRects)[j].x2 = min(pClipRects[i].x2, pScreen->width);
+		(*ppClipRects)[j].y2 = min(pClipRects[i].y2, pScreen->height);
+
+		if ((*ppClipRects)[j].x1 < (*ppClipRects)[j].x2 &&
+		    (*ppClipRects)[j].y1 < (*ppClipRects)[j].y2) {
+		    j++;
+		}
+	    }
+
+	    if (*numClipRects != j) {
+		*numClipRects = j;
+		*ppClipRects = xrealloc (*ppClipRects,
+					 sizeof (drm_clip_rect_t) *
+					 *numClipRects);
+	    }
+	} else
+	    *numClipRects = 0;
     }
     else {
       *ppClipRects = NULL;
@@ -769,7 +924,7 @@ getDrawableInfo(__DRInativeDisplay *dpy, int screen,
       *ppBackClipRects = NULL;
     }
 
-    return GL_TRUE;
+    return retval;
 }
 
 static int
@@ -815,7 +970,6 @@ static Bool
 glxDRIEnterVT (int index, int flags)
 {
     __GLXDRIscreen *screen = (__GLXDRIscreen *) __glXgetActiveScreen(index);
-    Bool ret;
 
     LogMessage(X_INFO, "AIGLX: Resuming AIGLX clients after VT switch\n");
 
@@ -852,7 +1006,7 @@ __glXDRIscreenProbe(ScreenPtr pScreen)
     __DRIframebuffer  framebuffer;
     int   fd = -1;
     int   status;
-    int api_ver = COPY_SUB_BUFFER_INTERNAL_VERSION;
+    int api_ver = 20070121;
     drm_magic_t magic;
     drmVersionPtr version;
     int newlyopened;
@@ -867,13 +1021,10 @@ __glXDRIscreenProbe(ScreenPtr pScreen)
     size_t buffer_size;
     ScrnInfoPtr pScrn = xf86Screens[pScreen->myNum];
 
-    if (!xf86LoaderCheckSymbol("DRIQueryDirectRenderingCapable")) {
-	LogMessage(X_ERROR, "AIGLX: DRI module not loaded\n");
-	return NULL;
-    }
-
-    if (!DRIQueryDirectRenderingCapable(pScreen, &isCapable) || !isCapable) {
-	LogMessage(X_ERROR,
+    if (!xf86LoaderCheckSymbol("DRIQueryDirectRenderingCapable") ||
+	!DRIQueryDirectRenderingCapable(pScreen, &isCapable) ||
+	!isCapable) {
+	LogMessage(X_INFO,
 		   "AIGLX: Screen %d is not DRI capable\n", pScreen->myNum);
 	return NULL;
     }
@@ -1034,6 +1185,9 @@ __glXDRIscreenProbe(ScreenPtr pScreen)
 	goto handle_error;
     }
 
+    DRIGetTexOffsetFuncs(pScreen, &screen->texOffsetStart,
+			 &screen->texOffsetFinish);
+
     __glXScreenInit(&screen->base, pScreen);
 
     buffer_size = __glXGetExtensionString(screen->glx_enable_bits, NULL);
diff --git a/GL/glx/glxext.c b/GL/glx/glxext.c
index 1f6c7f3..b35175e 100644
--- a/GL/glx/glxext.c
+++ b/GL/glx/glxext.c
@@ -62,6 +62,11 @@ xGLXSingleReply __glXReply;
 static __GLXclientState *__glXClients[MAXCLIENTS + 1];
 
 /*
+** Client that called into GLX dispatch.
+*/
+ClientPtr __pGlxClient;
+
+/*
 ** Forward declarations.
 */
 static int __glXDispatch(ClientPtr);
@@ -167,10 +172,12 @@ static int PixmapGone(__GLXpixmap *pGlxPixmap, XID id)
 
     pGlxPixmap->idExists = False;
     if (!pGlxPixmap->refcnt) {
+#ifdef XF86DRI
 	if (pGlxPixmap->pDamage) {
 	    DamageUnregister (pGlxPixmap->pDraw, pGlxPixmap->pDamage);
 	    DamageDestroy(pGlxPixmap->pDamage);
 	}
+#endif
 	/*
 	** The DestroyPixmap routine should decrement the refcount and free
 	** only if it's zero.
@@ -238,9 +245,9 @@ GLboolean __glXFreeContext(__GLXcontext *cx)
      * the latter case we need to lift the DRI lock manually. */
 
     if (!glxBlockClients) {
-	__glXleaveServer();
+	__glXleaveServer(GL_FALSE);
 	cx->destroy(cx);
-	__glXenterServer();
+	__glXenterServer(GL_FALSE);
     } else {
 	cx->next = glxPendingDestroyContexts;
 	glxPendingDestroyContexts = cx;
@@ -275,7 +282,7 @@ static GLboolean errorOccured = GL_FALSE;
 /*
 ** The GL was will call this routine if an error occurs.
 */
-void __glXErrorCallBack(__GLinterface *gc, GLenum code)
+void __glXErrorCallBack(GLenum code)
 {
     errorOccured = GL_TRUE;
 }
@@ -439,49 +446,49 @@ void glxResumeClients(void)
 	AttendClient(__glXClients[i]->client);
     }
 
-    __glXleaveServer();
+    __glXleaveServer(GL_FALSE);
     for (cx = glxPendingDestroyContexts; cx != NULL; cx = next) {
 	next = cx->next;
 
 	cx->destroy(cx);
     }
     glxPendingDestroyContexts = NULL;
-    __glXenterServer();
+    __glXenterServer(GL_FALSE);
 }
 
 static void
-__glXnopEnterServer(void)
+__glXnopEnterServer(GLboolean rendering)
 {
 }
     
 static void
-__glXnopLeaveServer(void)
+__glXnopLeaveServer(GLboolean rendering)
 {
 }
 
-static void (*__glXenterServerFunc)(void) = __glXnopEnterServer;
-static void (*__glXleaveServerFunc)(void)  = __glXnopLeaveServer;
+static void (*__glXenterServerFunc)(GLboolean) = __glXnopEnterServer;
+static void (*__glXleaveServerFunc)(GLboolean)  = __glXnopLeaveServer;
 
-void __glXsetEnterLeaveServerFuncs(void (*enter)(void),
-				   void (*leave)(void))
+void __glXsetEnterLeaveServerFuncs(void (*enter)(GLboolean),
+				   void (*leave)(GLboolean))
 {
   __glXenterServerFunc = enter;
   __glXleaveServerFunc = leave;
 }
 
 
-void __glXenterServer(void)
+void __glXenterServer(GLboolean rendering)
 {
   glxServerLeaveCount--;
 
   if (glxServerLeaveCount == 0)
-    (*__glXenterServerFunc)();
+    (*__glXenterServerFunc)(rendering);
 }
 
-void __glXleaveServer(void)
+void __glXleaveServer(GLboolean rendering)
 {
   if (glxServerLeaveCount == 0)
-    (*__glXleaveServerFunc)();
+    (*__glXleaveServerFunc)(rendering);
 
   glxServerLeaveCount++;
 }
@@ -546,11 +553,14 @@ static int __glXDispatch(ClientPtr client)
 								       opcode,
 								       client->swapped);
     if (proc != NULL) {
-	__glXleaveServer();
+	GLboolean rendering = opcode <= X_GLXRenderLarge;
+	__glXleaveServer(rendering);
+
+	__pGlxClient = client;
 
 	retval = (*proc)(cl, (GLbyte *) stuff);
 
-	__glXenterServer();
+	__glXenterServer(rendering);
     }
     else {
 	retval = BadRequest;
diff --git a/GL/glx/glxext.h b/GL/glx/glxext.h
index edd66a8..6774e4d 100644
--- a/GL/glx/glxext.h
+++ b/GL/glx/glxext.h
@@ -66,7 +66,7 @@ typedef struct {
 extern GLboolean __glXFreeContext(__GLXcontext *glxc);
 extern void __glXFlushContextCache(void);
 
-extern void __glXErrorCallBack(__GLinterface *gc, GLenum code);
+extern void __glXErrorCallBack(GLenum code);
 extern void __glXClearErrorOccured(void);
 extern GLboolean __glXErrorOccured(void);
 extern void __glXResetLargeCommandStatus(__GLXclientState*);
@@ -80,7 +80,8 @@ extern int DoGetFBConfigs(__GLXclientState *cl, unsigned screen,
 extern int DoCreateContext(__GLXclientState *cl, GLXContextID gcId,
     GLXContextID shareList, VisualID visual, GLuint screen, GLboolean isDirect);
 extern int DoCreateGLXPixmap(__GLXclientState *cl, XID fbconfigId,
-    GLuint screenNum, XID pixmapId, XID glxpixmapId);
+    GLuint screenNum, XID pixmapId, XID glxpixmapId, CARD32 *attribs,
+    CARD32 numAttribs);
 extern int DoDestroyPixmap(__GLXclientState *cl, XID glxpixmapId);
 
 extern int DoQueryContext(__GLXclientState *cl, GLXContextID gcId);
diff --git a/GL/glx/glxglcore.c b/GL/glx/glxglcore.c
new file mode 100644
index 0000000..df9be07
--- /dev/null
+++ b/GL/glx/glxglcore.c
@@ -0,0 +1,411 @@
+/**************************************************************************
+
+Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
+All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sub license, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice (including the
+next paragraph) shall be included in all copies or substantial portions
+of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
+ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+**************************************************************************/
+
+/*
+ * Authors:
+ *   Kevin E. Martin <kevin@precisioninsight.com>
+ *   Brian E. Paul <brian@precisioninsight.com>
+ *
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <string.h>
+
+#include <GL/xmesa.h>
+#include <GL/internal/glcore.h>
+#include <glxserver.h>
+#include <glxscreens.h>
+#include <glxdrawable.h>
+#include <glxcontext.h>
+#include <glxutil.h>
+
+#include "glcontextmodes.h"
+#include "os.h"
+
+typedef struct __GLXMESAscreen   __GLXMESAscreen;
+typedef struct __GLXMESAcontext  __GLXMESAcontext;
+typedef struct __GLXMESAdrawable __GLXMESAdrawable;
+
+struct __GLXMESAscreen {
+    __GLXscreen   base;
+    int           index;
+    int		  num_vis;
+    XMesaVisual  *xm_vis;
+};
+
+struct __GLXMESAcontext {
+    __GLXcontext base;
+    XMesaContext xmesa;
+};
+
+struct __GLXMESAdrawable {
+    __GLXdrawable base;
+    XMesaBuffer   xm_buf;
+};
+
+static XMesaVisual find_mesa_visual(__GLXscreen *screen, VisualID vid);
+
+
+static void
+__glXMesaDrawableDestroy(__GLXdrawable *base)
+{
+    __GLXMESAdrawable *glxPriv = (__GLXMESAdrawable *) base;
+
+    if (glxPriv->xm_buf != NULL)
+      XMesaDestroyBuffer(glxPriv->xm_buf);
+    xfree(glxPriv);
+}
+
+static GLboolean
+__glXMesaDrawableResize(__GLXdrawable *base)
+{
+    __GLXMESAdrawable *glxPriv = (__GLXMESAdrawable *) base;
+
+    XMesaResizeBuffers(glxPriv->xm_buf);
+
+    return GL_TRUE;
+}
+
+static GLboolean
+__glXMesaDrawableSwapBuffers(__GLXdrawable *base)
+{
+    __GLXMESAdrawable *glxPriv = (__GLXMESAdrawable *) base;
+
+    /* This is terrifying: XMesaSwapBuffers() ends up calling CopyArea
+     * to do the buffer swap, but this assumes that the server holds
+     * the lock and has its context visible.  If another screen uses a
+     * DRI driver, that will have installed the DRI enter/leave server
+     * functions, which lifts the lock during GLX dispatch.  This is
+     * why we need to re-take the lock and swap in the server context
+     * before calling XMesaSwapBuffers() here.  /me shakes head. */
+
+    __glXenterServer(GL_FALSE);
+
+    XMesaSwapBuffers(glxPriv->xm_buf);
+
+    __glXleaveServer(GL_FALSE);
+
+    return GL_TRUE;
+}
+
+
+static __GLXdrawable *
+__glXMesaScreenCreateDrawable(__GLXscreen *screen,
+			      DrawablePtr pDraw,
+			      XID drawId,
+			      __GLcontextModes *modes)
+{
+    __GLXMESAdrawable *glxPriv;
+    XMesaVisual xm_vis;
+
+    glxPriv = xalloc(sizeof *glxPriv);
+    if (glxPriv == NULL)
+	return NULL;
+
+    memset(glxPriv, 0, sizeof *glxPriv);
+
+    if (!__glXDrawableInit(&glxPriv->base, screen, pDraw, drawId, modes)) {
+        xfree(glxPriv);
+	return NULL;
+    }
+
+    glxPriv->base.destroy     = __glXMesaDrawableDestroy;
+    glxPriv->base.resize      = __glXMesaDrawableResize;
+    glxPriv->base.swapBuffers = __glXMesaDrawableSwapBuffers;
+
+    xm_vis = find_mesa_visual(screen, modes->visualID);
+    if (xm_vis == NULL) {
+	ErrorF("find_mesa_visual returned NULL for visualID = 0x%04x\n",
+	       modes->visualID);
+	xfree(glxPriv);
+	return NULL;
+    }
+
+    if (glxPriv->base.type == DRAWABLE_WINDOW) {
+	glxPriv->xm_buf = XMesaCreateWindowBuffer(xm_vis, (WindowPtr)pDraw);
+    } else {
+	glxPriv->xm_buf = XMesaCreatePixmapBuffer(xm_vis, (PixmapPtr)pDraw, 0);
+    }
+
+    return &glxPriv->base;
+}
+
+static void
+__glXMesaContextDestroy(__GLXcontext *baseContext)
+{
+    __GLXMESAcontext *context = (__GLXMESAcontext *) baseContext;
+
+    XMesaDestroyContext(context->xmesa);
+    __glXContextDestroy(&context->base);
+    xfree(context);
+}
+
+static int
+__glXMesaContextMakeCurrent(__GLXcontext *baseContext)
+
+{
+    __GLXMESAcontext *context = (__GLXMESAcontext *) baseContext;
+    __GLXMESAdrawable *drawPriv = (__GLXMESAdrawable *) context->base.drawPriv;
+    __GLXMESAdrawable *readPriv = (__GLXMESAdrawable *) context->base.readPriv;
+
+    return XMesaMakeCurrent2(context->xmesa,
+			     drawPriv->xm_buf,
+			     readPriv->xm_buf);
+}
+
+static int
+__glXMesaContextLoseCurrent(__GLXcontext *baseContext)
+{
+    __GLXMESAcontext *context = (__GLXMESAcontext *) baseContext;
+
+    return XMesaLoseCurrent(context->xmesa);
+}
+
+static int
+__glXMesaContextCopy(__GLXcontext *baseDst,
+		     __GLXcontext *baseSrc,
+		     unsigned long mask)
+{
+    __GLXMESAcontext *dst = (__GLXMESAcontext *) baseDst;
+    __GLXMESAcontext *src = (__GLXMESAcontext *) baseSrc;
+
+    return XMesaCopyContext(src->xmesa, dst->xmesa, mask);
+}
+
+static int
+__glXMesaContextForceCurrent(__GLXcontext *baseContext)
+{
+    __GLXMESAcontext *context = (__GLXMESAcontext *) baseContext;
+
+    /* GlxSetRenderTables() call for XGL moved in XMesaForceCurrent() */
+
+    return XMesaForceCurrent(context->xmesa);
+}
+
+static __GLXcontext *
+__glXMesaScreenCreateContext(__GLXscreen *screen,
+			     __GLcontextModes *modes,
+			     __GLXcontext *baseShareContext)
+{
+    __GLXMESAcontext *context;
+    __GLXMESAcontext *shareContext = (__GLXMESAcontext *) baseShareContext;
+    XMesaVisual xm_vis;
+    XMesaContext xm_share;
+
+    context = xalloc (sizeof (__GLXMESAcontext));
+    if (context == NULL)
+	return NULL;
+
+    memset(context, 0, sizeof *context);
+
+    context->base.pGlxScreen = screen;
+    context->base.modes      = modes;
+
+    context->base.destroy        = __glXMesaContextDestroy;
+    context->base.makeCurrent    = __glXMesaContextMakeCurrent;
+    context->base.loseCurrent    = __glXMesaContextLoseCurrent;
+    context->base.copy           = __glXMesaContextCopy;
+    context->base.forceCurrent   = __glXMesaContextForceCurrent;
+
+    xm_vis = find_mesa_visual(screen, modes->visualID);
+    if (!xm_vis) {
+	ErrorF("find_mesa_visual returned NULL for visualID = 0x%04x\n",
+	       modes->visualID);
+	xfree(context);
+	return NULL;
+    }
+
+    xm_share = shareContext ? shareContext->xmesa : NULL;
+    context->xmesa = XMesaCreateContext(xm_vis, xm_share);
+    if (!context->xmesa) {
+	xfree(context);
+	return NULL;
+    }
+
+    return &context->base;
+}
+
+static void
+__glXMesaScreenDestroy(__GLXscreen *screen)
+{
+    __GLXMESAscreen *mesaScreen = (__GLXMESAscreen *) screen;
+    int i;
+
+    if (mesaScreen->xm_vis) {
+	for (i = 0; i < mesaScreen->num_vis; i++) {
+	    if (mesaScreen->xm_vis[i])
+		XMesaDestroyVisual(mesaScreen->xm_vis[i]);
+	}
+
+	xfree(mesaScreen->xm_vis);
+    }
+
+    __glXScreenDestroy(screen);
+
+    xfree(screen);
+}
+
+static XMesaVisual
+find_mesa_visual(__GLXscreen *screen, VisualID vid)
+{
+    __GLXMESAscreen *mesaScreen = (__GLXMESAscreen *) screen;
+    const __GLcontextModes *modes;
+    unsigned i = 0;
+
+    for ( modes = screen->modes ; modes != NULL ; modes = modes->next ) {
+	if ( modes->visualID == vid ) {
+	    break;
+	}
+
+	i++;
+    }
+
+    return (modes != NULL) ? mesaScreen->xm_vis[i] : NULL;
+}
+
+static void init_screen_visuals(__GLXMESAscreen *screen)
+{
+    ScreenPtr pScreen = screen->base.pScreen;
+    __GLcontextModes *modes;
+    XMesaVisual *pXMesaVisual;
+    int *used;
+    int i, j, size;
+
+    /* Alloc space for the list of XMesa visuals */
+    size = screen->base.numVisuals * sizeof(XMesaVisual);
+    pXMesaVisual = (XMesaVisual *) xalloc(size);
+    memset(pXMesaVisual, 0, size);
+
+    /* FIXME: Change 'used' to be a array of bits (rather than of ints),
+     * FIXME: create a stack array of 8 or 16 bytes.  If 'numVisuals' is less
+     * FIXME: than 64 or 128 the stack array can be used instead of calling
+     * FIXME: __glXMalloc / __glXFree.  If nothing else, convert 'used' to
+     * FIXME: array of bytes instead of ints!
+     */
+    used = (int *) xalloc(pScreen->numVisuals * sizeof(int));
+    memset(used, 0, pScreen->numVisuals * sizeof(int));
+
+    i = 0;
+    for ( modes = screen->base.modes; modes != NULL; modes = modes->next ) {
+	const int vis_class = _gl_convert_to_x_visual_type( modes->visualType );
+	const int nplanes = (modes->rgbBits - modes->alphaBits);
+	const VisualPtr pVis = pScreen->visuals;
+
+	for (j = 0; j < pScreen->numVisuals; j++) {
+	    if (pVis[j].class     == vis_class &&
+		pVis[j].nplanes   == nplanes &&
+		pVis[j].redMask   == modes->redMask &&
+		pVis[j].greenMask == modes->greenMask &&
+		pVis[j].blueMask  == modes->blueMask &&
+		!used[j]) {
+
+		/* Create the XMesa visual */
+		pXMesaVisual[i] =
+		    XMesaCreateVisual(pScreen,
+				      &pVis[j],
+				      modes->rgbMode,
+				      (modes->alphaBits > 0),
+				      modes->doubleBufferMode,
+				      modes->stereoMode,
+				      GL_TRUE, /* ximage_flag */
+				      modes->depthBits,
+				      modes->stencilBits,
+				      modes->accumRedBits,
+				      modes->accumGreenBits,
+				      modes->accumBlueBits,
+				      modes->accumAlphaBits,
+				      modes->samples,
+				      modes->level,
+				      modes->visualRating);
+		/* Set the VisualID */
+		modes->visualID = pVis[j].vid;
+
+		/* Mark this visual used */
+		used[j] = 1;
+		break;
+	    }
+	}
+
+	if ( j == pScreen->numVisuals ) {
+	    ErrorF("No matching visual for __GLcontextMode with "
+		   "visual class = %d (%d), nplanes = %u\n",
+		   vis_class, 
+		   modes->visualType,
+		   (modes->rgbBits - modes->alphaBits) );
+	}
+	else if ( modes->visualID == -1 ) {
+	    FatalError( "Matching visual found, but visualID still -1!\n" );
+	}
+
+	i++;
+    }
+
+    xfree(used);
+
+    screen->num_vis = pScreen->numVisuals;
+    screen->xm_vis = pXMesaVisual;
+}
+
+static __GLXscreen *
+__glXMesaScreenProbe(ScreenPtr pScreen)
+{
+    __GLXMESAscreen *screen;
+
+    screen = xalloc(sizeof *screen);
+    if (screen == NULL)
+	return NULL;
+
+    __glXScreenInit(&screen->base, pScreen);
+
+    screen->base.destroy        = __glXMesaScreenDestroy;
+    screen->base.createContext  = __glXMesaScreenCreateContext;
+    screen->base.createDrawable = __glXMesaScreenCreateDrawable;
+    screen->base.pScreen       = pScreen;
+
+    /*
+     * Find the GLX visuals that are supported by this screen and create
+     * XMesa's visuals.
+     */
+    init_screen_visuals(screen);
+
+    return &screen->base;
+}
+
+__GLXprovider __glXMesaProvider = {
+    __glXMesaScreenProbe,
+    "MESA",
+    NULL
+};
+
+__GLXprovider *
+GlxGetMesaProvider (void)
+{
+    return &__glXMesaProvider;
+}
diff --git a/GL/glx/glxscreens.h b/GL/glx/glxscreens.h
index a7700f6..bba4557 100644
--- a/GL/glx/glxscreens.h
+++ b/GL/glx/glxscreens.h
@@ -40,9 +40,6 @@
 **
 */
 
-/* XXX: should be defined somewhere globally */
-#define CAPI
-
 #include "GL/internal/glcore.h"
 
 /*
diff --git a/GL/glx/glxserver.h b/GL/glx/glxserver.h
index 49cad73..b6b5592 100644
--- a/GL/glx/glxserver.h
+++ b/GL/glx/glxserver.h
@@ -110,6 +110,8 @@ void __glXScreenInitVisuals(__GLXscreen *screen);
 extern __GLXcontext *__glXLastContext;
 extern __GLXcontext *__glXForceCurrent(__GLXclientState*, GLXContextTag, int*);
 
+extern ClientPtr __pGlxClient;
+
 int __glXError(int error);
 
 /*
@@ -131,10 +133,10 @@ struct __GLXprovider {
 
 void GlxPushProvider(__GLXprovider *provider);
 
-void __glXsetEnterLeaveServerFuncs(void (*enter)(void),
-				   void (*leave)(void));
-void __glXenterServer(void);
-void __glXleaveServer(void);
+void __glXsetEnterLeaveServerFuncs(void (*enter)(GLboolean),
+				   void (*leave)(GLboolean));
+void __glXenterServer(GLboolean rendering);
+void __glXleaveServer(GLboolean rendering);
 
 void glxSuspendClients(void);
 void glxResumeClients(void);
diff --git a/GL/glx/glxutil.h b/GL/glx/glxutil.h
index 6cdb5c8..1937ef2 100644
--- a/GL/glx/glxutil.h
+++ b/GL/glx/glxutil.h
@@ -60,6 +60,4 @@ extern __GLXcontext *__glXLookupContextByTag(__GLXclientState*, GLXContextTag);
 extern void *__glXglDDXScreenInfo(void);
 extern void *__glXglDDXExtensionInfo(void);
 
-extern int glxCountBits(int);
-
 #endif /* _glxcmds_h_ */
diff --git a/GL/glx/indirect_dispatch.c b/GL/glx/indirect_dispatch.c
index d86dedf..00a9f96 100644
--- a/GL/glx/indirect_dispatch.c
+++ b/GL/glx/indirect_dispatch.c
@@ -33,6 +33,7 @@
 #include "indirect_size_get.h"
 #include "indirect_dispatch.h"
 #include "glxserver.h"
+#include "glxbyteorder.h"
 #include "indirect_util.h"
 #include "singlesize.h"
 #include "glapitable.h"
diff --git a/GL/glx/indirect_dispatch.h b/GL/glx/indirect_dispatch.h
index 78e5e69..24f4bed 100644
--- a/GL/glx/indirect_dispatch.h
+++ b/GL/glx/indirect_dispatch.h
@@ -379,8 +379,6 @@ extern HIDDEN void __glXDisp_DepthMask(GLbyte * pc);
 extern HIDDEN void __glXDispSwap_DepthMask(GLbyte * pc);
 extern HIDDEN void __glXDisp_Rotated(GLbyte * pc);
 extern HIDDEN void __glXDispSwap_Rotated(GLbyte * pc);
-extern HIDDEN void __glXDisp_Color4iv(GLbyte * pc);
-extern HIDDEN void __glXDispSwap_Color4iv(GLbyte * pc);
 extern HIDDEN int __glXDisp_GetMaterialiv(struct __GLXclientStateRec *, GLbyte *);
 extern HIDDEN int __glXDispSwap_GetMaterialiv(struct __GLXclientStateRec *, GLbyte *);
 extern HIDDEN void __glXDisp_StencilOp(GLbyte * pc);
@@ -621,6 +619,8 @@ extern HIDDEN int __glXDisp_PixelStorei(struct __GLXclientStateRec *, GLbyte *);
 extern HIDDEN int __glXDispSwap_PixelStorei(struct __GLXclientStateRec *, GLbyte *);
 extern HIDDEN void __glXDisp_VertexAttrib4usvARB(GLbyte * pc);
 extern HIDDEN void __glXDispSwap_VertexAttrib4usvARB(GLbyte * pc);
+extern HIDDEN void __glXDisp_Color4iv(GLbyte * pc);
+extern HIDDEN void __glXDispSwap_Color4iv(GLbyte * pc);
 extern HIDDEN void __glXDisp_EvalCoord2dv(GLbyte * pc);
 extern HIDDEN void __glXDispSwap_EvalCoord2dv(GLbyte * pc);
 extern HIDDEN void __glXDisp_VertexAttrib3svARB(GLbyte * pc);
diff --git a/GL/glx/indirect_dispatch_swap.c b/GL/glx/indirect_dispatch_swap.c
index 136f0d0..c0bb71c 100644
--- a/GL/glx/indirect_dispatch_swap.c
+++ b/GL/glx/indirect_dispatch_swap.c
@@ -28,24 +28,12 @@
 #include <X11/Xmd.h>
 #include <GL/gl.h>
 #include <GL/glxproto.h>
-#if defined(__linux__) || defined (__GLIBC__) || defined(__GNU__)
-#include <byteswap.h>
-#elif defined(__OpenBSD__)
-#include <sys/endian.h>
-#define bswap_16 __swap16
-#define bswap_32 __swap32
-#define bswap_64 __swap64
-#else
-#include <sys/endian.h>
-#define bswap_16 bswap16
-#define bswap_32 bswap32
-#define bswap_64 bswap64
-#endif
 #include <inttypes.h>
 #include "indirect_size.h"
 #include "indirect_size_get.h"
 #include "indirect_dispatch.h"
 #include "glxserver.h"
+#include "glxbyteorder.h"
 #include "indirect_util.h"
 #include "singlesize.h"
 #include "glapitable.h"
diff --git a/GL/glx/indirect_program.c b/GL/glx/indirect_program.c
index eae128a..d23a0a9 100644
--- a/GL/glx/indirect_program.c
+++ b/GL/glx/indirect_program.c
@@ -35,6 +35,7 @@
 #endif
 
 #include "glxserver.h"
+#include "glxbyteorder.h"
 #include "glxext.h"
 #include "singlesize.h"
 #include "unpack.h"
@@ -46,20 +47,6 @@
 #include "dispatch.h"
 #include "glapioffsets.h"
 
-#if defined(__linux__) || defined (__GLIBC__) || defined(__GNU__)
-#include <byteswap.h>
-#elif defined(__OpenBSD__)
-#include <sys/endian.h>
-#define bswap_16 __swap16
-#define bswap_32 __swap32
-#define bswap_64 __swap64
-#else
-#include <sys/endian.h>
-#define bswap_16 bswap16
-#define bswap_32 bswap32
-#define bswap_64 bswap64
-#endif
-
 static int DoGetProgramString(struct __GLXclientStateRec *cl, GLbyte *pc,
     unsigned get_programiv_offset, unsigned get_program_string_offset,
     Bool do_swap);
diff --git a/GL/glx/indirect_reqsize.c b/GL/glx/indirect_reqsize.c
index d3e2bc5..954eecd 100644
--- a/GL/glx/indirect_reqsize.c
+++ b/GL/glx/indirect_reqsize.c
@@ -28,16 +28,10 @@
 
 #include <GL/gl.h>
 #include "glxserver.h"
+#include "glxbyteorder.h"
 #include "indirect_size.h"
 #include "indirect_reqsize.h"
 
-#if defined(__linux__) || defined (__GLIBC__) || defined(__GNU__)
-#  include <byteswap.h>
-#  define SWAP_32(v)  do { (v) = bswap_32(v); } while(0)
-#else
-#  define SWAP_32(v)  do { char tmp; swapl(&v, tmp); } while(0)
-#endif
-
 #define __GLX_PAD(x)  (((x) + 3) & ~3)
 
 #if defined(__CYGWIN__) || defined(__MINGW32__)
@@ -56,15 +50,15 @@
 
 
 int
-__glXCallListsReqSize( const GLbyte * pc, Bool swap )
+__glXCallListsReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei n          = *(GLsizei *)(pc + 0);
-    GLenum type        = * (GLenum *)(pc + 4);
+    GLsizei n = *(GLsizei *) (pc + 0);
+    GLenum type = *(GLenum *) (pc + 4);
     GLsizei compsize;
 
     if (swap) {
-        SWAP_32( n );
-        SWAP_32( type );
+        n = bswap_32(n);
+        type = bswap_32(type);
     }
 
     compsize = __glCallLists_size(type);
@@ -72,22 +66,22 @@ __glXCallListsReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXBitmapReqSize( const GLbyte * pc, Bool swap )
+__glXBitmapReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint row_length = *(GLint *) (pc + 4);
     GLint image_height = 0;
-    GLint skip_images  = 0;
-    GLint skip_rows    = *  (GLint *)(pc +  8);
-    GLint alignment    = *  (GLint *)(pc + 16);
-    GLsizei width      = *(GLsizei *)(pc + 20);
-    GLsizei height     = *(GLsizei *)(pc + 24);
+    GLint skip_images = 0;
+    GLint skip_rows = *(GLint *) (pc + 8);
+    GLint alignment = *(GLint *) (pc + 16);
+    GLsizei width = *(GLsizei *) (pc + 20);
+    GLsizei height = *(GLsizei *) (pc + 24);
 
     if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( skip_rows );
-        SWAP_32( alignment );
-        SWAP_32( width );
-        SWAP_32( height );
+        row_length = bswap_32(row_length);
+        skip_rows = bswap_32(skip_rows);
+        alignment = bswap_32(alignment);
+        width = bswap_32(width);
+        height = bswap_32(height);
     }
 
     return __glXImageSize(GL_COLOR_INDEX, GL_BITMAP, 0, width, height, 1,
@@ -96,13 +90,13 @@ __glXBitmapReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXFogfvReqSize( const GLbyte * pc, Bool swap )
+__glXFogfvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLenum pname       = * (GLenum *)(pc + 0);
+    GLenum pname = *(GLenum *) (pc + 0);
     GLsizei compsize;
 
     if (swap) {
-        SWAP_32( pname );
+        pname = bswap_32(pname);
     }
 
     compsize = __glFogfv_size(pname);
@@ -110,13 +104,13 @@ __glXFogfvReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXLightfvReqSize( const GLbyte * pc, Bool swap )
+__glXLightfvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLenum pname       = * (GLenum *)(pc + 4);
+    GLenum pname = *(GLenum *) (pc + 4);
     GLsizei compsize;
 
     if (swap) {
-        SWAP_32( pname );
+        pname = bswap_32(pname);
     }
 
     compsize = __glLightfv_size(pname);
@@ -124,13 +118,13 @@ __glXLightfvReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXLightModelfvReqSize( const GLbyte * pc, Bool swap )
+__glXLightModelfvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLenum pname       = * (GLenum *)(pc + 0);
+    GLenum pname = *(GLenum *) (pc + 0);
     GLsizei compsize;
 
     if (swap) {
-        SWAP_32( pname );
+        pname = bswap_32(pname);
     }
 
     compsize = __glLightModelfv_size(pname);
@@ -138,13 +132,13 @@ __glXLightModelfvReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXMaterialfvReqSize( const GLbyte * pc, Bool swap )
+__glXMaterialfvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLenum pname       = * (GLenum *)(pc + 4);
+    GLenum pname = *(GLenum *) (pc + 4);
     GLsizei compsize;
 
     if (swap) {
-        SWAP_32( pname );
+        pname = bswap_32(pname);
     }
 
     compsize = __glMaterialfv_size(pname);
@@ -152,18 +146,18 @@ __glXMaterialfvReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXPolygonStippleReqSize( const GLbyte * pc, Bool swap )
+__glXPolygonStippleReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint row_length = *(GLint *) (pc + 4);
     GLint image_height = 0;
-    GLint skip_images  = 0;
-    GLint skip_rows    = *  (GLint *)(pc +  8);
-    GLint alignment    = *  (GLint *)(pc + 16);
+    GLint skip_images = 0;
+    GLint skip_rows = *(GLint *) (pc + 8);
+    GLint alignment = *(GLint *) (pc + 16);
 
     if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( skip_rows );
-        SWAP_32( alignment );
+        row_length = bswap_32(row_length);
+        skip_rows = bswap_32(skip_rows);
+        alignment = bswap_32(alignment);
     }
 
     return __glXImageSize(GL_COLOR_INDEX, GL_BITMAP, 0, 32, 32, 1,
@@ -172,13 +166,13 @@ __glXPolygonStippleReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXTexParameterfvReqSize( const GLbyte * pc, Bool swap )
+__glXTexParameterfvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLenum pname       = * (GLenum *)(pc + 4);
+    GLenum pname = *(GLenum *) (pc + 4);
     GLsizei compsize;
 
     if (swap) {
-        SWAP_32( pname );
+        pname = bswap_32(pname);
     }
 
     compsize = __glTexParameterfv_size(pname);
@@ -186,26 +180,26 @@ __glXTexParameterfvReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXTexImage1DReqSize( const GLbyte * pc, Bool swap )
+__glXTexImage1DReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint row_length = *(GLint *) (pc + 4);
     GLint image_height = 0;
-    GLint skip_images  = 0;
-    GLint skip_rows    = *  (GLint *)(pc +  8);
-    GLint alignment    = *  (GLint *)(pc + 16);
-    GLenum target      = * (GLenum *)(pc + 20);
-    GLsizei width      = *(GLsizei *)(pc + 32);
-    GLenum format      = * (GLenum *)(pc + 44);
-    GLenum type        = * (GLenum *)(pc + 48);
+    GLint skip_images = 0;
+    GLint skip_rows = *(GLint *) (pc + 8);
+    GLint alignment = *(GLint *) (pc + 16);
+    GLenum target = *(GLenum *) (pc + 20);
+    GLsizei width = *(GLsizei *) (pc + 32);
+    GLenum format = *(GLenum *) (pc + 44);
+    GLenum type = *(GLenum *) (pc + 48);
 
     if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( skip_rows );
-        SWAP_32( alignment );
-        SWAP_32( target );
-        SWAP_32( width );
-        SWAP_32( format );
-        SWAP_32( type );
+        row_length = bswap_32(row_length);
+        skip_rows = bswap_32(skip_rows);
+        alignment = bswap_32(alignment);
+        target = bswap_32(target);
+        width = bswap_32(width);
+        format = bswap_32(format);
+        type = bswap_32(type);
     }
 
     return __glXImageSize(format, type, target, width, 1, 1,
@@ -214,28 +208,28 @@ __glXTexImage1DReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXTexImage2DReqSize( const GLbyte * pc, Bool swap )
+__glXTexImage2DReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint row_length = *(GLint *) (pc + 4);
     GLint image_height = 0;
-    GLint skip_images  = 0;
-    GLint skip_rows    = *  (GLint *)(pc +  8);
-    GLint alignment    = *  (GLint *)(pc + 16);
-    GLenum target      = * (GLenum *)(pc + 20);
-    GLsizei width      = *(GLsizei *)(pc + 32);
-    GLsizei height     = *(GLsizei *)(pc + 36);
-    GLenum format      = * (GLenum *)(pc + 44);
-    GLenum type        = * (GLenum *)(pc + 48);
-
-    if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( skip_rows );
-        SWAP_32( alignment );
-        SWAP_32( target );
-        SWAP_32( width );
-        SWAP_32( height );
-        SWAP_32( format );
-        SWAP_32( type );
+    GLint skip_images = 0;
+    GLint skip_rows = *(GLint *) (pc + 8);
+    GLint alignment = *(GLint *) (pc + 16);
+    GLenum target = *(GLenum *) (pc + 20);
+    GLsizei width = *(GLsizei *) (pc + 32);
+    GLsizei height = *(GLsizei *) (pc + 36);
+    GLenum format = *(GLenum *) (pc + 44);
+    GLenum type = *(GLenum *) (pc + 48);
+
+    if (swap) {
+        row_length = bswap_32(row_length);
+        skip_rows = bswap_32(skip_rows);
+        alignment = bswap_32(alignment);
+        target = bswap_32(target);
+        width = bswap_32(width);
+        height = bswap_32(height);
+        format = bswap_32(format);
+        type = bswap_32(type);
     }
 
     return __glXImageSize(format, type, target, width, height, 1,
@@ -244,13 +238,13 @@ __glXTexImage2DReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXTexEnvfvReqSize( const GLbyte * pc, Bool swap )
+__glXTexEnvfvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLenum pname       = * (GLenum *)(pc + 4);
+    GLenum pname = *(GLenum *) (pc + 4);
     GLsizei compsize;
 
     if (swap) {
-        SWAP_32( pname );
+        pname = bswap_32(pname);
     }
 
     compsize = __glTexEnvfv_size(pname);
@@ -258,13 +252,13 @@ __glXTexEnvfvReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXTexGendvReqSize( const GLbyte * pc, Bool swap )
+__glXTexGendvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLenum pname       = * (GLenum *)(pc + 4);
+    GLenum pname = *(GLenum *) (pc + 4);
     GLsizei compsize;
 
     if (swap) {
-        SWAP_32( pname );
+        pname = bswap_32(pname);
     }
 
     compsize = __glTexGendv_size(pname);
@@ -272,13 +266,13 @@ __glXTexGendvReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXTexGenfvReqSize( const GLbyte * pc, Bool swap )
+__glXTexGenfvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLenum pname       = * (GLenum *)(pc + 4);
+    GLenum pname = *(GLenum *) (pc + 4);
     GLsizei compsize;
 
     if (swap) {
-        SWAP_32( pname );
+        pname = bswap_32(pname);
     }
 
     compsize = __glTexGenfv_size(pname);
@@ -286,50 +280,50 @@ __glXTexGenfvReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXPixelMapfvReqSize( const GLbyte * pc, Bool swap )
+__glXPixelMapfvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei mapsize    = *(GLsizei *)(pc + 4);
+    GLsizei mapsize = *(GLsizei *) (pc + 4);
 
     if (swap) {
-        SWAP_32( mapsize );
+        mapsize = bswap_32(mapsize);
     }
 
     return __GLX_PAD((mapsize * 4));
 }
 
 int
-__glXPixelMapusvReqSize( const GLbyte * pc, Bool swap )
+__glXPixelMapusvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei mapsize    = *(GLsizei *)(pc + 4);
+    GLsizei mapsize = *(GLsizei *) (pc + 4);
 
     if (swap) {
-        SWAP_32( mapsize );
+        mapsize = bswap_32(mapsize);
     }
 
     return __GLX_PAD((mapsize * 2));
 }
 
 int
-__glXDrawPixelsReqSize( const GLbyte * pc, Bool swap )
+__glXDrawPixelsReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint row_length = *(GLint *) (pc + 4);
     GLint image_height = 0;
-    GLint skip_images  = 0;
-    GLint skip_rows    = *  (GLint *)(pc +  8);
-    GLint alignment    = *  (GLint *)(pc + 16);
-    GLsizei width      = *(GLsizei *)(pc + 20);
-    GLsizei height     = *(GLsizei *)(pc + 24);
-    GLenum format      = * (GLenum *)(pc + 28);
-    GLenum type        = * (GLenum *)(pc + 32);
+    GLint skip_images = 0;
+    GLint skip_rows = *(GLint *) (pc + 8);
+    GLint alignment = *(GLint *) (pc + 16);
+    GLsizei width = *(GLsizei *) (pc + 20);
+    GLsizei height = *(GLsizei *) (pc + 24);
+    GLenum format = *(GLenum *) (pc + 28);
+    GLenum type = *(GLenum *) (pc + 32);
 
     if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( skip_rows );
-        SWAP_32( alignment );
-        SWAP_32( width );
-        SWAP_32( height );
-        SWAP_32( format );
-        SWAP_32( type );
+        row_length = bswap_32(row_length);
+        skip_rows = bswap_32(skip_rows);
+        alignment = bswap_32(alignment);
+        width = bswap_32(width);
+        height = bswap_32(height);
+        format = bswap_32(format);
+        type = bswap_32(type);
     }
 
     return __glXImageSize(format, type, 0, width, height, 1,
@@ -338,38 +332,38 @@ __glXDrawPixelsReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXPrioritizeTexturesReqSize( const GLbyte * pc, Bool swap )
+__glXPrioritizeTexturesReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei n          = *(GLsizei *)(pc + 0);
+    GLsizei n = *(GLsizei *) (pc + 0);
 
     if (swap) {
-        SWAP_32( n );
+        n = bswap_32(n);
     }
 
     return __GLX_PAD((n * 4) + (n * 4));
 }
 
 int
-__glXTexSubImage1DReqSize( const GLbyte * pc, Bool swap )
+__glXTexSubImage1DReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint row_length = *(GLint *) (pc + 4);
     GLint image_height = 0;
-    GLint skip_images  = 0;
-    GLint skip_rows    = *  (GLint *)(pc +  8);
-    GLint alignment    = *  (GLint *)(pc + 16);
-    GLenum target      = * (GLenum *)(pc + 20);
-    GLsizei width      = *(GLsizei *)(pc + 36);
-    GLenum format      = * (GLenum *)(pc + 44);
-    GLenum type        = * (GLenum *)(pc + 48);
+    GLint skip_images = 0;
+    GLint skip_rows = *(GLint *) (pc + 8);
+    GLint alignment = *(GLint *) (pc + 16);
+    GLenum target = *(GLenum *) (pc + 20);
+    GLsizei width = *(GLsizei *) (pc + 36);
+    GLenum format = *(GLenum *) (pc + 44);
+    GLenum type = *(GLenum *) (pc + 48);
 
     if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( skip_rows );
-        SWAP_32( alignment );
-        SWAP_32( target );
-        SWAP_32( width );
-        SWAP_32( format );
-        SWAP_32( type );
+        row_length = bswap_32(row_length);
+        skip_rows = bswap_32(skip_rows);
+        alignment = bswap_32(alignment);
+        target = bswap_32(target);
+        width = bswap_32(width);
+        format = bswap_32(format);
+        type = bswap_32(type);
     }
 
     return __glXImageSize(format, type, target, width, 1, 1,
@@ -378,28 +372,28 @@ __glXTexSubImage1DReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXTexSubImage2DReqSize( const GLbyte * pc, Bool swap )
+__glXTexSubImage2DReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint row_length = *(GLint *) (pc + 4);
     GLint image_height = 0;
-    GLint skip_images  = 0;
-    GLint skip_rows    = *  (GLint *)(pc +  8);
-    GLint alignment    = *  (GLint *)(pc + 16);
-    GLenum target      = * (GLenum *)(pc + 20);
-    GLsizei width      = *(GLsizei *)(pc + 36);
-    GLsizei height     = *(GLsizei *)(pc + 40);
-    GLenum format      = * (GLenum *)(pc + 44);
-    GLenum type        = * (GLenum *)(pc + 48);
-
-    if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( skip_rows );
-        SWAP_32( alignment );
-        SWAP_32( target );
-        SWAP_32( width );
-        SWAP_32( height );
-        SWAP_32( format );
-        SWAP_32( type );
+    GLint skip_images = 0;
+    GLint skip_rows = *(GLint *) (pc + 8);
+    GLint alignment = *(GLint *) (pc + 16);
+    GLenum target = *(GLenum *) (pc + 20);
+    GLsizei width = *(GLsizei *) (pc + 36);
+    GLsizei height = *(GLsizei *) (pc + 40);
+    GLenum format = *(GLenum *) (pc + 44);
+    GLenum type = *(GLenum *) (pc + 48);
+
+    if (swap) {
+        row_length = bswap_32(row_length);
+        skip_rows = bswap_32(skip_rows);
+        alignment = bswap_32(alignment);
+        target = bswap_32(target);
+        width = bswap_32(width);
+        height = bswap_32(height);
+        format = bswap_32(format);
+        type = bswap_32(type);
     }
 
     return __glXImageSize(format, type, target, width, height, 1,
@@ -408,26 +402,26 @@ __glXTexSubImage2DReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXColorTableReqSize( const GLbyte * pc, Bool swap )
+__glXColorTableReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint row_length = *(GLint *) (pc + 4);
     GLint image_height = 0;
-    GLint skip_images  = 0;
-    GLint skip_rows    = *  (GLint *)(pc +  8);
-    GLint alignment    = *  (GLint *)(pc + 16);
-    GLenum target      = * (GLenum *)(pc + 20);
-    GLsizei width      = *(GLsizei *)(pc + 28);
-    GLenum format      = * (GLenum *)(pc + 32);
-    GLenum type        = * (GLenum *)(pc + 36);
+    GLint skip_images = 0;
+    GLint skip_rows = *(GLint *) (pc + 8);
+    GLint alignment = *(GLint *) (pc + 16);
+    GLenum target = *(GLenum *) (pc + 20);
+    GLsizei width = *(GLsizei *) (pc + 28);
+    GLenum format = *(GLenum *) (pc + 32);
+    GLenum type = *(GLenum *) (pc + 36);
 
     if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( skip_rows );
-        SWAP_32( alignment );
-        SWAP_32( target );
-        SWAP_32( width );
-        SWAP_32( format );
-        SWAP_32( type );
+        row_length = bswap_32(row_length);
+        skip_rows = bswap_32(skip_rows);
+        alignment = bswap_32(alignment);
+        target = bswap_32(target);
+        width = bswap_32(width);
+        format = bswap_32(format);
+        type = bswap_32(type);
     }
 
     return __glXImageSize(format, type, target, width, 1, 1,
@@ -436,13 +430,13 @@ __glXColorTableReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXColorTableParameterfvReqSize( const GLbyte * pc, Bool swap )
+__glXColorTableParameterfvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLenum pname       = * (GLenum *)(pc + 4);
+    GLenum pname = *(GLenum *) (pc + 4);
     GLsizei compsize;
 
     if (swap) {
-        SWAP_32( pname );
+        pname = bswap_32(pname);
     }
 
     compsize = __glColorTableParameterfv_size(pname);
@@ -450,26 +444,26 @@ __glXColorTableParameterfvReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXColorSubTableReqSize( const GLbyte * pc, Bool swap )
+__glXColorSubTableReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint row_length = *(GLint *) (pc + 4);
     GLint image_height = 0;
-    GLint skip_images  = 0;
-    GLint skip_rows    = *  (GLint *)(pc +  8);
-    GLint alignment    = *  (GLint *)(pc + 16);
-    GLenum target      = * (GLenum *)(pc + 20);
-    GLsizei count      = *(GLsizei *)(pc + 28);
-    GLenum format      = * (GLenum *)(pc + 32);
-    GLenum type        = * (GLenum *)(pc + 36);
+    GLint skip_images = 0;
+    GLint skip_rows = *(GLint *) (pc + 8);
+    GLint alignment = *(GLint *) (pc + 16);
+    GLenum target = *(GLenum *) (pc + 20);
+    GLsizei count = *(GLsizei *) (pc + 28);
+    GLenum format = *(GLenum *) (pc + 32);
+    GLenum type = *(GLenum *) (pc + 36);
 
     if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( skip_rows );
-        SWAP_32( alignment );
-        SWAP_32( target );
-        SWAP_32( count );
-        SWAP_32( format );
-        SWAP_32( type );
+        row_length = bswap_32(row_length);
+        skip_rows = bswap_32(skip_rows);
+        alignment = bswap_32(alignment);
+        target = bswap_32(target);
+        count = bswap_32(count);
+        format = bswap_32(format);
+        type = bswap_32(type);
     }
 
     return __glXImageSize(format, type, target, count, 1, 1,
@@ -478,26 +472,26 @@ __glXColorSubTableReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXConvolutionFilter1DReqSize( const GLbyte * pc, Bool swap )
+__glXConvolutionFilter1DReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint row_length = *(GLint *) (pc + 4);
     GLint image_height = 0;
-    GLint skip_images  = 0;
-    GLint skip_rows    = *  (GLint *)(pc +  8);
-    GLint alignment    = *  (GLint *)(pc + 16);
-    GLenum target      = * (GLenum *)(pc + 20);
-    GLsizei width      = *(GLsizei *)(pc + 28);
-    GLenum format      = * (GLenum *)(pc + 36);
-    GLenum type        = * (GLenum *)(pc + 40);
+    GLint skip_images = 0;
+    GLint skip_rows = *(GLint *) (pc + 8);
+    GLint alignment = *(GLint *) (pc + 16);
+    GLenum target = *(GLenum *) (pc + 20);
+    GLsizei width = *(GLsizei *) (pc + 28);
+    GLenum format = *(GLenum *) (pc + 36);
+    GLenum type = *(GLenum *) (pc + 40);
 
     if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( skip_rows );
-        SWAP_32( alignment );
-        SWAP_32( target );
-        SWAP_32( width );
-        SWAP_32( format );
-        SWAP_32( type );
+        row_length = bswap_32(row_length);
+        skip_rows = bswap_32(skip_rows);
+        alignment = bswap_32(alignment);
+        target = bswap_32(target);
+        width = bswap_32(width);
+        format = bswap_32(format);
+        type = bswap_32(type);
     }
 
     return __glXImageSize(format, type, target, width, 1, 1,
@@ -506,28 +500,28 @@ __glXConvolutionFilter1DReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXConvolutionFilter2DReqSize( const GLbyte * pc, Bool swap )
+__glXConvolutionFilter2DReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
+    GLint row_length = *(GLint *) (pc + 4);
     GLint image_height = 0;
-    GLint skip_images  = 0;
-    GLint skip_rows    = *  (GLint *)(pc +  8);
-    GLint alignment    = *  (GLint *)(pc + 16);
-    GLenum target      = * (GLenum *)(pc + 20);
-    GLsizei width      = *(GLsizei *)(pc + 28);
-    GLsizei height     = *(GLsizei *)(pc + 32);
-    GLenum format      = * (GLenum *)(pc + 36);
-    GLenum type        = * (GLenum *)(pc + 40);
-
-    if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( skip_rows );
-        SWAP_32( alignment );
-        SWAP_32( target );
-        SWAP_32( width );
-        SWAP_32( height );
-        SWAP_32( format );
-        SWAP_32( type );
+    GLint skip_images = 0;
+    GLint skip_rows = *(GLint *) (pc + 8);
+    GLint alignment = *(GLint *) (pc + 16);
+    GLenum target = *(GLenum *) (pc + 20);
+    GLsizei width = *(GLsizei *) (pc + 28);
+    GLsizei height = *(GLsizei *) (pc + 32);
+    GLenum format = *(GLenum *) (pc + 36);
+    GLenum type = *(GLenum *) (pc + 40);
+
+    if (swap) {
+        row_length = bswap_32(row_length);
+        skip_rows = bswap_32(skip_rows);
+        alignment = bswap_32(alignment);
+        target = bswap_32(target);
+        width = bswap_32(width);
+        height = bswap_32(height);
+        format = bswap_32(format);
+        type = bswap_32(type);
     }
 
     return __glXImageSize(format, type, target, width, height, 1,
@@ -536,13 +530,13 @@ __glXConvolutionFilter2DReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXConvolutionParameterfvReqSize( const GLbyte * pc, Bool swap )
+__glXConvolutionParameterfvReqSize(const GLbyte *pc, Bool swap)
 {
-    GLenum pname       = * (GLenum *)(pc + 4);
+    GLenum pname = *(GLenum *) (pc + 4);
     GLsizei compsize;
 
     if (swap) {
-        SWAP_32( pname );
+        pname = bswap_32(pname);
     }
 
     compsize = __glConvolutionParameterfv_size(pname);
@@ -550,32 +544,32 @@ __glXConvolutionParameterfvReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXTexImage3DReqSize( const GLbyte * pc, Bool swap )
+__glXTexImage3DReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
-    GLint image_height = *  (GLint *)(pc +  8);
-    GLint skip_rows    = *  (GLint *)(pc + 16);
-    GLint skip_images  = *  (GLint *)(pc + 20);
-    GLint alignment    = *  (GLint *)(pc + 32);
-    GLenum target      = * (GLenum *)(pc + 36);
-    GLsizei width      = *(GLsizei *)(pc + 48);
-    GLsizei height     = *(GLsizei *)(pc + 52);
-    GLsizei depth      = *(GLsizei *)(pc + 56);
-    GLenum format      = * (GLenum *)(pc + 68);
-    GLenum type        = * (GLenum *)(pc + 72);
+    GLint row_length = *(GLint *) (pc + 4);
+    GLint image_height = *(GLint *) (pc + 8);
+    GLint skip_rows = *(GLint *) (pc + 16);
+    GLint skip_images = *(GLint *) (pc + 20);
+    GLint alignment = *(GLint *) (pc + 32);
+    GLenum target = *(GLenum *) (pc + 36);
+    GLsizei width = *(GLsizei *) (pc + 48);
+    GLsizei height = *(GLsizei *) (pc + 52);
+    GLsizei depth = *(GLsizei *) (pc + 56);
+    GLenum format = *(GLenum *) (pc + 68);
+    GLenum type = *(GLenum *) (pc + 72);
 
     if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( image_height );
-        SWAP_32( skip_rows );
-        SWAP_32( skip_images );
-        SWAP_32( alignment );
-        SWAP_32( target );
-        SWAP_32( width );
-        SWAP_32( height );
-        SWAP_32( depth );
-        SWAP_32( format );
-        SWAP_32( type );
+        row_length = bswap_32(row_length);
+        image_height = bswap_32(image_height);
+        skip_rows = bswap_32(skip_rows);
+        skip_images = bswap_32(skip_images);
+        alignment = bswap_32(alignment);
+        target = bswap_32(target);
+        width = bswap_32(width);
+        height = bswap_32(height);
+        depth = bswap_32(depth);
+        format = bswap_32(format);
+        type = bswap_32(type);
     }
 
     return __glXImageSize(format, type, target, width, height, depth,
@@ -584,32 +578,32 @@ __glXTexImage3DReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXTexSubImage3DReqSize( const GLbyte * pc, Bool swap )
+__glXTexSubImage3DReqSize(const GLbyte *pc, Bool swap)
 {
-    GLint row_length   = *  (GLint *)(pc +  4);
-    GLint image_height = *  (GLint *)(pc +  8);
-    GLint skip_rows    = *  (GLint *)(pc + 16);
-    GLint skip_images  = *  (GLint *)(pc + 20);
-    GLint alignment    = *  (GLint *)(pc + 32);
-    GLenum target      = * (GLenum *)(pc + 36);
-    GLsizei width      = *(GLsizei *)(pc + 60);
-    GLsizei height     = *(GLsizei *)(pc + 64);
-    GLsizei depth      = *(GLsizei *)(pc + 68);
-    GLenum format      = * (GLenum *)(pc + 76);
-    GLenum type        = * (GLenum *)(pc + 80);
+    GLint row_length = *(GLint *) (pc + 4);
+    GLint image_height = *(GLint *) (pc + 8);
+    GLint skip_rows = *(GLint *) (pc + 16);
+    GLint skip_images = *(GLint *) (pc + 20);
+    GLint alignment = *(GLint *) (pc + 32);
+    GLenum target = *(GLenum *) (pc + 36);
+    GLsizei width = *(GLsizei *) (pc + 60);
+    GLsizei height = *(GLsizei *) (pc + 64);
+    GLsizei depth = *(GLsizei *) (pc + 68);
+    GLenum format = *(GLenum *) (pc + 76);
+    GLenum type = *(GLenum *) (pc + 80);
 
     if (swap) {
-        SWAP_32( row_length );
-        SWAP_32( image_height );
-        SWAP_32( skip_rows );
-        SWAP_32( skip_images );
-        SWAP_32( alignment );
-        SWAP_32( target );
-        SWAP_32( width );
-        SWAP_32( height );
-        SWAP_32( depth );
-        SWAP_32( format );
-        SWAP_32( type );
+        row_length = bswap_32(row_length);
+        image_height = bswap_32(image_height);
+        skip_rows = bswap_32(skip_rows);
+        skip_images = bswap_32(skip_images);
+        alignment = bswap_32(alignment);
+        target = bswap_32(target);
+        width = bswap_32(width);
+        height = bswap_32(height);
+        depth = bswap_32(depth);
+        format = bswap_32(format);
+        type = bswap_32(type);
     }
 
     return __glXImageSize(format, type, target, width, height, depth,
@@ -618,221 +612,221 @@ __glXTexSubImage3DReqSize( const GLbyte * pc, Bool swap )
 }
 
 int
-__glXDrawBuffersARBReqSize( const GLbyte * pc, Bool swap )
+__glXCompressedTexImage1DARBReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei n          = *(GLsizei *)(pc + 0);
+    GLsizei imageSize = *(GLsizei *) (pc + 20);
 
     if (swap) {
-        SWAP_32( n );
+        imageSize = bswap_32(imageSize);
     }
 
-    return __GLX_PAD((n * 4));
+    return __GLX_PAD(imageSize);
 }
 
 int
-__glXPointParameterfvEXTReqSize( const GLbyte * pc, Bool swap )
+__glXCompressedTexImage2DARBReqSize(const GLbyte *pc, Bool swap)
 {
-    GLenum pname       = * (GLenum *)(pc + 0);
-    GLsizei compsize;
+    GLsizei imageSize = *(GLsizei *) (pc + 24);
 
     if (swap) {
-        SWAP_32( pname );
+        imageSize = bswap_32(imageSize);
     }
 
-    compsize = __glPointParameterfvEXT_size(pname);
-    return __GLX_PAD((compsize * 4));
+    return __GLX_PAD(imageSize);
 }
 
 int
-__glXCompressedTexImage3DARBReqSize( const GLbyte * pc, Bool swap )
+__glXCompressedTexImage3DARBReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei imageSize  = *(GLsizei *)(pc + 28);
+    GLsizei imageSize = *(GLsizei *) (pc + 28);
 
     if (swap) {
-        SWAP_32( imageSize );
+        imageSize = bswap_32(imageSize);
     }
 
     return __GLX_PAD(imageSize);
 }
 
 int
-__glXCompressedTexImage2DARBReqSize( const GLbyte * pc, Bool swap )
+__glXCompressedTexSubImage3DARBReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei imageSize  = *(GLsizei *)(pc + 24);
+    GLsizei imageSize = *(GLsizei *) (pc + 36);
 
     if (swap) {
-        SWAP_32( imageSize );
+        imageSize = bswap_32(imageSize);
     }
 
     return __GLX_PAD(imageSize);
 }
 
 int
-__glXCompressedTexImage1DARBReqSize( const GLbyte * pc, Bool swap )
+__glXProgramStringARBReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei imageSize  = *(GLsizei *)(pc + 20);
+    GLsizei len = *(GLsizei *) (pc + 8);
 
     if (swap) {
-        SWAP_32( imageSize );
+        len = bswap_32(len);
     }
 
-    return __GLX_PAD(imageSize);
+    return __GLX_PAD(len);
 }
 
 int
-__glXCompressedTexSubImage3DARBReqSize( const GLbyte * pc, Bool swap )
+__glXDrawBuffersARBReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei imageSize  = *(GLsizei *)(pc + 36);
+    GLsizei n = *(GLsizei *) (pc + 0);
 
     if (swap) {
-        SWAP_32( imageSize );
+        n = bswap_32(n);
     }
 
-    return __GLX_PAD(imageSize);
+    return __GLX_PAD((n * 4));
 }
 
 int
-__glXLoadProgramNVReqSize( const GLbyte * pc, Bool swap )
+__glXPointParameterfvEXTReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei len        = *(GLsizei *)(pc + 8);
+    GLenum pname = *(GLenum *) (pc + 0);
+    GLsizei compsize;
 
     if (swap) {
-        SWAP_32( len );
+        pname = bswap_32(pname);
     }
 
-    return __GLX_PAD(len);
+    compsize = __glPointParameterfvEXT_size(pname);
+    return __GLX_PAD((compsize * 4));
 }
 
 int
-__glXProgramParameters4dvNVReqSize( const GLbyte * pc, Bool swap )
+__glXProgramParameters4dvNVReqSize(const GLbyte *pc, Bool swap)
 {
-    GLuint num         = * (GLuint *)(pc + 8);
+    GLuint num = *(GLuint *) (pc + 8);
 
     if (swap) {
-        SWAP_32( num );
+        num = bswap_32(num);
     }
 
     return __GLX_PAD((num * 32));
 }
 
 int
-__glXProgramParameters4fvNVReqSize( const GLbyte * pc, Bool swap )
+__glXProgramParameters4fvNVReqSize(const GLbyte *pc, Bool swap)
 {
-    GLuint num         = * (GLuint *)(pc + 8);
+    GLuint num = *(GLuint *) (pc + 8);
 
     if (swap) {
-        SWAP_32( num );
+        num = bswap_32(num);
     }
 
     return __GLX_PAD((num * 16));
 }
 
 int
-__glXVertexAttribs1dvNVReqSize( const GLbyte * pc, Bool swap )
+__glXVertexAttribs1dvNVReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei n          = *(GLsizei *)(pc + 4);
+    GLsizei n = *(GLsizei *) (pc + 4);
 
     if (swap) {
-        SWAP_32( n );
+        n = bswap_32(n);
     }
 
     return __GLX_PAD((n * 8));
 }
 
 int
-__glXVertexAttribs2dvNVReqSize( const GLbyte * pc, Bool swap )
+__glXVertexAttribs2dvNVReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei n          = *(GLsizei *)(pc + 4);
+    GLsizei n = *(GLsizei *) (pc + 4);
 
     if (swap) {
-        SWAP_32( n );
+        n = bswap_32(n);
     }
 
     return __GLX_PAD((n * 16));
 }
 
 int
-__glXVertexAttribs3dvNVReqSize( const GLbyte * pc, Bool swap )
+__glXVertexAttribs3dvNVReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei n          = *(GLsizei *)(pc + 4);
+    GLsizei n = *(GLsizei *) (pc + 4);
 
     if (swap) {
-        SWAP_32( n );
+        n = bswap_32(n);
     }
 
     return __GLX_PAD((n * 24));
 }
 
 int
-__glXVertexAttribs3fvNVReqSize( const GLbyte * pc, Bool swap )
+__glXVertexAttribs3fvNVReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei n          = *(GLsizei *)(pc + 4);
+    GLsizei n = *(GLsizei *) (pc + 4);
 
     if (swap) {
-        SWAP_32( n );
+        n = bswap_32(n);
     }
 
     return __GLX_PAD((n * 12));
 }
 
 int
-__glXVertexAttribs3svNVReqSize( const GLbyte * pc, Bool swap )
+__glXVertexAttribs3svNVReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei n          = *(GLsizei *)(pc + 4);
+    GLsizei n = *(GLsizei *) (pc + 4);
 
     if (swap) {
-        SWAP_32( n );
+        n = bswap_32(n);
     }
 
     return __GLX_PAD((n * 6));
 }
 
 int
-__glXVertexAttribs4dvNVReqSize( const GLbyte * pc, Bool swap )
+__glXVertexAttribs4dvNVReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei n          = *(GLsizei *)(pc + 4);
+    GLsizei n = *(GLsizei *) (pc + 4);
 
     if (swap) {
-        SWAP_32( n );
+        n = bswap_32(n);
     }
 
     return __GLX_PAD((n * 32));
 }
 
 int
-__glXProgramNamedParameter4fvNVReqSize( const GLbyte * pc, Bool swap )
+__glXProgramNamedParameter4fvNVReqSize(const GLbyte *pc, Bool swap)
 {
-    GLsizei len        = *(GLsizei *)(pc + 4);
+    GLsizei len = *(GLsizei *) (pc + 4);
 
     if (swap) {
-        SWAP_32( len );
+        len = bswap_32(len);
     }
 
     return __GLX_PAD(len);
 }
 
-ALIAS( Fogiv, Fogfv )
-ALIAS( Lightiv, Lightfv )
-ALIAS( LightModeliv, LightModelfv )
-ALIAS( Materialiv, Materialfv )
-ALIAS( TexParameteriv, TexParameterfv )
-ALIAS( TexEnviv, TexEnvfv )
-ALIAS( TexGeniv, TexGenfv )
-ALIAS( PixelMapuiv, PixelMapfv )
-ALIAS( ColorTableParameteriv, ColorTableParameterfv )
-ALIAS( ConvolutionParameteriv, ConvolutionParameterfv )
-ALIAS( CompressedTexSubImage2DARB, CompressedTexImage3DARB )
-ALIAS( CompressedTexSubImage1DARB, CompressedTexImage1DARB )
-ALIAS( RequestResidentProgramsNV, DrawBuffersARB )
-ALIAS( VertexAttribs1fvNV, PixelMapfv )
-ALIAS( VertexAttribs1svNV, PixelMapusv )
-ALIAS( VertexAttribs2fvNV, VertexAttribs1dvNV )
-ALIAS( VertexAttribs2svNV, PixelMapfv )
-ALIAS( VertexAttribs4fvNV, VertexAttribs2dvNV )
-ALIAS( VertexAttribs4svNV, VertexAttribs1dvNV )
-ALIAS( VertexAttribs4ubvNV, PixelMapfv )
-ALIAS( PointParameterivNV, PointParameterfvEXT )
-ALIAS( ProgramStringARB, LoadProgramNV )
-ALIAS( ProgramNamedParameter4dvNV, CompressedTexSubImage3DARB )
-ALIAS( DeleteRenderbuffersEXT, DrawBuffersARB )
-ALIAS( DeleteFramebuffersEXT, DrawBuffersARB )
+ALIAS(Fogiv, Fogfv)
+    ALIAS(Lightiv, Lightfv)
+    ALIAS(LightModeliv, LightModelfv)
+    ALIAS(Materialiv, Materialfv)
+    ALIAS(TexParameteriv, TexParameterfv)
+    ALIAS(TexEnviv, TexEnvfv)
+    ALIAS(TexGeniv, TexGenfv)
+    ALIAS(PixelMapuiv, PixelMapfv)
+    ALIAS(ColorTableParameteriv, ColorTableParameterfv)
+    ALIAS(ConvolutionParameteriv, ConvolutionParameterfv)
+    ALIAS(CompressedTexSubImage1DARB, CompressedTexImage1DARB)
+    ALIAS(CompressedTexSubImage2DARB, CompressedTexImage3DARB)
+    ALIAS(LoadProgramNV, ProgramStringARB)
+    ALIAS(RequestResidentProgramsNV, DrawBuffersARB)
+    ALIAS(VertexAttribs1fvNV, PixelMapfv)
+    ALIAS(VertexAttribs1svNV, PixelMapusv)
+    ALIAS(VertexAttribs2fvNV, VertexAttribs1dvNV)
+    ALIAS(VertexAttribs2svNV, PixelMapfv)
+    ALIAS(VertexAttribs4fvNV, VertexAttribs2dvNV)
+    ALIAS(VertexAttribs4svNV, VertexAttribs1dvNV)
+    ALIAS(VertexAttribs4ubvNV, PixelMapfv)
+    ALIAS(PointParameterivNV, PointParameterfvEXT)
+    ALIAS(ProgramNamedParameter4dvNV, CompressedTexSubImage3DARB)
+    ALIAS(DeleteFramebuffersEXT, DrawBuffersARB)
+    ALIAS(DeleteRenderbuffersEXT, DrawBuffersARB)
diff --git a/GL/glx/indirect_reqsize.h b/GL/glx/indirect_reqsize.h
index 23bc41c..26211ee 100644
--- a/GL/glx/indirect_reqsize.h
+++ b/GL/glx/indirect_reqsize.h
@@ -83,14 +83,15 @@ extern PURE HIDDEN int __glXConvolutionParameterivReqSize(const GLbyte *pc, Bool
 extern PURE HIDDEN int __glXSeparableFilter2DReqSize(const GLbyte *pc, Bool swap);
 extern PURE HIDDEN int __glXTexImage3DReqSize(const GLbyte *pc, Bool swap);
 extern PURE HIDDEN int __glXTexSubImage3DReqSize(const GLbyte *pc, Bool swap);
-extern PURE HIDDEN int __glXDrawBuffersARBReqSize(const GLbyte *pc, Bool swap);
-extern PURE HIDDEN int __glXPointParameterfvEXTReqSize(const GLbyte *pc, Bool swap);
-extern PURE HIDDEN int __glXCompressedTexImage3DARBReqSize(const GLbyte *pc, Bool swap);
-extern PURE HIDDEN int __glXCompressedTexImage2DARBReqSize(const GLbyte *pc, Bool swap);
 extern PURE HIDDEN int __glXCompressedTexImage1DARBReqSize(const GLbyte *pc, Bool swap);
-extern PURE HIDDEN int __glXCompressedTexSubImage3DARBReqSize(const GLbyte *pc, Bool swap);
-extern PURE HIDDEN int __glXCompressedTexSubImage2DARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXCompressedTexImage2DARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXCompressedTexImage3DARBReqSize(const GLbyte *pc, Bool swap);
 extern PURE HIDDEN int __glXCompressedTexSubImage1DARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXCompressedTexSubImage2DARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXCompressedTexSubImage3DARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXProgramStringARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXDrawBuffersARBReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXPointParameterfvEXTReqSize(const GLbyte *pc, Bool swap);
 extern PURE HIDDEN int __glXLoadProgramNVReqSize(const GLbyte *pc, Bool swap);
 extern PURE HIDDEN int __glXProgramParameters4dvNVReqSize(const GLbyte *pc, Bool swap);
 extern PURE HIDDEN int __glXProgramParameters4fvNVReqSize(const GLbyte *pc, Bool swap);
@@ -109,11 +110,10 @@ extern PURE HIDDEN int __glXVertexAttribs4fvNVReqSize(const GLbyte *pc, Bool swa
 extern PURE HIDDEN int __glXVertexAttribs4svNVReqSize(const GLbyte *pc, Bool swap);
 extern PURE HIDDEN int __glXVertexAttribs4ubvNVReqSize(const GLbyte *pc, Bool swap);
 extern PURE HIDDEN int __glXPointParameterivNVReqSize(const GLbyte *pc, Bool swap);
-extern PURE HIDDEN int __glXProgramStringARBReqSize(const GLbyte *pc, Bool swap);
-extern PURE HIDDEN int __glXProgramNamedParameter4fvNVReqSize(const GLbyte *pc, Bool swap);
 extern PURE HIDDEN int __glXProgramNamedParameter4dvNVReqSize(const GLbyte *pc, Bool swap);
-extern PURE HIDDEN int __glXDeleteRenderbuffersEXTReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXProgramNamedParameter4fvNVReqSize(const GLbyte *pc, Bool swap);
 extern PURE HIDDEN int __glXDeleteFramebuffersEXTReqSize(const GLbyte *pc, Bool swap);
+extern PURE HIDDEN int __glXDeleteRenderbuffersEXTReqSize(const GLbyte *pc, Bool swap);
 
 #  undef HIDDEN
 #  undef PURE
diff --git a/GL/glx/indirect_size_get.c b/GL/glx/indirect_size_get.c
index 150c6a1..f29ae47 100644
--- a/GL/glx/indirect_size_get.c
+++ b/GL/glx/indirect_size_get.c
@@ -370,6 +370,7 @@ __glGetBooleanv_size(GLenum e)
     case GL_PROJECTION_STACK_DEPTH:
     case GL_TEXTURE_STACK_DEPTH:
     case GL_ATTRIB_STACK_DEPTH:
+    case GL_CLIENT_ATTRIB_STACK_DEPTH:
     case GL_ALPHA_TEST:
     case GL_ALPHA_TEST_FUNC:
     case GL_ALPHA_TEST_REF:
@@ -448,6 +449,7 @@ __glGetBooleanv_size(GLenum e)
     case GL_MAX_NAME_STACK_DEPTH:
     case GL_MAX_PROJECTION_STACK_DEPTH:
     case GL_MAX_TEXTURE_STACK_DEPTH:
+    case GL_MAX_CLIENT_ATTRIB_STACK_DEPTH:
     case GL_SUBPIXEL_BITS:
     case GL_INDEX_BITS:
     case GL_RED_BITS:
@@ -639,7 +641,7 @@ __glGetBooleanv_size(GLenum e)
     case GL_PROGRAM_ERROR_POSITION_ARB:
     case GL_DEPTH_CLAMP_NV:
     case GL_NUM_COMPRESSED_TEXTURE_FORMATS:
-/*      case GL_NUM_TEXTURE_COMPRESSED_FORMATS_ARB:*/
+/*      case GL_NUM_COMPRESSED_TEXTURE_FORMATS_ARB:*/
     case GL_MAX_VERTEX_UNITS_ARB:
     case GL_ACTIVE_VERTEX_UNITS_ARB:
     case GL_WEIGHT_SUM_UNITY_ARB:
@@ -699,6 +701,8 @@ __glGetBooleanv_size(GLenum e)
 /*      case GL_POINT_SPRITE_NV:*/
     case GL_POINT_SPRITE_R_MODE_NV:
     case GL_MAX_VERTEX_ATTRIBS_ARB:
+    case GL_MAX_TEXTURE_COORDS_ARB:
+    case GL_MAX_TEXTURE_IMAGE_UNITS_ARB:
     case GL_DEPTH_BOUNDS_TEST_EXT:
     case GL_STENCIL_TEST_TWO_SIDE_EXT:
     case GL_ACTIVE_STENCIL_FACE_EXT:
@@ -1005,8 +1009,6 @@ __glGetProgramivARB_size(GLenum e)
     case GL_MAX_PROGRAM_NATIVE_ALU_INSTRUCTIONS_ARB:
     case GL_MAX_PROGRAM_NATIVE_TEX_INSTRUCTIONS_ARB:
     case GL_MAX_PROGRAM_NATIVE_TEX_INDIRECTIONS_ARB:
-    case GL_MAX_TEXTURE_COORDS_ARB:
-    case GL_MAX_TEXTURE_IMAGE_UNITS_ARB:
     case GL_PROGRAM_FORMAT_ARB:
     case GL_PROGRAM_INSTRUCTIONS_ARB:
     case GL_MAX_PROGRAM_INSTRUCTIONS_ARB:
diff --git a/GL/glx/indirect_texture_compression.c b/GL/glx/indirect_texture_compression.c
index 11f63c2..3c09663 100644
--- a/GL/glx/indirect_texture_compression.c
+++ b/GL/glx/indirect_texture_compression.c
@@ -29,6 +29,7 @@
 #endif
 
 #include "glxserver.h"
+#include "glxbyteorder.h"
 #include "glxext.h"
 #include "singlesize.h"
 #include "unpack.h"
@@ -39,20 +40,6 @@
 #include "glthread.h"
 #include "dispatch.h"
 
-#if defined(__linux__) || defined (__GLIBC__) || defined(__GNU__)
-#include <byteswap.h>
-#elif defined(__OpenBSD__)
-#include <sys/endian.h>
-#define bswap_16 __swap16
-#define bswap_32 __swap32
-#define bswap_64 __swap64
-#else
-#include <sys/endian.h>
-#define bswap_16 bswap16
-#define bswap_32 bswap32
-#define bswap_64 bswap64
-#endif
-
 int __glXDisp_GetCompressedTexImageARB(struct __GLXclientStateRec *cl, GLbyte *pc)
 {
     xGLXSingleReq * const req = (xGLXSingleReq *) pc;
diff --git a/GL/glx/indirect_util.c b/GL/glx/indirect_util.c
index 09b7ab8..58c194c 100644
--- a/GL/glx/indirect_util.c
+++ b/GL/glx/indirect_util.c
@@ -23,29 +23,21 @@
  * SOFTWARE.
  */
 
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
 #include <string.h>
 
 #include <X11/Xmd.h>
 #include <GL/gl.h>
 #include <GL/glxproto.h>
-#if defined(__linux__) || defined (__GLIBC__) || defined(__GNU__)
-#include <byteswap.h>
-#elif defined(__OpenBSD__)
-#include <sys/endian.h>
-#define bswap_16 __swap16
-#define bswap_32 __swap32
-#define bswap_64 __swap64
-#else
-#include <sys/endian.h>
-#define bswap_16 bswap16
-#define bswap_32 bswap32
-#define bswap_64 bswap64
-#endif
 #include <inttypes.h>
 #include "indirect_size.h"
 #include "indirect_size_get.h"
 #include "indirect_dispatch.h"
 #include "glxserver.h"
+#include "glxbyteorder.h"
 #include "singlesize.h"
 #include "glapitable.h"
 #include "glapi.h"
diff --git a/GL/glx/renderpix.c b/GL/glx/renderpix.c
index cd2a78d..2fe6301 100644
--- a/GL/glx/renderpix.c
+++ b/GL/glx/renderpix.c
@@ -1,4 +1,3 @@
-/* $XFree86$ */
 /*
 ** License Applicability. Except to the extent portions of this file are
 ** made subject to an alternative license as permitted in the SGI Free
diff --git a/GL/glx/renderpixswap.c b/GL/glx/renderpixswap.c
index 0a9f60f..8455807 100644
--- a/GL/glx/renderpixswap.c
+++ b/GL/glx/renderpixswap.c
@@ -1,4 +1,3 @@
-/* $XFree86$ */
 /*
 ** License Applicability. Except to the extent portions of this file are
 ** made subject to an alternative license as permitted in the SGI Free
diff --git a/GL/glx/singlepix.c b/GL/glx/singlepix.c
index 98898aa..d6b96de 100644
--- a/GL/glx/singlepix.c
+++ b/GL/glx/singlepix.c
@@ -1,4 +1,3 @@
-/* $XFree86$ */
 /*
 ** License Applicability. Except to the extent portions of this file are
 ** made subject to an alternative license as permitted in the SGI Free
diff --git a/GL/glx/singlesize.h b/GL/glx/singlesize.h
index 5d25b24..1cce1bc 100644
--- a/GL/glx/singlesize.h
+++ b/GL/glx/singlesize.h
@@ -1,4 +1,3 @@
-/* $XFree86$ */
 #ifdef HAVE_DIX_CONFIG_H
 #include <dix-config.h>
 #endif
diff --git a/GL/glx/swap_interval.c b/GL/glx/swap_interval.c
index f049ce5..24abd69 100644
--- a/GL/glx/swap_interval.c
+++ b/GL/glx/swap_interval.c
@@ -39,20 +39,7 @@
 #include "glthread.h"
 #include "dispatch.h"
 #include "glapioffsets.h"
-
-#if defined(__linux__) || defined (__GLIBC__) || defined(__GNU__)
-#include <byteswap.h>
-#elif defined(__OpenBSD__)
-#include <sys/endian.h>
-#define bswap_16 __swap16
-#define bswap_32 __swap32
-#define bswap_64 __swap64
-#else
-#include <sys/endian.h>
-#define bswap_16 bswap16
-#define bswap_32 bswap32
-#define bswap_64 bswap64
-#endif
+#include "glxbyteorder.h"
 
 static int DoSwapInterval(__GLXclientState *cl, GLbyte *pc, int do_swap);
 
diff --git a/GL/glx/xfont.c b/GL/glx/xfont.c
index b24c77d..9629cf1 100644
--- a/GL/glx/xfont.c
+++ b/GL/glx/xfont.c
@@ -1,4 +1,3 @@
-/* $XFree86$ */
 /*
 ** License Applicability. Except to the extent portions of this file are
 ** made subject to an alternative license as permitted in the SGI Free
diff --git a/GL/mesa/Makefile.am b/GL/mesa/Makefile.am
index 18eebfc..99d3834 100644
--- a/GL/mesa/Makefile.am
+++ b/GL/mesa/Makefile.am
@@ -1,15 +1,15 @@
-SUBDIRS = main math array_cache swrast swrast_setup tnl shader X glapi
+SUBDIRS = main math swrast swrast_setup tnl shader X glapi vbo
 
 noinst_LTLIBRARIES = libGLcore.la
 
 libGLcore_la_SOURCES = dummy.c
 libGLcore_la_LIBADD = main/libmain.la \
                       math/libmath.la \
-                      array_cache/libac.la \
                       swrast/libswrast.la \
                       swrast_setup/libss.la \
                       tnl/libtnl.la \
                       shader/libshader.la \
 		      shader/grammar/libgrammar.la \
 		      shader/slang/libslang.la \
+                      vbo/libvbo.la \
                       X/libX.la
diff --git a/GL/mesa/X/Makefile.am b/GL/mesa/X/Makefile.am
index 2a9f422..ace1181 100644
--- a/GL/mesa/X/Makefile.am
+++ b/GL/mesa/X/Makefile.am
@@ -2,7 +2,6 @@ noinst_LTLIBRARIES = libX.la
 
 INCLUDES = -I@MESA_SOURCE@/include \
            -I../X \
-           -I../array_cache \
            -I../glapi \
            -I../main \
            -I../math \
@@ -21,18 +20,13 @@ INCLUDES = -I@MESA_SOURCE@/include \
 AM_CFLAGS = \
 	$(DIX_CFLAGS) \
 	-DXFree86Server \
-	@GLX_DEFINES@ \
-	-DXFree86Server
-
-libX_la_SOURCES = xf86glx.c \
-                  xf86glx_util.c \
-                  xf86glx_util.h \
-                  xf86glxint.h
+	@GLX_DEFINES@
 
 nodist_libX_la_SOURCES = \
                   xm_api.c \
 		  xm_buffer.c \
                   xm_dd.c \
+                  xm_image.c \
                   xm_line.c \
                   xm_span.c \
                   xm_tri.c \
diff --git a/GL/mesa/X/xf86glx.c b/GL/mesa/X/xf86glx.c
deleted file mode 100644
index 47c87f6..0000000
--- a/GL/mesa/X/xf86glx.c
+++ /dev/null
@@ -1,432 +0,0 @@
-/**************************************************************************
-
-Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
-All Rights Reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sub license, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice (including the
-next paragraph) shall be included in all copies or substantial portions
-of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
-IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
-ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-**************************************************************************/
-
-/*
- * Authors:
- *   Kevin E. Martin <kevin@precisioninsight.com>
- *   Brian E. Paul <brian@precisioninsight.com>
- *
- */
-
-#ifdef HAVE_DIX_CONFIG_H
-#include <dix-config.h>
-#endif
-
-#include <string.h>
-#include <regionstr.h>
-#include <resource.h>
-#include <GL/gl.h>
-#include <GL/glxint.h>
-#include <GL/glxtokens.h>
-#include <scrnintstr.h>
-#include <windowstr.h>
-#include <config.h>
-#include <glxserver.h>
-#include <glxscreens.h>
-#include <glxdrawable.h>
-#include <glxcontext.h>
-#include <glxext.h>
-#include <glxutil.h>
-#include "context.h"
-#include "xmesaP.h"
-#include "context.h"
-
-#include "glcontextmodes.h"
-#include "os.h"
-
-/*
- * This define is for the glcore.h header file.
- * If you add it here, then make sure you also add it in
- * ../../../glx/Imakefile.
- */
-#if 0
-#define DEBUG
-#include <GL/internal/glcore.h>
-#undef DEBUG
-#else
-#include <GL/internal/glcore.h>
-#endif
-
-typedef struct __GLXMESAscreen   __GLXMESAscreen;
-typedef struct __GLXMESAcontext  __GLXMESAcontext;
-typedef struct __GLXMESAdrawable __GLXMESAdrawable;
-
-struct __GLXMESAscreen {
-    __GLXscreen   base;
-    int           index;
-    int		  num_vis;
-    XMesaVisual  *xm_vis;
-};
-
-struct __GLXMESAcontext {
-    __GLXcontext base;
-    XMesaContext xmesa;
-};
-
-struct __GLXMESAdrawable {
-    __GLXdrawable base;
-    XMesaBuffer   xm_buf;
-};
-
-static XMesaVisual find_mesa_visual(__GLXscreen *screen, VisualID vid);
-
-
-static void
-__glXMesaDrawableDestroy(__GLXdrawable *base)
-{
-    __GLXMESAdrawable *glxPriv = (__GLXMESAdrawable *) base;
-
-    if (glxPriv->xm_buf != NULL)
-      XMesaDestroyBuffer(glxPriv->xm_buf);
-    xfree(glxPriv);
-}
-
-static GLboolean
-__glXMesaDrawableResize(__GLXdrawable *base)
-{
-    __GLXMESAdrawable *glxPriv = (__GLXMESAdrawable *) base;
-
-    XMesaResizeBuffers(glxPriv->xm_buf);
-
-    return GL_TRUE;
-}
-
-static GLboolean
-__glXMesaDrawableSwapBuffers(__GLXdrawable *base)
-{
-    __GLXMESAdrawable *glxPriv = (__GLXMESAdrawable *) base;
-
-    /* This is terrifying: XMesaSwapBuffers() ends up calling CopyArea
-     * to do the buffer swap, but this assumes that the server holds
-     * the lock and has its context visible.  If another screen uses a
-     * DRI driver, that will have installed the DRI enter/leave server
-     * functions, which lifts the lock during GLX dispatch.  This is
-     * why we need to re-take the lock and swap in the server context
-     * before calling XMesaSwapBuffers() here.  /me shakes head. */
-
-    __glXenterServer();
-
-    XMesaSwapBuffers(glxPriv->xm_buf);
-
-    __glXleaveServer();
-
-    return GL_TRUE;
-}
-
-
-static __GLXdrawable *
-__glXMesaScreenCreateDrawable(__GLXscreen *screen,
-			      DrawablePtr pDraw,
-			      XID drawId,
-			      __GLcontextModes *modes)
-{
-    __GLXMESAdrawable *glxPriv;
-    XMesaVisual xm_vis;
-
-    glxPriv = xalloc(sizeof *glxPriv);
-    if (glxPriv == NULL)
-	return NULL;
-
-    memset(glxPriv, 0, sizeof *glxPriv);
-
-    if (!__glXDrawableInit(&glxPriv->base, screen, pDraw, drawId, modes)) {
-        xfree(glxPriv);
-	return NULL;
-    }
-
-    glxPriv->base.destroy     = __glXMesaDrawableDestroy;
-    glxPriv->base.resize      = __glXMesaDrawableResize;
-    glxPriv->base.swapBuffers = __glXMesaDrawableSwapBuffers;
-
-    xm_vis = find_mesa_visual(screen, modes->visualID);
-    if (xm_vis == NULL) {
-	ErrorF("find_mesa_visual returned NULL for visualID = 0x%04x\n",
-	       modes->visualID);
-	xfree(glxPriv);
-	return NULL;
-    }
-
-    if (glxPriv->base.type == DRAWABLE_WINDOW) {
-	glxPriv->xm_buf = XMesaCreateWindowBuffer(xm_vis, (WindowPtr)pDraw);
-    } else {
-	glxPriv->xm_buf = XMesaCreatePixmapBuffer(xm_vis, (PixmapPtr)pDraw, 0);
-    }
-
-    return &glxPriv->base;
-}
-
-static void
-__glXMesaContextDestroy(__GLXcontext *baseContext)
-{
-    __GLXMESAcontext *context = (__GLXMESAcontext *) baseContext;
-
-    XMesaDestroyContext(context->xmesa);
-    __glXContextDestroy(&context->base);
-    xfree(context);
-}
-
-static int
-__glXMesaContextMakeCurrent(__GLXcontext *baseContext)
-
-{
-    __GLXMESAcontext *context = (__GLXMESAcontext *) baseContext;
-    __GLXMESAdrawable *drawPriv = (__GLXMESAdrawable *) context->base.drawPriv;
-    __GLXMESAdrawable *readPriv = (__GLXMESAdrawable *) context->base.readPriv;
-
-    return XMesaMakeCurrent2(context->xmesa,
-			     drawPriv->xm_buf,
-			     readPriv->xm_buf);
-}
-
-static int
-__glXMesaContextLoseCurrent(__GLXcontext *baseContext)
-{
-    __GLXMESAcontext *context = (__GLXMESAcontext *) baseContext;
-
-    return XMesaLoseCurrent(context->xmesa);
-}
-
-static int
-__glXMesaContextCopy(__GLXcontext *baseDst,
-		     __GLXcontext *baseSrc,
-		     unsigned long mask)
-{
-    __GLXMESAcontext *dst = (__GLXMESAcontext *) baseDst;
-    __GLXMESAcontext *src = (__GLXMESAcontext *) baseSrc;
-
-    _mesa_copy_context(&src->xmesa->mesa, &dst->xmesa->mesa, mask);
-    return GL_TRUE;
-}
-
-static int
-__glXMesaContextForceCurrent(__GLXcontext *baseContext)
-{
-    __GLXMESAcontext *context = (__GLXMESAcontext *) baseContext;
-
-    GlxSetRenderTables (context->xmesa->mesa.CurrentDispatch);
-
-    return XMesaForceCurrent(context->xmesa);
-}
-
-static __GLXcontext *
-__glXMesaScreenCreateContext(__GLXscreen *screen,
-			     __GLcontextModes *modes,
-			     __GLXcontext *baseShareContext)
-{
-    __GLXMESAcontext *context;
-    __GLXMESAcontext *shareContext = (__GLXMESAcontext *) baseShareContext;
-    XMesaVisual xm_vis;
-    XMesaContext xm_share;
-
-    context = xalloc (sizeof (__GLXMESAcontext));
-    if (context == NULL)
-	return NULL;
-
-    memset(context, 0, sizeof *context);
-
-    context->base.pGlxScreen = screen;
-    context->base.modes      = modes;
-
-    context->base.destroy        = __glXMesaContextDestroy;
-    context->base.makeCurrent    = __glXMesaContextMakeCurrent;
-    context->base.loseCurrent    = __glXMesaContextLoseCurrent;
-    context->base.copy           = __glXMesaContextCopy;
-    context->base.forceCurrent   = __glXMesaContextForceCurrent;
-
-    xm_vis = find_mesa_visual(screen, modes->visualID);
-    if (!xm_vis) {
-	ErrorF("find_mesa_visual returned NULL for visualID = 0x%04x\n",
-	       modes->visualID);
-	xfree(context);
-	return NULL;
-    }
-
-    xm_share = shareContext ? shareContext->xmesa : NULL;
-    context->xmesa = XMesaCreateContext(xm_vis, xm_share);
-    if (!context->xmesa) {
-	xfree(context);
-	return NULL;
-    }
-
-    return &context->base;
-}
-
-static void
-__glXMesaScreenDestroy(__GLXscreen *screen)
-{
-    __GLXMESAscreen *mesaScreen = (__GLXMESAscreen *) screen;
-    int i;
-
-    for (i = 0; i < mesaScreen->num_vis; i++) {
-	if (mesaScreen->xm_vis[i])
-	    XMesaDestroyVisual(mesaScreen->xm_vis[i]);
-    }
-
-    xfree(mesaScreen->xm_vis);
-
-    __glXScreenDestroy(screen);
-
-    xfree(screen);
-}
-
-static XMesaVisual
-find_mesa_visual(__GLXscreen *screen, VisualID vid)
-{
-    __GLXMESAscreen *mesaScreen = (__GLXMESAscreen *) screen;
-    const __GLcontextModes *modes;
-    unsigned i = 0;
-
-    for ( modes = screen->modes ; modes != NULL ; modes = modes->next ) {
-	if ( modes->visualID == vid ) {
-	    break;
-	}
-
-	i++;
-    }
-
-    return (modes != NULL) ? mesaScreen->xm_vis[i] : NULL;
-}
-
-static void init_screen_visuals(__GLXMESAscreen *screen)
-{
-    ScreenPtr pScreen = screen->base.pScreen;
-    __GLcontextModes *modes;
-    XMesaVisual *pXMesaVisual;
-    int *used;
-    int i, j, size;
-
-    /* Alloc space for the list of XMesa visuals */
-    size = screen->base.numVisuals * sizeof(XMesaVisual);
-    pXMesaVisual = (XMesaVisual *) xalloc(size);
-    memset(pXMesaVisual, 0, size);
-
-    /* FIXME: Change 'used' to be a array of bits (rather than of ints),
-     * FIXME: create a stack array of 8 or 16 bytes.  If 'numVisuals' is less
-     * FIXME: than 64 or 128 the stack array can be used instead of calling
-     * FIXME: __glXMalloc / __glXFree.  If nothing else, convert 'used' to
-     * FIXME: array of bytes instead of ints!
-     */
-    used = (int *) xalloc(pScreen->numVisuals * sizeof(int));
-    memset(used, 0, pScreen->numVisuals * sizeof(int));
-
-    i = 0;
-    for ( modes = screen->base.modes; modes != NULL; modes = modes->next ) {
-	const int vis_class = _gl_convert_to_x_visual_type( modes->visualType );
-	const int nplanes = (modes->rgbBits - modes->alphaBits);
-	const VisualPtr pVis = pScreen->visuals;
-
-	for (j = 0; j < pScreen->numVisuals; j++) {
-	    if (pVis[j].class     == vis_class &&
-		pVis[j].nplanes   == nplanes &&
-		pVis[j].redMask   == modes->redMask &&
-		pVis[j].greenMask == modes->greenMask &&
-		pVis[j].blueMask  == modes->blueMask &&
-		!used[j]) {
-
-		/* Create the XMesa visual */
-		pXMesaVisual[i] =
-		    XMesaCreateVisual(pScreen,
-				      &pVis[j],
-				      modes->rgbMode,
-				      (modes->alphaBits > 0),
-				      modes->doubleBufferMode,
-				      modes->stereoMode,
-				      GL_TRUE, /* ximage_flag */
-				      modes->depthBits,
-				      modes->stencilBits,
-				      modes->accumRedBits,
-				      modes->accumGreenBits,
-				      modes->accumBlueBits,
-				      modes->accumAlphaBits,
-				      modes->samples,
-				      modes->level,
-				      modes->visualRating);
-		/* Set the VisualID */
-		modes->visualID = pVis[j].vid;
-
-		/* Mark this visual used */
-		used[j] = 1;
-		break;
-	    }
-	}
-
-	if ( j == pScreen->numVisuals ) {
-	    ErrorF("No matching visual for __GLcontextMode with "
-		   "visual class = %d (%d), nplanes = %u\n",
-		   vis_class, 
-		   modes->visualType,
-		   (modes->rgbBits - modes->alphaBits) );
-	}
-	else if ( modes->visualID == -1 ) {
-	    FatalError( "Matching visual found, but visualID still -1!\n" );
-	}
-
-	i++;
-    }
-
-    xfree(used);
-
-    screen->num_vis = pScreen->numVisuals;
-    screen->xm_vis = pXMesaVisual;
-}
-
-static __GLXscreen *
-__glXMesaScreenProbe(ScreenPtr pScreen)
-{
-    __GLXMESAscreen *screen;
-
-    screen = xalloc(sizeof *screen);
-    if (screen == NULL)
-	return NULL;
-
-    __glXScreenInit(&screen->base, pScreen);
-
-    screen->base.destroy        = __glXMesaScreenDestroy;
-    screen->base.createContext  = __glXMesaScreenCreateContext;
-    screen->base.createDrawable = __glXMesaScreenCreateDrawable;
-    screen->base.pScreen       = pScreen;
-
-    /*
-     * Find the GLX visuals that are supported by this screen and create
-     * XMesa's visuals.
-     */
-    init_screen_visuals(screen);
-
-    return &screen->base;
-}
-
-__GLXprovider __glXMesaProvider = {
-    __glXMesaScreenProbe,
-    "MESA",
-    NULL
-};
-
-__GLXprovider *
-GlxGetMesaProvider (void)
-{
-    return &__glXMesaProvider;
-}
diff --git a/GL/mesa/X/xf86glx_util.c b/GL/mesa/X/xf86glx_util.c
deleted file mode 100644
index ffb5280..0000000
--- a/GL/mesa/X/xf86glx_util.c
+++ /dev/null
@@ -1,151 +0,0 @@
-/**************************************************************************
-
-Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
-All Rights Reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sub license, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice (including the
-next paragraph) shall be included in all copies or substantial portions
-of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
-IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
-ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-**************************************************************************/
-
-/*
- * Authors:
- *   Kevin E. Martin <kevin@precisioninsight.com>
- *   Brian Paul <brian@precisioninsight.com>
- */
-
-#ifdef HAVE_DIX_CONFIG_H
-#include <dix-config.h>
-#endif
-
-#include <stdlib.h>
-
-#include <gcstruct.h>
-#include "pixmapstr.h"
-#include "xf86glx_util.h"
-#include <X11/Xmd.h>
-
-#ifdef ROUNDUP
-#undef ROUNDUP
-#endif
-
-#define ROUNDUP(nbytes, pad) ((((nbytes) + ((pad)-1)) / (pad)) * ((pad)>>3))
-
-XMesaImage *XMesaCreateImage(int bitsPerPixel, int width, int height, char *data)
-{
-    XMesaImage *image;
-
-    image = (XMesaImage *)xalloc(sizeof(XMesaImage));
-
-    if (image) {
-	image->width = width;
-	image->height = height;
-	image->data = data;
-	/* Always pad to 32 bits */
-	image->bytes_per_line = ROUNDUP((bitsPerPixel * width), 32);
-	image->bits_per_pixel = bitsPerPixel;
-    }
-
-    return image;
-}
-
-void XMesaDestroyImage(XMesaImage *image)
-{
-    if (image->data)
-	free(image->data);
-    xfree(image);
-}
-
-unsigned long XMesaGetPixel(XMesaImage *image, int x, int y)
-{
-    CARD8  *row = (CARD8 *)(image->data + y*image->bytes_per_line);
-    CARD8  *i8;
-    CARD16 *i16;
-    CARD32 *i32;
-    switch (image->bits_per_pixel) {
-    case 8:
-	i8 = (CARD8 *)row;
-	return i8[x];
-	break;
-    case 15:
-    case 16:
-	i16 = (CARD16 *)row;
-	return i16[x];
-	break;
-    case 24: /* WARNING: architecture specific code */
-	i8 = (CARD8 *)row;
-	return (((CARD32)i8[x*3]) |
-		(((CARD32)i8[x*3+1])<<8) |
-		(((CARD32)i8[x*3+2])<<16));
-	break;
-    case 32:
-	i32 = (CARD32 *)row;
-	return i32[x];
-	break;
-    }
-    return 0;
-}
-
-#ifndef XMESA_USE_PUTPIXEL_MACRO
-void XMesaPutPixel(XMesaImage *image, int x, int y, unsigned long pixel)
-{
-    CARD8  *row = (CARD8 *)(image->data + y*image->bytes_per_line);
-    CARD8  *i8;
-    CARD16 *i16;
-    CARD32 *i32;
-    switch (image->bits_per_pixel) {
-    case 8:
-	i8 = (CARD8 *)row;
-	i8[x] = (CARD8)pixel;
-	break;
-    case 15:
-    case 16:
-	i16 = (CARD16 *)row;
-	i16[x] = (CARD16)pixel;
-	break;
-    case 24: /* WARNING: architecture specific code */
-	i8 = (CARD8 *)__row;
-	i8[x*3]   = (CARD8)(p);
-	i8[x*3+1] = (CARD8)(p>>8);
-	i8[x*3+2] = (CARD8)(p>>16);
-    case 32:
-	i32 = (CARD32 *)row;
-	i32[x] = (CARD32)pixel;
-	break;
-    }
-}
-#endif
-
-void XMesaPutImageHelper(ScreenPtr display,
-			 DrawablePtr d, GCPtr gc,
-			 XMesaImage *image,
-			 int src_x, int src_y,
-			 int dest_x, int dest_y,
-			 unsigned int width, unsigned int height)
-{
-    /* NOT_DONE: Verify that the following works for all depths */
-    char *src = (image->data +
-		 src_y * image->bytes_per_line +
-		 ((src_x * image->bits_per_pixel) >> 3));
-
-    ValidateGC(d, gc);
-    (*gc->ops->PutImage)(d, gc, d->depth, dest_x, dest_y, width, height,
-			 0, ZPixmap, src);
-}
diff --git a/GL/mesa/X/xf86glx_util.h b/GL/mesa/X/xf86glx_util.h
deleted file mode 100644
index bb31412..0000000
--- a/GL/mesa/X/xf86glx_util.h
+++ /dev/null
@@ -1,105 +0,0 @@
-/**************************************************************************
-
-Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
-All Rights Reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sub license, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice (including the
-next paragraph) shall be included in all copies or substantial portions
-of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
-IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
-ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-**************************************************************************/
-
-/*
- * Authors:
- *   Kevin E. Martin <kevin@precisioninsight.com>
- *   Brian Paul <brian@precisioninsight.com>
- */
-
-#ifdef HAVE_DIX_CONFIG_H
-#include <dix-config.h>
-#endif
-
-#ifndef _XF86GLX_UTIL_H_
-#define _XF86GLX_UTIL_H_
-
-#ifdef __CYGWIN__
-#undef WIN32
-#undef _WIN32
-#endif
-
-#include <screenint.h>
-#include <pixmap.h>
-#include <gc.h>
-#include "GL/xmesa.h"
-
-#define XMESA_USE_PUTPIXEL_MACRO
-
-struct _XMesaImageRec {
-    int width, height;
-    char *data;
-    int bytes_per_line; /* Padded to 32 bits */
-    int bits_per_pixel;
-};
-
-extern XMesaImage *XMesaCreateImage(int bitsPerPixel, int width, int height,
-				    char *data);
-extern void XMesaDestroyImage(XMesaImage *image);
-extern unsigned long XMesaGetPixel(XMesaImage *image, int x, int y);
-#ifdef XMESA_USE_PUTPIXEL_MACRO
-#define XMesaPutPixel(__i,__x,__y,__p) \
-{ \
-    CARD8  *__row = (CARD8 *)(__i->data + __y*__i->bytes_per_line); \
-    CARD8  *__i8; \
-    CARD16 *__i16; \
-    CARD32 *__i32; \
-    switch (__i->bits_per_pixel) { \
-    case 8: \
-	__i8 = (CARD8 *)__row; \
-	__i8[__x] = (CARD8)__p; \
-	break; \
-    case 15: \
-    case 16: \
-	__i16 = (CARD16 *)__row; \
-	__i16[__x] = (CARD16)__p; \
-	break; \
-    case 24: /* WARNING: architecture specific code */ \
-	__i8 = (CARD8 *)__row; \
-	__i8[__x*3]   = (CARD8)(__p); \
-	__i8[__x*3+1] = (CARD8)(__p>>8); \
-	__i8[__x*3+2] = (CARD8)(__p>>16); \
-	break; \
-    case 32: \
-	__i32 = (CARD32 *)__row; \
-	__i32[__x] = (CARD32)__p; \
-	break; \
-    } \
-}
-#else
-extern void XMesaPutPixel(XMesaImage *image, int x, int y,
-			  unsigned long pixel);
-#endif
-
-extern void XMesaPutImageHelper(ScreenPtr display,
-				DrawablePtr d, GCPtr gc,
-				XMesaImage *image,
-				int src_x, int src_y,
-				int dest_x, int dest_y,
-				unsigned int width, unsigned int height);
-
-#endif /* _XF86GLX_UTIL_H_ */
diff --git a/GL/mesa/X/xf86glxint.h b/GL/mesa/X/xf86glxint.h
deleted file mode 100644
index 8c7e913..0000000
--- a/GL/mesa/X/xf86glxint.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/**************************************************************************
-
-Copyright 1998-1999 Precision Insight, Inc., Cedar Park, Texas.
-All Rights Reserved.
-
-Permission is hereby granted, free of charge, to any person obtaining a
-copy of this software and associated documentation files (the
-"Software"), to deal in the Software without restriction, including
-without limitation the rights to use, copy, modify, merge, publish,
-distribute, sub license, and/or sell copies of the Software, and to
-permit persons to whom the Software is furnished to do so, subject to
-the following conditions:
-
-The above copyright notice and this permission notice (including the
-next paragraph) shall be included in all copies or substantial portions
-of the Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
-OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
-MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
-IN NO EVENT SHALL PRECISION INSIGHT AND/OR ITS SUPPLIERS BE LIABLE FOR
-ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
-TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-
-**************************************************************************/
-
-/*
- * Authors:
- *   Kevin E. Martin <kevin@precisioninsight.com>
- *
- */
-
-#ifdef HAVE_DIX_CONFIG_H
-#include <dix-config.h>
-#endif
-
-#ifndef _XF86GLXINT_H_
-#define _XF86GLXINT_H_
-
-#include <miscstruct.h>
-#include <GL/gl.h>
-#include <GL/xmesa.h>
-
-#endif /* _XF86GLXINT_H_ */
diff --git a/GL/mesa/array_cache/Makefile.am b/GL/mesa/array_cache/Makefile.am
deleted file mode 100644
index 5016b73..0000000
--- a/GL/mesa/array_cache/Makefile.am
+++ /dev/null
@@ -1,21 +0,0 @@
-noinst_LTLIBRARIES = libac.la
-
-AM_CFLAGS = \
-	$(DIX_CFLAGS) \
-	-DXFree86Server \
-	@GLX_DEFINES@
-
-INCLUDES = -I@MESA_SOURCE@/include \
-           -I../X \
-           -I../array_cache \
-           -I../glapi \
-           -I../main \
-           -I../math \
-           -I../shader \
-           -I../swrast \
-           -I../swrast_setup \
-           -I../tnl \
-           -I.. \
-           -I$(top_srcdir)/hw/xfree86/os-support
-
-nodist_libac_la_SOURCES = ac_context.c ac_import.c
diff --git a/GL/mesa/glapi/Makefile.am b/GL/mesa/glapi/Makefile.am
index de457b9..db79114 100644
--- a/GL/mesa/glapi/Makefile.am
+++ b/GL/mesa/glapi/Makefile.am
@@ -7,7 +7,6 @@ AM_CFLAGS = \
 
 INCLUDES = -I@MESA_SOURCE@/include \
            -I../X \
-           -I../array_cache \
            -I../glapi \
            -I../main \
            -I../math \
diff --git a/GL/mesa/main/Makefile.am b/GL/mesa/main/Makefile.am
index 64b383d..f8ce137 100644
--- a/GL/mesa/main/Makefile.am
+++ b/GL/mesa/main/Makefile.am
@@ -7,7 +7,6 @@ AM_CFLAGS = \
 
 INCLUDES = -I@MESA_SOURCE@/include \
            -I../X \
-           -I../array_cache \
            -I../glapi \
            -I../main \
            -I../math \
@@ -62,13 +61,14 @@ nodist_libmain_la_SOURCES = accum.c \
                     matrix.c \
                     mipmap.c \
                     mm.c \
-                    occlude.c \
                     pixel.c \
                     points.c \
                     polygon.c \
+		    queryobj.c \
                     rastpos.c \
                     rbadaptors.c \
                     renderbuffer.c \
+                    shaders.c \
                     state.c \
                     stencil.c \
                     texcompress.c \
diff --git a/GL/mesa/math/Makefile.am b/GL/mesa/math/Makefile.am
index 5e99d90..c7c5642 100644
--- a/GL/mesa/math/Makefile.am
+++ b/GL/mesa/math/Makefile.am
@@ -7,7 +7,6 @@ AM_CFLAGS = \
 
 INCLUDES = -I@MESA_SOURCE@/include \
            -I../X \
-           -I../array_cache \
            -I../glapi \
            -I../main \
            -I../math \
diff --git a/GL/mesa/shader/Makefile.am b/GL/mesa/shader/Makefile.am
index 4bd5736..abde275 100644
--- a/GL/mesa/shader/Makefile.am
+++ b/GL/mesa/shader/Makefile.am
@@ -9,7 +9,6 @@ AM_CFLAGS = \
 
 INCLUDES = -I@MESA_SOURCE@/include \
            -I../X \
-           -I../array_cache \
            -I../glapi \
            -I../main \
            -I../math \
@@ -28,8 +27,13 @@ nodist_libshader_la_SOURCES = \
                       atifragshader.c \
                       nvfragparse.c \
                       nvprogram.c \
-                      nvvertexec.c \
-		      nvvertparse.c \
+                      nvvertparse.c \
+                      prog_debug.c \
+                      prog_execute.c \
+                      prog_instruction.c \
+                      prog_parameter.c \
+                      prog_print.c \
                       program.c \
-                      shaderobjects.c \
-		      shaderobjects_3dlabs.c
+                      programopt.c \
+                      prog_statevars.c \
+                      shader_api.c
diff --git a/GL/mesa/shader/grammar/Makefile.am b/GL/mesa/shader/grammar/Makefile.am
index 0974d5b..332c8e9 100644
--- a/GL/mesa/shader/grammar/Makefile.am
+++ b/GL/mesa/shader/grammar/Makefile.am
@@ -7,7 +7,6 @@ AM_CFLAGS = \
 
 INCLUDES = -I@MESA_SOURCE@/include \
            -I../../X \
-           -I../../array_cache \
            -I../../glapi \
            -I../../main \
            -I../../math \
diff --git a/GL/mesa/shader/slang/Makefile.am b/GL/mesa/shader/slang/Makefile.am
index 8f2636e..71498ee 100644
--- a/GL/mesa/shader/slang/Makefile.am
+++ b/GL/mesa/shader/slang/Makefile.am
@@ -8,7 +8,6 @@ AM_CFLAGS = \
 INCLUDES = -I@MESA_SOURCE@/include \
            -I../grammar \
            -I../../X \
-           -I../../array_cache \
            -I../../glapi \
            -I../../main \
            -I../../math \
@@ -19,23 +18,24 @@ INCLUDES = -I@MESA_SOURCE@/include \
            -I../.. \
            -I$(top_srcdir)/hw/xfree86/os-support
 
-nodist_libslang_la_SOURCES = slang_analyse.c \
-		      slang_assemble_assignment.c \
-		      slang_assemble.c \
-		      slang_assemble_conditional.c \
-		      slang_assemble_constructor.c \
-		      slang_assemble_typeinfo.c \
+nodist_libslang_la_SOURCES = slang_builtin.c \
+		      slang_codegen.c \
 		      slang_compile.c \
 		      slang_compile_function.c \
 		      slang_compile_operation.c \
 		      slang_compile_struct.c \
 		      slang_compile_variable.c \
-		      slang_execute.c \
-		      slang_execute_x86.c \
-		      slang_export.c \
-		      slang_library_texsample.c \
+		      slang_emit.c \
+		      slang_ir.c \
+		      slang_label.c \
 		      slang_library_noise.c \
 		      slang_link.c \
+		      slang_log.c \
+		      slang_mem.c \
 		      slang_preprocess.c \
+		      slang_print.c \
+		      slang_simplify.c \
 		      slang_storage.c \
-		      slang_utility.c
+		      slang_typeinfo.c \
+		      slang_utility.c \
+		      slang_vartable.c
diff --git a/GL/mesa/swrast/Makefile.am b/GL/mesa/swrast/Makefile.am
index d972af6..bffb1e7 100644
--- a/GL/mesa/swrast/Makefile.am
+++ b/GL/mesa/swrast/Makefile.am
@@ -7,7 +7,6 @@ AM_CFLAGS = \
 
 INCLUDES = -I@MESA_SOURCE@/include \
            -I../X \
-           -I../array_cache \
            -I../glapi \
            -I../main \
            -I../math \
@@ -24,7 +23,6 @@ nodist_libswrast_la_SOURCES = s_aaline.c \
                       s_aatriangle.c \
                       s_accum.c \
                       s_alpha.c \
-                      s_arbshader.c \
                       s_atifragshader.c \
                       s_bitmap.c \
                       s_blend.c \
@@ -36,11 +34,11 @@ nodist_libswrast_la_SOURCES = s_aaline.c \
                       s_drawpix.c \
                       s_feedback.c \
                       s_fog.c \
+		      s_fragprog.c \
                       s_imaging.c \
                       s_lines.c \
                       s_logic.c \
                       s_masking.c \
-                      s_nvfragprog.c \
                       s_points.c \
                       s_readpix.c \
                       s_span.c \
diff --git a/GL/mesa/swrast_setup/Makefile.am b/GL/mesa/swrast_setup/Makefile.am
index 8d70408..1f3c031 100644
--- a/GL/mesa/swrast_setup/Makefile.am
+++ b/GL/mesa/swrast_setup/Makefile.am
@@ -7,7 +7,6 @@ AM_CFLAGS = \
 
 INCLUDES = -I@MESA_SOURCE@/include \
            -I../X \
-           -I../array_cache \
            -I../glapi \
            -I../main \
            -I../math \
diff --git a/GL/mesa/tnl/Makefile.am b/GL/mesa/tnl/Makefile.am
index 717e6fd..b3c8206 100644
--- a/GL/mesa/tnl/Makefile.am
+++ b/GL/mesa/tnl/Makefile.am
@@ -7,7 +7,6 @@ AM_CFLAGS = \
 
 INCLUDES = -I@MESA_SOURCE@/include \
            -I../X \
-           -I../array_cache \
            -I../glapi \
            -I../main \
            -I../math \
@@ -19,16 +18,9 @@ INCLUDES = -I@MESA_SOURCE@/include \
            -I.. \
            -I$(top_srcdir)/hw/xfree86/os-support
 
-nodist_libtnl_la_SOURCES = t_array_api.c \
-                      t_array_import.c \
-                      t_context.c \
+nodist_libtnl_la_SOURCES = t_context.c \
+                      t_draw.c \
                       t_pipeline.c \
-                      t_save_api.c \
-                      t_save_loopback.c \
-                      t_save_playback.c \
-                      t_vb_arbprogram.c \
-                      t_vb_arbprogram_sse.c \
-                      t_vb_arbshader.c \
                       t_vb_cull.c \
                       t_vb_fog.c \
                       t_vb_light.c \
@@ -42,9 +34,4 @@ nodist_libtnl_la_SOURCES = t_array_api.c \
                       t_vertex.c \
                       t_vertex_generic.c \
                       t_vertex_sse.c \
-                      t_vp_build.c \
-                      t_vtx_api.c \
-                      t_vtx_eval.c \
-                      t_vtx_exec.c \
-                      t_vtx_generic.c \
-                      t_vtx_x86.c
+                      t_vp_build.c
diff --git a/GL/mesa/vbo/Makefile.am b/GL/mesa/vbo/Makefile.am
new file mode 100644
index 0000000..9943f2a
--- /dev/null
+++ b/GL/mesa/vbo/Makefile.am
@@ -0,0 +1,35 @@
+noinst_LTLIBRARIES = libvbo.la
+
+AM_CFLAGS = \
+	$(DIX_CFLAGS) \
+	-DXFree86Server \
+	@GLX_DEFINES@
+
+INCLUDES = -I@MESA_SOURCE@/include \
+           -I../X \
+           -I../glapi \
+           -I../main \
+           -I../math \
+           -I../shader \
+           -I../shader/slang \
+	   -I../shader/slang \
+           -I../swrast \
+           -I../swrast_setup \
+           -I../tnl \
+           -I.. \
+           -I$(top_srcdir)/hw/xfree86/os-support
+
+nodist_libvbo_la_SOURCES = vbo_context.c \
+			vbo_exec_api.c \
+			vbo_exec_array.c \
+			vbo_exec.c \
+			vbo_exec_draw.c \
+			vbo_exec_eval.c \
+			vbo_rebase.c \
+			vbo_save_api.c \
+			vbo_save.c \
+			vbo_save_draw.c \
+			vbo_save_loopback.c \
+			vbo_split.c \
+			vbo_split_copy.c \
+			vbo_split_inplace.c
diff --git a/GL/symlink-mesa.sh b/GL/symlink-mesa.sh
index c14c683..0cfe1c9 100755
--- a/GL/symlink-mesa.sh
+++ b/GL/symlink-mesa.sh
@@ -85,15 +85,6 @@ symlink_mesa_math() {
     done
 }
 
-symlink_mesa_ac() {
-    src_dir src/mesa/array_cache
-    dst_dir mesa/array_cache
-
-    for src in $REAL_SRC_DIR/*.c $REAL_SRC_DIR/*.h; do
-        action `basename $src`
-    done
-}
-
 symlink_mesa_swrast() {
     src_dir src/mesa/swrast
     dst_dir mesa/swrast
@@ -157,6 +148,15 @@ symlink_mesa_shader_slang_library() {
     done
 }        
 
+symlink_mesa_vbo() {
+    src_dir src/mesa/vbo
+    dst_dir mesa/vbo
+
+    for src in $REAL_SRC_DIR/*.c $REAL_SRC_DIR/*.h; do
+        action `basename $src`
+    done
+}
+
 symlink_mesa_x() {
     src_dir src/mesa/drivers/x11
     dst_dir mesa/X
@@ -168,6 +168,8 @@ symlink_mesa_x() {
     action xm_api.c
     action xm_buffer.c
     action xm_dd.c
+    action xm_image.c
+    action xm_image.h
     action xm_line.c
     action xm_span.c
     action xm_tri.c
@@ -203,7 +205,6 @@ symlink_mesa_x8664() {
 symlink_mesa() {
     symlink_mesa_main
     symlink_mesa_math
-    symlink_mesa_ac
     symlink_mesa_swrast
     symlink_mesa_ss
     symlink_mesa_tnl
@@ -215,6 +216,7 @@ symlink_mesa() {
     symlink_mesa_glapi
     symlink_mesa_ppc
     symlink_mesa_sparc
+    symlink_mesa_vbo
     symlink_mesa_x86
     symlink_mesa_x8664
 }
@@ -225,9 +227,6 @@ symlink_glx() {
     dst_dir glx
 
     action indirect_size.h
-
-    src_dir src/mesa/drivers/dri/common
-
     action glcontextmodes.c
     action glcontextmodes.h
 
@@ -289,9 +288,9 @@ action() {
 }
 
 usage() {
-    echo symlink.sh src-dir dst-dir
-    echo src-dir: the xc directory of the monolithic source tree
-    echo dst-dir: the modular source tree containing proto, app, lib, ...
+    echo symlink-mesa.sh src-dir dst-dir
+    echo src-dir: the Mesa source directory
+    echo dst-dir: the GL subdirectory of the Xserver modular tree
 }
 
 # Check commandline args
--- xorg-server-1.3.0.0.orig/configure.ac	2007-08-11 11:35:59.000000000 +1000
+++ xorg-server-1.3.0.0/configure.ac	2007-08-11 13:09:14.000000000 +1000
@@ -1694,7 +1694,6 @@
 GL/Makefile
 GL/glx/Makefile
 GL/mesa/Makefile
-GL/mesa/array_cache/Makefile
 GL/mesa/glapi/Makefile
 GL/mesa/main/Makefile
 GL/mesa/math/Makefile
@@ -1704,6 +1703,7 @@
 GL/mesa/swrast/Makefile
 GL/mesa/swrast_setup/Makefile
 GL/mesa/tnl/Makefile
+GL/mesa/vbo/Makefile
 GL/mesa/X/Makefile
 include/Makefile
 afb/Makefile
diff --git a/hw/xfree86/dri/Makefile.am b/hw/xfree86/dri/Makefile.am
index 4def387..68f1eae 100644
--- a/hw/xfree86/dri/Makefile.am
+++ b/hw/xfree86/dri/Makefile.am
@@ -7,7 +7,7 @@ libdri_la_CFLAGS = -I$(top_srcdir)/hw/xfree86/common \
                    -I$(top_builddir)/GL/include \
 		   -I@MESA_SOURCE@/include \
                    -DHAVE_XORG_CONFIG_H \
-                   @DRIPROTO_CFLAGS@ \
+                   @DIX_CFLAGS@ @DRIPROTO_CFLAGS@ \
                    @LIBDRM_CFLAGS@ \
                    @GL_CFLAGS@
 libdri_la_LDFLAGS = -module -avoid-version @LIBDRM_LIBS@
diff --git a/hw/xfree86/dri/dri.c b/hw/xfree86/dri/dri.c
index 3b0d4db..80e07c5 100644
--- a/hw/xfree86/dri/dri.c
+++ b/hw/xfree86/dri/dri.c
@@ -43,6 +43,7 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include <string.h>
 #include <stdio.h>
 #include <sys/ioctl.h>
+#include <errno.h>
 
 #define NEED_REPLIES
 #define NEED_EVENTS
@@ -71,10 +72,13 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "mipointer.h"
 #include "xf86_OSproc.h"
 
+#define PCI_BUS_NO_DOMAIN(bus) ((bus) & 0xffu)
+
 #if !defined(PANORAMIX)
 extern Bool noPanoramiXExtension;
 #endif
 
+static int DRIEntPrivIndex = -1;
 static int DRIScreenPrivIndex = -1;
 static int DRIWindowPrivIndex = -1;
 static unsigned long DRIGeneration = 0;
@@ -110,24 +114,205 @@ DRIDrvMsg(int scrnIndex, MessageType type, const char *format, ...)
 }
 
 
+static void
+DRIOpenDRMCleanup(DRIEntPrivPtr pDRIEntPriv)
+{
+    if (pDRIEntPriv->pLSAREA != NULL) {
+	drmUnmap(pDRIEntPriv->pLSAREA, pDRIEntPriv->sAreaSize);
+	pDRIEntPriv->pLSAREA = NULL;
+    }
+    if (pDRIEntPriv->hLSAREA != 0) {
+	drmRmMap(pDRIEntPriv->drmFD, pDRIEntPriv->hLSAREA);
+    }
+    if (pDRIEntPriv->drmFD >= 0) {
+	drmClose(pDRIEntPriv->drmFD);
+	pDRIEntPriv->drmFD = 0;
+    }
+}
+
+int
+DRIMasterFD(ScrnInfoPtr pScrn)
+{
+    return DRI_ENT_PRIV(pScrn)->drmFD;
+}
+
+void *
+DRIMasterSareaPointer(ScrnInfoPtr pScrn)
+{
+    return DRI_ENT_PRIV(pScrn)->pLSAREA;
+}
+
+drm_handle_t
+DRIMasterSareaHandle(ScrnInfoPtr pScrn)
+{
+    return DRI_ENT_PRIV(pScrn)->hLSAREA;
+}
+
+
+Bool
+DRIOpenDRMMaster(ScrnInfoPtr pScrn,
+		 unsigned long sAreaSize,
+		 const char *busID,
+		 const char *drmDriverName)
+{
+    drmSetVersion saveSv, sv;
+    Bool drmWasAvailable;
+    DRIEntPrivPtr pDRIEntPriv;
+    DRIEntPrivRec tmp;
+    drmVersionPtr drmlibv;
+    int drmlibmajor, drmlibminor;
+    const char *openBusID;
+    int count;
+    int err;
+
+    if (DRIEntPrivIndex == -1)
+	DRIEntPrivIndex = xf86AllocateEntityPrivateIndex();
+
+    pDRIEntPriv = DRI_ENT_PRIV(pScrn);
+
+    if (pDRIEntPriv && pDRIEntPriv->drmFD != -1)
+	return TRUE;
+
+    drmWasAvailable = drmAvailable();
+
+    memset(&tmp, 0, sizeof(tmp));
+
+    /* Check the DRM lib version.
+     * drmGetLibVersion was not supported in version 1.0, so check for
+     * symbol first to avoid possible crash or hang.
+     */
+
+    drmlibmajor = 1;
+    drmlibminor = 0;
+    if (xf86LoaderCheckSymbol("drmGetLibVersion")) {
+	drmlibv = drmGetLibVersion(-1);
+	if (drmlibv != NULL) {
+	    drmlibmajor = drmlibv->version_major;
+	    drmlibminor = drmlibv->version_minor;
+	    drmFreeVersion(drmlibv);
+	}
+    }
+
+    /* Check if the libdrm can handle falling back to loading based on name
+     * if a busid string is passed.
+     */
+    openBusID = (drmlibmajor == 1 && drmlibminor >= 2) ? busID : NULL;
+
+    tmp.drmFD = -1;
+    sv.drm_di_major = 1;
+    sv.drm_di_minor = 1;
+    sv.drm_dd_major = -1;
+
+    saveSv = sv;
+    count = 10;
+    while (count--) {
+	tmp.drmFD = drmOpen(drmDriverName, openBusID);
+
+	if (tmp.drmFD < 0) {
+	    DRIDrvMsg(-1, X_ERROR, "[drm] drmOpen failed.\n");
+	    goto out_err;
+	}
+
+	err = drmSetInterfaceVersion(tmp.drmFD, &sv);
+
+	if (err != -EPERM)
+	    break;
+
+	sv = saveSv;
+	drmClose(tmp.drmFD);
+	tmp.drmFD = -1;
+	usleep(100000);
+    }
+
+    if (tmp.drmFD <= 0) {
+	DRIDrvMsg(-1, X_ERROR, "[drm] DRM was busy with another master.\n");
+	goto out_err;
+    }
+
+    if (!drmWasAvailable) {
+	DRIDrvMsg(-1, X_INFO,
+		  "[drm] loaded kernel module for \"%s\" driver.\n",
+		  drmDriverName);
+    }
+
+    if (err != 0) {
+	sv.drm_di_major = 1;
+	sv.drm_di_minor = 0;
+    }
+
+    DRIDrvMsg(-1, X_INFO, "[drm] DRM interface version %d.%d\n",
+	      sv.drm_di_major, sv.drm_di_minor);
+
+    if (sv.drm_di_major == 1 && sv.drm_di_minor >= 1)
+	err = 0;
+    else
+	err = drmSetBusid(tmp.drmFD, busID);
+
+    if (err) {
+	DRIDrvMsg(-1, X_ERROR, "[drm] Could not set DRM device bus ID.\n");
+	goto out_err;
+    }
+
+    /*
+     * Create a lock-containing sarea.
+     */
+
+    if (drmAddMap( tmp.drmFD, 0, sAreaSize, DRM_SHM,
+		   DRM_CONTAINS_LOCK, &tmp.hLSAREA) < 0) {
+        DRIDrvMsg(-1, X_INFO, "[drm] Could not create SAREA for DRM lock.\n");
+	tmp.hLSAREA = 0;
+	goto out_err;
+    }
+
+    if (drmMap( tmp.drmFD, tmp.hLSAREA, sAreaSize,
+		(drmAddressPtr)(&tmp.pLSAREA)) < 0) {
+        DRIDrvMsg(-1, X_INFO, "[drm] Mapping SAREA for DRM lock failed.\n");
+	tmp.pLSAREA = NULL;
+	goto out_err;
+    }
+
+    memset(tmp.pLSAREA, 0, sAreaSize);
+
+    /*
+     * Reserved contexts are handled by the first opened screen.
+     */
+
+    tmp.resOwner = NULL;
+
+    if (!pDRIEntPriv)
+	pDRIEntPriv = xnfcalloc(sizeof(*pDRIEntPriv), 1);
+
+    if (!pDRIEntPriv) {
+        DRIDrvMsg(-1, X_INFO, "[drm] Failed to allocate memory for "
+		  "DRM device.\n");
+	goto out_err;
+    }
+    *pDRIEntPriv = tmp;
+    xf86GetEntityPrivate((pScrn)->entityList[0],DRIEntPrivIndex)->ptr =
+	pDRIEntPriv;
+
+    DRIDrvMsg(-1, X_INFO, "[drm] DRM open master succeeded.\n");
+    return TRUE;
+
+  out_err:
+
+    DRIOpenDRMCleanup(&tmp);
+    return FALSE;
+}
+
+
 Bool
 DRIScreenInit(ScreenPtr pScreen, DRIInfoPtr pDRIInfo, int *pDRMFD)
 {
     DRIScreenPrivPtr    pDRIPriv;
     drm_context_t *       reserved;
     int                 reserved_count;
-    int                 i, fd, drmWasAvailable;
+    int                 i;
     Bool                xineramaInCore = FALSE;
-    int                 err = 0;
-    char                *openbusid;
-    drmVersionPtr       drmlibv;
-    int                 drmlibmajor, drmlibminor, drmdimajor, drmdiminor;
-
-    if (DRIGeneration != serverGeneration) {
-	if ((DRIScreenPrivIndex = AllocateScreenPrivateIndex()) < 0)
-	    return FALSE;
-	DRIGeneration = serverGeneration;
-    }
+    DRIEntPrivPtr       pDRIEntPriv;
+    ScrnInfoPtr         pScrn = xf86Screens[pScreen->myNum];
+    DRIContextFlags	flags    = 0;
+    DRIContextPrivPtr	pDRIContextPriv;
 
     /* If the DRI extension is disabled, do not initialize the DRI */
     if (noXFree86DRIExtension) {
@@ -151,59 +336,32 @@ DRIScreenInit(ScreenPtr pScreen, DRIInfoPtr pDRIInfo, int *pDRMFD)
 	}
     }
 
-    drmWasAvailable = drmAvailable();
-
-    /* Check the DRM lib version.
-     * drmGetLibVersion was not supported in version 1.0, so check for
-     * symbol first to avoid possible crash or hang.
-     */
-    drmlibmajor = 1;
-    drmlibminor = 0;
-    if (xf86LoaderCheckSymbol("drmGetLibVersion")) {
-	drmlibv = drmGetLibVersion(-1);
-	if (drmlibv != NULL) {
-	    drmlibmajor = drmlibv->version_major;
-	    drmlibminor = drmlibv->version_minor;
-	    drmFreeVersion(drmlibv);
-	}
-    }
-
-    /* Check if the libdrm can handle falling back to loading based on name
-     * if a busid string is passed.
-     */
-    if (drmlibmajor == 1 && drmlibminor >= 2)
-	openbusid = pDRIInfo->busIdString;
-    else
-	openbusid = NULL;
+    if (!DRIOpenDRMMaster(pScrn, pDRIInfo->SAREASize,
+			  pDRIInfo->busIdString,
+			  pDRIInfo->drmDriverName))
+	return FALSE;
 
-    /* Note that drmOpen will try to load the kernel module, if needed. */
-    fd = drmOpen(pDRIInfo->drmDriverName, openbusid);
-    if (fd < 0) {
-        /* failed to open DRM */
-        pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
-        DRIDrvMsg(pScreen->myNum, X_INFO,
-                  "[drm] drmOpen failed\n");
-        return FALSE;
-    }
+    pDRIEntPriv = DRI_ENT_PRIV(pScrn);
 
-    if (!drmWasAvailable) {
-       /* drmOpen loaded the kernel module, print a message to say so */
-       DRIDrvMsg(pScreen->myNum, X_INFO,
-                 "[drm] loaded kernel module for \"%s\" driver\n",
-                 pDRIInfo->drmDriverName);
+    if (DRIGeneration != serverGeneration) {
+	if ((DRIScreenPrivIndex = AllocateScreenPrivateIndex()) < 0)
+	    return FALSE;
+	DRIGeneration = serverGeneration;
     }
 
     pDRIPriv = (DRIScreenPrivPtr) xcalloc(1, sizeof(DRIScreenPrivRec));
     if (!pDRIPriv) {
         pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
+        DRIScreenPrivIndex = -1;
         return FALSE;
     }
 
     pScreen->devPrivates[DRIScreenPrivIndex].ptr = (pointer) pDRIPriv;
-    pDRIPriv->drmFD = fd;
+    pDRIPriv->drmFD = pDRIEntPriv->drmFD;
     pDRIPriv->directRenderingSupport = TRUE;
     pDRIPriv->pDriverInfo = pDRIInfo;
     pDRIPriv->nrWindows = 0;
+    pDRIPriv->nrWindowsVisible = 0;
     pDRIPriv->fullscreen = NULL;
 
     pDRIPriv->createDummyCtx     = pDRIInfo->createDummyCtx;
@@ -211,124 +369,99 @@ DRIScreenInit(ScreenPtr pScreen, DRIInfoPtr pDRIInfo, int *pDRMFD)
 
     pDRIPriv->grabbedDRILock = FALSE;
     pDRIPriv->drmSIGIOHandlerInstalled = FALSE;
+    *pDRMFD = pDRIPriv->drmFD;
 
-    if (drmlibmajor == 1 && drmlibminor >= 2) {
-	drmSetVersion sv;
-
-	/* Get the interface version, asking for 1.1. */
-	sv.drm_di_major = 1;
-	sv.drm_di_minor = 1;
-	sv.drm_dd_major = -1;
-	err = drmSetInterfaceVersion(pDRIPriv->drmFD, &sv);
-	if (err == 0) {
-	    drmdimajor = sv.drm_di_major;
-	    drmdiminor = sv.drm_di_minor;
-	} else {
-	    /* failure, so set it to 1.0.0. */
-	    drmdimajor = 1;
-	    drmdiminor = 0;
+    if (pDRIEntPriv->sAreaGrabbed || pDRIInfo->allocSarea) {
+
+	if (drmAddMap( pDRIPriv->drmFD,
+		       0,
+		       pDRIPriv->pDriverInfo->SAREASize,
+		       DRM_SHM,
+		       0,
+		       &pDRIPriv->hSAREA) < 0)
+	{
+	    pDRIPriv->directRenderingSupport = FALSE;
+	    pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
+	    drmClose(pDRIPriv->drmFD);
+	    DRIDrvMsg(pScreen->myNum, X_INFO,
+		      "[drm] drmAddMap failed\n");
+	    return FALSE;
 	}
-    }
-    else {
-	/* We can't check the DI DRM interface version, so set it to 1.0.0. */
-	drmdimajor = 1;
-	drmdiminor = 0;
-    }
-    DRIDrvMsg(pScreen->myNum, X_INFO,
-              "[drm] DRM interface version %d.%d\n", drmdimajor, drmdiminor);
-
-    /* If the interface minor number is 1.1, then we've opened a DRM device
-     * that already had the busid set through drmOpen.
-     */
-    if (drmdimajor == 1 && drmdiminor >= 1)
-	err = 0;
-    else
-	err = drmSetBusid(pDRIPriv->drmFD, pDRIPriv->pDriverInfo->busIdString);
-
-    if (err < 0) {
-	pDRIPriv->directRenderingSupport = FALSE;
-	pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
-	drmClose(pDRIPriv->drmFD);
-        DRIDrvMsg(pScreen->myNum, X_INFO,
-                  "[drm] drmSetBusid failed (%d, %s), %s\n",
-                  pDRIPriv->drmFD, pDRIPriv->pDriverInfo->busIdString, strerror(-err));
-	return FALSE;
+	DRIDrvMsg(pScreen->myNum, X_INFO,
+		  "[drm] added %d byte SAREA at %p\n",
+		  pDRIPriv->pDriverInfo->SAREASize, pDRIPriv->hSAREA);
+
+	/* Backwards compat. */
+	if (drmMap( pDRIPriv->drmFD,
+		    pDRIPriv->hSAREA,
+		    pDRIPriv->pDriverInfo->SAREASize,
+		    (drmAddressPtr)(&pDRIPriv->pSAREA)) < 0)
+	{
+	    pDRIPriv->directRenderingSupport = FALSE;
+	    pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
+	    drmClose(pDRIPriv->drmFD);
+	    DRIDrvMsg(pScreen->myNum, X_INFO,
+		      "[drm] drmMap failed\n");
+	    return FALSE;
+	}
+	DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] mapped SAREA %p to %p\n",
+		  pDRIPriv->hSAREA, pDRIPriv->pSAREA);
+	memset(pDRIPriv->pSAREA, 0, pDRIPriv->pDriverInfo->SAREASize);
+    } else {
+	DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] Using the DRM lock "
+		  "SAREA also for drawables.\n");
+	pDRIPriv->hSAREA = pDRIEntPriv->hLSAREA;
+	pDRIPriv->pSAREA = (XF86DRISAREAPtr) pDRIEntPriv->pLSAREA;
+	pDRIEntPriv->sAreaGrabbed = TRUE;
     }
 
-    *pDRMFD = pDRIPriv->drmFD;
-    DRIDrvMsg(pScreen->myNum, X_INFO,
-	      "[drm] created \"%s\" driver at busid \"%s\"\n",
-	      pDRIPriv->pDriverInfo->drmDriverName,
-	      pDRIPriv->pDriverInfo->busIdString);
-
-    if (drmAddMap( pDRIPriv->drmFD,
-		   0,
-		   pDRIPriv->pDriverInfo->SAREASize,
-		   DRM_SHM,
-		   DRM_CONTAINS_LOCK,
-		   &pDRIPriv->hSAREA) < 0)
-    {
-	pDRIPriv->directRenderingSupport = FALSE;
-	pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
-	drmClose(pDRIPriv->drmFD);
-        DRIDrvMsg(pScreen->myNum, X_INFO,
-                  "[drm] drmAddMap failed\n");
-	return FALSE;
-    }
-    DRIDrvMsg(pScreen->myNum, X_INFO,
-	      "[drm] added %d byte SAREA at %p\n",
-	      pDRIPriv->pDriverInfo->SAREASize, pDRIPriv->hSAREA);
+    pDRIPriv->hLSAREA = pDRIEntPriv->hLSAREA;
+    pDRIPriv->pLSAREA = pDRIEntPriv->pLSAREA;
 
-    if (drmMap( pDRIPriv->drmFD,
-		pDRIPriv->hSAREA,
-		pDRIPriv->pDriverInfo->SAREASize,
-		(drmAddressPtr)(&pDRIPriv->pSAREA)) < 0)
+    if (!pDRIPriv->pDriverInfo->dontMapFrameBuffer)
     {
-	pDRIPriv->directRenderingSupport = FALSE;
-	pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
-	drmClose(pDRIPriv->drmFD);
-        DRIDrvMsg(pScreen->myNum, X_INFO,
-                  "[drm] drmMap failed\n");
-	return FALSE;
+	if (drmAddMap( pDRIPriv->drmFD,
+		       (drm_handle_t)pDRIPriv->pDriverInfo->frameBufferPhysicalAddress,
+		       pDRIPriv->pDriverInfo->frameBufferSize,
+		       DRM_FRAME_BUFFER,
+		       0,
+		       &pDRIPriv->pDriverInfo->hFrameBuffer) < 0)
+	    {
+		pDRIPriv->directRenderingSupport = FALSE;
+		pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
+		drmUnmap(pDRIPriv->pSAREA, pDRIPriv->pDriverInfo->SAREASize);
+		drmClose(pDRIPriv->drmFD);
+		DRIDrvMsg(pScreen->myNum, X_INFO,
+			  "[drm] drmAddMap failed\n");
+		return FALSE;
+	    }
+	DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] framebuffer handle = %p\n",
+		  pDRIPriv->pDriverInfo->hFrameBuffer);
+    } else {
+	DRIDrvMsg(pScreen->myNum, X_INFO,
+		  "[drm] framebuffer mapped by ddx driver\n");
     }
-    memset(pDRIPriv->pSAREA, 0, pDRIPriv->pDriverInfo->SAREASize);
-    DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] mapped SAREA %p to %p\n",
-	      pDRIPriv->hSAREA, pDRIPriv->pSAREA);
 
-    if (drmAddMap( pDRIPriv->drmFD,
-		   (drm_handle_t)pDRIPriv->pDriverInfo->frameBufferPhysicalAddress,
-		   pDRIPriv->pDriverInfo->frameBufferSize,
-		   DRM_FRAME_BUFFER,
-		   0,
-		   &pDRIPriv->hFrameBuffer) < 0)
-    {
-	pDRIPriv->directRenderingSupport = FALSE;
-	pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
-	drmUnmap(pDRIPriv->pSAREA, pDRIPriv->pDriverInfo->SAREASize);
-	drmClose(pDRIPriv->drmFD);
-        DRIDrvMsg(pScreen->myNum, X_INFO,
-                  "[drm] drmAddMap failed\n");
-	return FALSE;
-    }
-    DRIDrvMsg(pScreen->myNum, X_INFO, "[drm] framebuffer handle = %p\n",
-	      pDRIPriv->hFrameBuffer);
+    if (pDRIEntPriv->resOwner == NULL) {
+	pDRIEntPriv->resOwner = pScreen;
 
-				/* Add tags for reserved contexts */
-    if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
-					      &reserved_count))) {
-	int  i;
-	void *tag;
+	/* Add tags for reserved contexts */
+	if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
+						  &reserved_count))) {
+	    int  i;
+	    void *tag;
 
-	for (i = 0; i < reserved_count; i++) {
-	    tag = DRICreateContextPrivFromHandle(pScreen,
-						 reserved[i],
-						 DRI_CONTEXT_RESERVED);
-	    drmAddContextTag(pDRIPriv->drmFD, reserved[i], tag);
+	    for (i = 0; i < reserved_count; i++) {
+		tag = DRICreateContextPrivFromHandle(pScreen,
+						     reserved[i],
+						     DRI_CONTEXT_RESERVED);
+		drmAddContextTag(pDRIPriv->drmFD, reserved[i], tag);
+	    }
+	    drmFreeReservedContextList(reserved);
+	    DRIDrvMsg(pScreen->myNum, X_INFO,
+		      "[drm] added %d reserved context%s for kernel\n",
+		      reserved_count, reserved_count > 1 ? "s" : "");
 	}
-	drmFreeReservedContextList(reserved);
-	DRIDrvMsg(pScreen->myNum, X_INFO,
-		  "[drm] added %d reserved context%s for kernel\n",
-		  reserved_count, reserved_count > 1 ? "s" : "");
     }
 
     /* validate max drawable table entry set by driver */
@@ -346,21 +479,22 @@ DRIScreenInit(ScreenPtr pScreen, DRIInfoPtr pDRIInfo, int *pDRMFD)
 	pDRIPriv->pSAREA->drawableTable[i].flags = 0;
     }
 
-    return TRUE;
-}
+    pDRIPriv->pLockRefCount = &pDRIEntPriv->lockRefCount;
+    pDRIPriv->pLockingContext = &pDRIEntPriv->lockingContext;
 
-Bool
-DRIFinishScreenInit(ScreenPtr pScreen)
-{
-    DRIScreenPrivPtr  pDRIPriv = DRI_SCREEN_PRIV(pScreen);
-    DRIInfoPtr        pDRIInfo = pDRIPriv->pDriverInfo;
-    DRIContextFlags   flags    = 0;
-    DRIContextPrivPtr pDRIContextPriv;
+    if (!pDRIEntPriv->keepFDOpen)
+	pDRIEntPriv->keepFDOpen = pDRIInfo->keepFDOpen;
+
+    pDRIEntPriv->refCount++;
 
-				/* Set up flags for DRICreateContextPriv */
+    /* Set up flags for DRICreateContextPriv */
     switch (pDRIInfo->driverSwapMethod) {
-    case DRI_KERNEL_SWAP:    flags = DRI_CONTEXT_2DONLY;    break;
-    case DRI_HIDE_X_CONTEXT: flags = DRI_CONTEXT_PRESERVED; break;
+    case DRI_KERNEL_SWAP:
+	flags = DRI_CONTEXT_2DONLY;
+	break;
+    case DRI_HIDE_X_CONTEXT:
+	flags = DRI_CONTEXT_PRESERVED;
+	break;
     }
 
     if (!(pDRIContextPriv = DRICreateContextPriv(pScreen,
@@ -447,6 +581,15 @@ DRIFinishScreenInit(ScreenPtr pScreen)
 	break;
     }
 
+    return TRUE;
+}
+
+Bool
+DRIFinishScreenInit(ScreenPtr pScreen)
+{
+    DRIScreenPrivPtr  pDRIPriv = DRI_SCREEN_PRIV(pScreen);
+    DRIInfoPtr        pDRIInfo = pDRIPriv->pDriverInfo;
+
     /* Wrap DRI support */
     if (pDRIInfo->wrap.ValidateTree) {
 	pDRIPriv->wrap.ValidateTree     = pScreen->ValidateTree;
@@ -460,6 +603,10 @@ DRIFinishScreenInit(ScreenPtr pScreen)
 	pDRIPriv->wrap.WindowExposures  = pScreen->WindowExposures;
 	pScreen->WindowExposures        = pDRIInfo->wrap.WindowExposures;
     }
+
+    pDRIPriv->DestroyWindow             = pScreen->DestroyWindow;
+    pScreen->DestroyWindow              = DRIDestroyWindow;
+
     if (pDRIInfo->wrap.CopyWindow) {
 	pDRIPriv->wrap.CopyWindow       = pScreen->CopyWindow;
 	pScreen->CopyWindow             = pDRIInfo->wrap.CopyWindow;
@@ -487,8 +634,11 @@ DRICloseScreen(ScreenPtr pScreen)
     DRIInfoPtr       pDRIInfo;
     drm_context_t *    reserved;
     int              reserved_count;
+    ScrnInfoPtr      pScrn = xf86Screens[pScreen->myNum];
+    DRIEntPrivPtr    pDRIEntPriv = DRI_ENT_PRIV(pScrn);
+    Bool closeMaster;
 
-    if (pDRIPriv && pDRIPriv->directRenderingSupport) {
+    if (pDRIPriv) {
 
         pDRIInfo = pDRIPriv->pDriverInfo;
 
@@ -506,6 +656,10 @@ DRICloseScreen(ScreenPtr pScreen)
 		pScreen->WindowExposures        = pDRIPriv->wrap.WindowExposures;
 		pDRIPriv->wrap.WindowExposures  = NULL;
 	    }
+	    if (pDRIPriv->DestroyWindow) {
+		pScreen->DestroyWindow          = pDRIPriv->DestroyWindow;
+		pDRIPriv->DestroyWindow         = NULL;
+	    }
 	    if (pDRIInfo->wrap.CopyWindow) {
 		pScreen->CopyWindow             = pDRIPriv->wrap.CopyWindow;
 		pDRIPriv->wrap.CopyWindow       = NULL;
@@ -539,41 +693,59 @@ DRICloseScreen(ScreenPtr pScreen)
 	}
 
 				/* Remove tags for reserved contexts */
-	if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
+	if (pDRIEntPriv->resOwner == pScreen) {
+	    pDRIEntPriv->resOwner = NULL;
+
+	    if ((reserved = drmGetReservedContextList(pDRIPriv->drmFD,
 						  &reserved_count))) {
-	    int  i;
+		int  i;
 
-	    for (i = 0; i < reserved_count; i++) {
-		DRIDestroyContextPriv(drmGetContextTag(pDRIPriv->drmFD,
-						       reserved[i]));
+		for (i = 0; i < reserved_count; i++) {
+		    DRIDestroyContextPriv(drmGetContextTag(pDRIPriv->drmFD,
+							   reserved[i]));
+		}
+		drmFreeReservedContextList(reserved);
+		DRIDrvMsg(pScreen->myNum, X_INFO,
+			  "[drm] removed %d reserved context%s for kernel\n",
+			  reserved_count, reserved_count > 1 ? "s" : "");
 	    }
-	    drmFreeReservedContextList(reserved);
-	    DRIDrvMsg(pScreen->myNum, X_INFO,
-		      "[drm] removed %d reserved context%s for kernel\n",
-		      reserved_count, reserved_count > 1 ? "s" : "");
 	}
 
 	/* Make sure signals get unblocked etc. */
 	drmUnlock(pDRIPriv->drmFD, pDRIPriv->myContext);
-	pDRIPriv->lockRefCount = 0;
-	DRIDrvMsg(pScreen->myNum, X_INFO,
-		  "[drm] unmapping %d bytes of SAREA %p at %p\n",
-		  pDRIInfo->SAREASize,
-		  pDRIPriv->hSAREA,
-		  pDRIPriv->pSAREA);
-	if (drmUnmap(pDRIPriv->pSAREA, pDRIInfo->SAREASize)) {
-	    DRIDrvMsg(pScreen->myNum, X_ERROR,
-		      "[drm] unable to unmap %d bytes"
-		      " of SAREA %p at %p\n",
+	pDRIPriv->pLockRefCount = NULL;
+	closeMaster = (--pDRIEntPriv->refCount == 0) &&
+	    !pDRIEntPriv->keepFDOpen;
+	if (closeMaster || pDRIPriv->hSAREA != pDRIEntPriv->hLSAREA) {
+	    DRIDrvMsg(pScreen->myNum, X_INFO,
+		      "[drm] unmapping %d bytes of SAREA %p at %p\n",
 		      pDRIInfo->SAREASize,
 		      pDRIPriv->hSAREA,
 		      pDRIPriv->pSAREA);
+	    if (drmUnmap(pDRIPriv->pSAREA, pDRIInfo->SAREASize)) {
+		DRIDrvMsg(pScreen->myNum, X_ERROR,
+			  "[drm] unable to unmap %d bytes"
+			  " of SAREA %p at %p\n",
+			  pDRIInfo->SAREASize,
+			  pDRIPriv->hSAREA,
+			  pDRIPriv->pSAREA);
+	    }
+	} else {
+	    pDRIEntPriv->sAreaGrabbed = FALSE;
 	}
 
-	drmClose(pDRIPriv->drmFD);
+	if (closeMaster || (pDRIEntPriv->drmFD != pDRIPriv->drmFD)) {
+	    drmClose(pDRIPriv->drmFD);
+	    if (pDRIEntPriv->drmFD == pDRIPriv->drmFD) {
+		DRIDrvMsg(pScreen->myNum, X_INFO,
+			  "[drm] Closed DRM master.\n");
+		pDRIEntPriv->drmFD = -1;
+	    }
+	}
 
 	xfree(pDRIPriv);
 	pScreen->devPrivates[DRIScreenPrivIndex].ptr = NULL;
+	DRIScreenPrivIndex = -1;
     }
 }
 
@@ -1006,9 +1178,96 @@ DRITransitionTo2d(ScreenPtr pScreen)
 }
 
 
+static int
+DRIDCNTreeTraversal(WindowPtr pWin, pointer data)
+{
+    DRIDrawablePrivPtr pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
+
+    if (pDRIDrawablePriv) {
+	ScreenPtr pScreen = pWin->drawable.pScreen;
+	DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
+
+	if (REGION_NUM_RECTS(&pWin->clipList) > 0) {
+	    WindowPtr *pDRIWindows = (WindowPtr*)data;
+	    int i = 0;
+
+	    while (pDRIWindows[i])
+		i++;
+
+	    pDRIWindows[i] = pWin;
+
+	    pDRIPriv->nrWalked++;
+	}
+
+	if (pDRIPriv->nrWindows == pDRIPriv->nrWalked)
+	    return WT_STOPWALKING;
+    }
+
+    return WT_WALKCHILDREN;
+}
+
+static void
+DRIDriverClipNotify(ScreenPtr pScreen)
+{
+    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
+
+    if (pDRIPriv->pDriverInfo->ClipNotify) {
+	WindowPtr *pDRIWindows = xcalloc(sizeof(WindowPtr), pDRIPriv->nrWindows);
+	DRIInfoPtr pDRIInfo = pDRIPriv->pDriverInfo;
+
+	if (pDRIPriv->nrWindows > 0) {
+	    pDRIPriv->nrWalked = 0;
+	    TraverseTree(WindowTable[pScreen->myNum], DRIDCNTreeTraversal,
+			 (pointer)pDRIWindows);
+	}
+
+	pDRIInfo->ClipNotify(pScreen, pDRIWindows, pDRIPriv->nrWindows);
+
+	xfree(pDRIWindows);
+    }
+}
+
+static void
+DRIIncreaseNumberVisible(ScreenPtr pScreen)
+{
+    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
+
+    switch (++pDRIPriv->nrWindowsVisible) {
+    case 1:
+	DRITransitionTo3d( pScreen );
+	break;
+    case 2:
+	DRITransitionToSharedBuffers( pScreen );
+	break;
+    default:
+	break;
+    }
+
+    DRIDriverClipNotify(pScreen);
+}
+
+static void
+DRIDecreaseNumberVisible(ScreenPtr pScreen)
+{
+    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
+
+    switch (--pDRIPriv->nrWindowsVisible) {
+    case 0:
+	DRITransitionTo2d( pScreen );
+	break;
+    case 1:
+	DRITransitionToPrivateBuffers( pScreen );
+	break;
+    default:
+	break;
+    }
+
+    DRIDriverClipNotify(pScreen);
+}
+
 Bool
-DRICreateDrawable(ScreenPtr pScreen, Drawable id,
-                  DrawablePtr pDrawable, drm_drawable_t * hHWDrawable)
+DRICreateDrawable(ScreenPtr pScreen, ClientPtr client, DrawablePtr pDrawable,
+		  drm_drawable_t * hHWDrawable)
 {
     DRIScreenPrivPtr	pDRIPriv = DRI_SCREEN_PRIV(pScreen);
     DRIDrawablePrivPtr	pDRIDrawablePriv;
@@ -1018,6 +1277,10 @@ DRICreateDrawable(ScreenPtr pScreen, Drawable id,
 	pWin = (WindowPtr)pDrawable;
 	if ((pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin))) {
 	    pDRIDrawablePriv->refCount++;
+
+	    if (!pDRIDrawablePriv->hwDrawable) {
+		drmCreateDrawable(pDRIPriv->drmFD, &pDRIDrawablePriv->hwDrawable);
+	    }
 	}
 	else {
 	    /* allocate a DRI Window Private record */
@@ -1026,34 +1289,39 @@ DRICreateDrawable(ScreenPtr pScreen, Drawable id,
 	    }
 
 	    /* Only create a drm_drawable_t once */
-	    if (drmCreateDrawable(pDRIPriv->drmFD, hHWDrawable)) {
+	    if (drmCreateDrawable(pDRIPriv->drmFD,
+				  &pDRIDrawablePriv->hwDrawable)) {
 		xfree(pDRIDrawablePriv);
 		return FALSE;
 	    }
 
 	    /* add it to the list of DRI drawables for this screen */
-	    pDRIDrawablePriv->hwDrawable = *hHWDrawable;
 	    pDRIDrawablePriv->pScreen = pScreen;
 	    pDRIDrawablePriv->refCount = 1;
 	    pDRIDrawablePriv->drawableIndex = -1;
+	    pDRIDrawablePriv->nrects = REGION_NUM_RECTS(&pWin->clipList);
 
 	    /* save private off of preallocated index */
 	    pWin->devPrivates[DRIWindowPrivIndex].ptr =
 						(pointer)pDRIDrawablePriv;
 
-	    switch (++pDRIPriv->nrWindows) {
-	    case 1:
-	       DRITransitionTo3d( pScreen );
-	       break;
-	    case 2:
-	       DRITransitionToSharedBuffers( pScreen );
-	       break;
-	    default:
-	       break;
-	    }
+	    pDRIPriv->nrWindows++;
+
+	    if (pDRIDrawablePriv->nrects)
+		DRIIncreaseNumberVisible(pScreen);
+	}
 
-	    /* track this in case this window is destroyed */
-	    AddResource(id, DRIDrawablePrivResType, (pointer)pWin);
+	/* track this in case the client dies */
+	AddResource(FakeClientID(client->index), DRIDrawablePrivResType,
+		    (pointer)pDrawable->id);
+
+	if (pDRIDrawablePriv->hwDrawable) {
+	    drmUpdateDrawableInfo(pDRIPriv->drmFD,
+				  pDRIDrawablePriv->hwDrawable,
+				  DRM_DRAWABLE_CLIPRECTS,
+				  REGION_NUM_RECTS(&pWin->clipList),
+				  REGION_RECTS(&pWin->clipList));
+	    *hHWDrawable = pDRIDrawablePriv->hwDrawable;
 	}
     }
     else { /* pixmap (or for GLX 1.3, a PBuffer) */
@@ -1064,21 +1332,59 @@ DRICreateDrawable(ScreenPtr pScreen, Drawable id,
     return TRUE;
 }
 
-Bool
-DRIDestroyDrawable(ScreenPtr pScreen, Drawable id, DrawablePtr pDrawable)
+static void
+DRIDrawablePrivDestroy(WindowPtr pWin)
 {
-    DRIDrawablePrivPtr	pDRIDrawablePriv;
-    WindowPtr		pWin;
+    DRIDrawablePrivPtr pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
+    ScreenPtr pScreen;
+    DRIScreenPrivPtr pDRIPriv;
+
+    if (!pDRIDrawablePriv)
+	return;
+
+    pScreen = pWin->drawable.pScreen;
+    pDRIPriv = DRI_SCREEN_PRIV(pScreen);
+
+    if (pDRIDrawablePriv->drawableIndex != -1) {
+	/* bump stamp to force outstanding 3D requests to resync */
+	pDRIPriv->pSAREA->drawableTable[pDRIDrawablePriv->drawableIndex].stamp
+	    = DRIDrawableValidationStamp++;
+
+	/* release drawable table entry */
+	pDRIPriv->DRIDrawables[pDRIDrawablePriv->drawableIndex] = NULL;
+    }
+
+    pDRIPriv->nrWindows--;
 
+    if (pDRIDrawablePriv->nrects)
+	DRIDecreaseNumberVisible(pScreen);
 
+    drmDestroyDrawable(pDRIPriv->drmFD, pDRIDrawablePriv->hwDrawable);
+
+    xfree(pDRIDrawablePriv);
+    pWin->devPrivates[DRIWindowPrivIndex].ptr = NULL;
+}
+
+static Bool
+DRIDestroyDrawableCB(pointer value, XID id, pointer data)
+{
+    if (value == data) {
+	/* This calls back DRIDrawablePrivDelete which frees private area */
+	FreeResourceByType(id, DRIDrawablePrivResType, FALSE);
+
+	return TRUE;
+    }
+
+    return FALSE;
+}
+
+Bool
+DRIDestroyDrawable(ScreenPtr pScreen, ClientPtr client, DrawablePtr pDrawable)
+{
     if (pDrawable->type == DRAWABLE_WINDOW) {
-	pWin = (WindowPtr)pDrawable;
-	pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
-	pDRIDrawablePriv->refCount--;
-	if (pDRIDrawablePriv->refCount <= 0) {
-	    /* This calls back DRIDrawablePrivDelete which frees private area */
-	    FreeResourceByType(id, DRIDrawablePrivResType, FALSE);
-	}
+	LookupClientResourceComplex(client, DRIDrawablePrivResType,
+				    DRIDestroyDrawableCB,
+				    (pointer)pDrawable->id);
     }
     else { /* pixmap (or for GLX 1.3, a PBuffer) */
 	/* NOT_DONE */
@@ -1091,48 +1397,26 @@ DRIDestroyDrawable(ScreenPtr pScreen, Drawable id, DrawablePtr pDrawable)
 Bool
 DRIDrawablePrivDelete(pointer pResource, XID id)
 {
-    DrawablePtr		pDrawable = (DrawablePtr)pResource;
-    DRIScreenPrivPtr	pDRIPriv = DRI_SCREEN_PRIV(pDrawable->pScreen);
-    DRIDrawablePrivPtr	pDRIDrawablePriv;
-    WindowPtr		pWin;
+    WindowPtr pWin;
 
-    if (pDrawable->type == DRAWABLE_WINDOW) {
-	pWin = (WindowPtr)pDrawable;
-	pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
-
-	if (pDRIDrawablePriv->drawableIndex != -1) {
-	    /* bump stamp to force outstanding 3D requests to resync */
-	    pDRIPriv->pSAREA->drawableTable[pDRIDrawablePriv->drawableIndex].stamp
-		= DRIDrawableValidationStamp++;
+    id = (XID)pResource;
+    pWin = LookupIDByType(id, RT_WINDOW);
 
-	    /* release drawable table entry */
-	    pDRIPriv->DRIDrawables[pDRIDrawablePriv->drawableIndex] = NULL;
-	}
+    if (pWin) {
+	DRIDrawablePrivPtr pDRIDrwPriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin);
 
-	if (drmDestroyDrawable(pDRIPriv->drmFD,
-			       pDRIDrawablePriv->hwDrawable)) {
+	if (!pDRIDrwPriv)
 	    return FALSE;
-	}
-	xfree(pDRIDrawablePriv);
-	pWin->devPrivates[DRIWindowPrivIndex].ptr = NULL;
-
-	switch (--pDRIPriv->nrWindows) {
-	case 0:
-	   DRITransitionTo2d( pDrawable->pScreen );
-	   break;
-	case 1:
-	   DRITransitionToPrivateBuffers( pDrawable->pScreen );
-	   break;
-	default:
-	   break;
-	}
+
+	if (--pDRIDrwPriv->refCount == 0)
+	    DRIDrawablePrivDestroy(pWin);
+
+	return TRUE;
     }
     else { /* pixmap (or for GLX 1.3, a PBuffer) */
 	/* NOT_DONE */
 	return FALSE;
     }
-
-    return TRUE;
 }
 
 Bool
@@ -1263,7 +1547,7 @@ DRIGetDrawableInfo(ScreenPtr pScreen,
 	    *backX = *X;
 	    *backY = *Y;
 
-	    if (pDRIPriv->nrWindows == 1 && *numClipRects) {
+	    if (pDRIPriv->nrWindowsVisible == 1 && *numClipRects) {
 	       /* Use a single cliprect. */
 
 	       int x0 = *X;
@@ -1276,13 +1560,18 @@ DRIGetDrawableInfo(ScreenPtr pScreen,
 	       if (x1 > pScreen->width) x1 = pScreen->width;
 	       if (y1 > pScreen->height) y1 = pScreen->height;
 
-	       pDRIPriv->private_buffer_rect.x1 = x0;
-	       pDRIPriv->private_buffer_rect.y1 = y0;
-	       pDRIPriv->private_buffer_rect.x2 = x1;
-	       pDRIPriv->private_buffer_rect.y2 = y1;
-
-	       *numBackClipRects = 1;
-	       *pBackClipRects = &(pDRIPriv->private_buffer_rect);
+	       if (y0 >= y1 || x0 >= x1) {
+		    *numBackClipRects = 0;
+		    *pBackClipRects = NULL;
+	       } else {
+		    pDRIPriv->private_buffer_rect.x1 = x0;
+		    pDRIPriv->private_buffer_rect.y1 = y0;
+		    pDRIPriv->private_buffer_rect.x2 = x1;
+		    pDRIPriv->private_buffer_rect.y2 = y1;
+
+		    *numBackClipRects = 1;
+		    *pBackClipRects = &(pDRIPriv->private_buffer_rect);
+	       }
 	    } else {
 	       /* Use the frontbuffer cliprects for back buffers.  */
 	       *numBackClipRects = 0;
@@ -1313,7 +1602,7 @@ DRIGetDeviceInfo(ScreenPtr pScreen,
 {
     DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
 
-    *hFrameBuffer = pDRIPriv->hFrameBuffer;
+    *hFrameBuffer = pDRIPriv->pDriverInfo->hFrameBuffer;
     *fbOrigin = 0;
     *fbSize = pDRIPriv->pDriverInfo->frameBufferSize;
     *fbStride = pDRIPriv->pDriverInfo->frameBufferStride;
@@ -1621,16 +1910,45 @@ DRITreeTraversal(WindowPtr pWin, pointer data)
     if(pDRIDrawablePriv) {
         ScreenPtr pScreen = pWin->drawable.pScreen;
         DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
-        RegionPtr reg = (RegionPtr)data;
 
-        REGION_UNION(pScreen, reg, reg, &(pWin->clipList));
+	if(REGION_NUM_RECTS(&(pWin->clipList)) > 0) {
+	   RegionPtr reg = (RegionPtr)data;
 
-        if(pDRIPriv->nrWindows == 1)
+	   REGION_UNION(pScreen, reg, reg, &(pWin->clipList));
+	   pDRIPriv->nrWalked++;
+	}
+
+	if(pDRIPriv->nrWindows == pDRIPriv->nrWalked)
 	   return WT_STOPWALKING;
     }
     return WT_WALKCHILDREN;
 }
 
+Bool
+DRIDestroyWindow(WindowPtr pWin)
+{
+    ScreenPtr pScreen = pWin->drawable.pScreen;
+    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
+    Bool retval = TRUE;
+
+    DRIDrawablePrivDestroy(pWin);
+
+    /* call lower wrapped functions */
+    if(pDRIPriv->DestroyWindow) {
+	/* unwrap */
+	pScreen->DestroyWindow = pDRIPriv->DestroyWindow;
+
+	/* call lower layers */
+	retval = (*pScreen->DestroyWindow)(pWin);
+
+	/* rewrap */
+	pDRIPriv->DestroyWindow = pScreen->DestroyWindow;
+	pScreen->DestroyWindow = DRIDestroyWindow;
+    }
+
+    return retval;
+}
+
 void
 DRICopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
 {
@@ -1639,10 +1957,11 @@ DRICopyWindow(WindowPtr pWin, DDXPointRec ptOldOrg, RegionPtr prgnSrc)
 
     if(!pDRIPriv) return;
 
-    if(pDRIPriv->nrWindows > 0) {
+    if(pDRIPriv->nrWindowsVisible > 0) {
        RegionRec reg;
 
        REGION_NULL(pScreen, &reg);
+       pDRIPriv->nrWalked = 0;
        TraverseTree(pWin, DRITreeTraversal, (pointer)(&reg));
 
        if(REGION_NOTEMPTY(pScreen, &reg)) {
@@ -1831,14 +2150,28 @@ DRIClipNotify(WindowPtr pWin, int dx, int dy)
     if(!pDRIPriv) return;
 
     if ((pDRIDrawablePriv = DRI_DRAWABLE_PRIV_FROM_WINDOW(pWin))) {
+        int nrects = REGION_NUM_RECTS(&pWin->clipList);
 
         if(!pDRIPriv->windowsTouched) {
             DRILockTree(pScreen);
             pDRIPriv->windowsTouched = TRUE;
         }
 
+	if (nrects && !pDRIDrawablePriv->nrects)
+	    DRIIncreaseNumberVisible(pScreen);
+	else if (!nrects && pDRIDrawablePriv->nrects)
+	    DRIDecreaseNumberVisible(pScreen);
+	else
+	    DRIDriverClipNotify(pScreen);
+
+	pDRIDrawablePriv->nrects = nrects;
+
 	pDRIPriv->pSAREA->drawableTable[pDRIDrawablePriv->drawableIndex].stamp
 	    = DRIDrawableValidationStamp++;
+
+	drmUpdateDrawableInfo(pDRIPriv->drmFD, pDRIDrawablePriv->hwDrawable,
+			      DRM_DRAWABLE_CLIPRECTS,
+			      nrects, REGION_RECTS(&pWin->clipList));
     }
 
     /* call lower wrapped functions */
@@ -1894,28 +2227,46 @@ void
 DRILock(ScreenPtr pScreen, int flags)
 {
     DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
-    if(!pDRIPriv) return;
 
-    if (!pDRIPriv->lockRefCount)
-        DRM_LOCK(pDRIPriv->drmFD, pDRIPriv->pSAREA, pDRIPriv->myContext, flags);
-    pDRIPriv->lockRefCount++;
+    if(!pDRIPriv || !pDRIPriv->pLockRefCount) return;
+
+    if (!*pDRIPriv->pLockRefCount) {
+        DRM_LOCK(pDRIPriv->drmFD, pDRIPriv->pLSAREA, pDRIPriv->myContext, flags);
+	*pDRIPriv->pLockingContext = pDRIPriv->myContext;
+    } else if (*pDRIPriv->pLockingContext != pDRIPriv->myContext) {
+	DRIDrvMsg(pScreen->myNum, X_ERROR,
+		  "[DRI] Locking deadlock.\n"
+		  "\tAlready locked with context %d,\n"
+		  "\ttrying to lock with context %d.\n",
+		  pDRIPriv->pLockingContext,
+		  pDRIPriv->myContext);
+    }
+    (*pDRIPriv->pLockRefCount)++;
 }
 
 void
 DRIUnlock(ScreenPtr pScreen)
 {
     DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
-    if(!pDRIPriv) return;
 
-    if (pDRIPriv->lockRefCount > 0) {
-        pDRIPriv->lockRefCount--;
-    }
-    else {
-        ErrorF("DRIUnlock called when not locked\n");
+    if(!pDRIPriv || !pDRIPriv->pLockRefCount) return;
+
+    if (*pDRIPriv->pLockRefCount > 0) {
+	if (pDRIPriv->myContext != *pDRIPriv->pLockingContext) {
+	    DRIDrvMsg(pScreen->myNum, X_ERROR,
+		      "[DRI] Unlocking inconsistency:\n"
+		      "\tContext %d trying to unlock lock held by context %d\n",
+		      pDRIPriv->pLockingContext,
+		      pDRIPriv->myContext);
+	}
+	(*pDRIPriv->pLockRefCount)--;
+    } else {
+        DRIDrvMsg(pScreen->myNum, X_ERROR,
+		  "DRIUnlock called when not locked.\n");
         return;
     }
-    if (!pDRIPriv->lockRefCount)
-        DRM_UNLOCK(pDRIPriv->drmFD, pDRIPriv->pSAREA, pDRIPriv->myContext);
+    if (! *pDRIPriv->pLockRefCount)
+        DRM_UNLOCK(pDRIPriv->drmFD, pDRIPriv->pLSAREA, pDRIPriv->myContext);
 }
 
 void *
@@ -1936,6 +2287,19 @@ DRIGetContext(ScreenPtr pScreen)
     return pDRIPriv->myContext;
 }
 
+void
+DRIGetTexOffsetFuncs(ScreenPtr pScreen,
+		     DRITexOffsetStartProcPtr *texOffsetStartFunc,
+		     DRITexOffsetFinishProcPtr *texOffsetFinishFunc)
+{
+    DRIScreenPrivPtr pDRIPriv = DRI_SCREEN_PRIV(pScreen);
+
+    if (!pDRIPriv) return;
+
+    *texOffsetStartFunc  = pDRIPriv->pDriverInfo->texOffsetStart;
+    *texOffsetFinishFunc = pDRIPriv->pDriverInfo->texOffsetFinish;
+}
+
 /* This lets get at the unwrapped functions so that they can correctly
  * call the lowerlevel functions, and choose whether they will be
  * called at every level of recursion (eg in validatetree).
@@ -2097,8 +2461,8 @@ DRICreatePCIBusID(pciVideoPtr PciInfo)
 
     tag = pciTag(PciInfo->bus, PciInfo->device, PciInfo->func);
     domain = xf86GetPciDomain(tag);
-    snprintf(busID, 20, "pci:%04x:%02x:%02x.%d", domain, PciInfo->bus,
-	PciInfo->device, PciInfo->func);
+    snprintf(busID, 20, "pci:%04x:%02x:%02x.%d", domain,
+	PCI_BUS_NO_DOMAIN(PciInfo->bus), PciInfo->device, PciInfo->func);
     return busID;
 }
 
diff --git a/hw/xfree86/dri/dri.h b/hw/xfree86/dri/dri.h
index dca0edd..98e8b75 100644
--- a/hw/xfree86/dri/dri.h
+++ b/hw/xfree86/dri/dri.h
@@ -107,9 +107,12 @@ typedef struct {
  */
 
 #define DRIINFO_MAJOR_VERSION   5
-#define DRIINFO_MINOR_VERSION   0
+#define DRIINFO_MINOR_VERSION   4
 #define DRIINFO_PATCH_VERSION   0
 
+typedef unsigned long long (*DRITexOffsetStartProcPtr)(PixmapPtr pPix);
+typedef void (*DRITexOffsetFinishProcPtr)(PixmapPtr pPix);
+
 typedef struct {
     /* driver call back functions
      *
@@ -173,9 +176,30 @@ typedef struct {
     /* New with DRI version 4.1.0 */
     void        (*TransitionSingleToMulti3D)(ScreenPtr pScreen);
     void        (*TransitionMultiToSingle3D)(ScreenPtr pScreen);
+
+    /* New with DRI version 5.1.0 */
+    void        (*ClipNotify)(ScreenPtr pScreen, WindowPtr *ppWin, int num);
+
+    /* New with DRI version 5.2.0 */
+    Bool                allocSarea;
+    Bool                keepFDOpen;
+
+    /* New with DRI version 5.3.0 */
+    DRITexOffsetStartProcPtr  texOffsetStart;
+    DRITexOffsetFinishProcPtr texOffsetFinish;
+
+    /* New with DRI version 5.4.0 */
+    int			dontMapFrameBuffer;
+    drm_handle_t   	hFrameBuffer; /* Handle to framebuffer, either
+				       * mapped by DDX driver or DRI */
+    
 } DRIInfoRec, *DRIInfoPtr;
 
 
+extern Bool DRIOpenDRMMaster(ScrnInfoPtr pScrn, unsigned long sAreaSize,
+			     const char *busID,
+			     const char *drmDriverName);
+
 extern Bool DRIScreenInit(ScreenPtr pScreen,
                           DRIInfoPtr pDRIInfo,
                           int *pDRMFD);
@@ -213,12 +237,12 @@ extern Bool DRIDestroyContext(ScreenPtr pScreen, XID context);
 extern Bool DRIContextPrivDelete(pointer pResource, XID id);
 
 extern Bool DRICreateDrawable(ScreenPtr pScreen,
-                              Drawable id,
+                              ClientPtr client,
                               DrawablePtr pDrawable,
                               drm_drawable_t * hHWDrawable);
 
 extern Bool DRIDestroyDrawable(ScreenPtr pScreen, 
-                               Drawable id,
+			       ClientPtr client,
                                DrawablePtr pDrawable);
 
 extern Bool DRIDrawablePrivDelete(pointer pResource,
@@ -281,6 +305,8 @@ extern void DRIWindowExposures(WindowPtr pWin,
                               RegionPtr prgn,
                               RegionPtr bsreg);
 
+extern Bool DRIDestroyWindow(WindowPtr pWin);
+
 extern void DRICopyWindow(WindowPtr pWin,
                           DDXPointRec ptOldOrg,
                           RegionPtr prgnSrc);
@@ -341,6 +367,16 @@ extern char *DRICreatePCIBusID(pciVideoPtr PciInfo);
 
 extern int drmInstallSIGIOHandler(int fd, void (*f)(int, void *, void *));
 extern int drmRemoveSIGIOHandler(int fd);
+extern int DRIMasterFD(ScrnInfoPtr pScrn);
+
+extern void *DRIMasterSareaPointer(ScrnInfoPtr pScrn);
+
+extern drm_handle_t DRIMasterSareaHandle(ScrnInfoPtr pScrn);
+
+extern void DRIGetTexOffsetFuncs(ScreenPtr pScreen,
+				 DRITexOffsetStartProcPtr *texOffsetStartFunc,
+				 DRITexOffsetFinishProcPtr *texOffsetFinishFunc);
+
 #define _DRI_H_
 
 #endif
diff --git a/hw/xfree86/dri/drimodule.c b/hw/xfree86/dri/drimodule.c
index c437f0f..3aa9245 100644
--- a/hw/xfree86/dri/drimodule.c
+++ b/hw/xfree86/dri/drimodule.c
@@ -42,7 +42,7 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "xf86drm.h"
 static MODULESETUPPROTO(driSetup);
 
-extern drmServerInfo DRIDRMServerInfo;
+drmServerInfo DRIDRMServerInfo;
 
 static XF86ModuleVersionInfo VersRec =
 {
@@ -88,6 +88,6 @@ driSetup(pointer module, pointer opts, int *errmaj, int *errmin)
     drmSetServerInfo(&DRIDRMServerInfo);
 
     /* Need a non-NULL return value to indicate success */
-    return 1;
+    return (pointer)1;
 }
 
diff --git a/hw/xfree86/dri/dristruct.h b/hw/xfree86/dri/dristruct.h
index 340c59a..c3b0aee 100644
--- a/hw/xfree86/dri/dristruct.h
+++ b/hw/xfree86/dri/dristruct.h
@@ -53,6 +53,7 @@ typedef struct _DRIDrawablePrivRec
     int			drawableIndex;
     ScreenPtr		pScreen;
     int 		refCount;
+    int 		nrects;
 } DRIDrawablePrivRec, *DRIDrawablePrivPtr;
 
 struct _DRIContextPrivRec
@@ -72,6 +73,11 @@ struct _DRIContextPrivRec
 #define DRI_SCREEN_PRIV_FROM_INDEX(screenIndex) ((DRIScreenPrivPtr) \
     (screenInfo.screens[screenIndex]->devPrivates[DRIScreenPrivIndex].ptr))
 
+#define DRI_ENT_PRIV(pScrn)  \
+    ((DRIEntPrivIndex < 0) ? \
+     NULL:		     \
+     ((DRIEntPrivPtr)(xf86GetEntityPrivate((pScrn)->entityList[0], \
+					   DRIEntPrivIndex)->ptr)))
 
 typedef struct _DRIScreenPrivRec
 {
@@ -79,7 +85,6 @@ typedef struct _DRIScreenPrivRec
     int			drmFD;	      /* File descriptor for /dev/video/?   */
     drm_handle_t   	hSAREA;	      /* Handle to SAREA, for mapping       */
     XF86DRISAREAPtr	pSAREA;	      /* Mapped pointer to SAREA            */
-    drm_handle_t   	hFrameBuffer; /* Handle to framebuffer, for mapping */
     drm_context_t          myContext;    /* DDX Driver's context               */
     DRIContextPrivPtr   myContextPriv;/* Pointer to server's private area   */
     DRIContextPrivPtr   lastPartial3DContext;  /* last one partially saved  */
@@ -87,10 +92,13 @@ typedef struct _DRIScreenPrivRec
     void**		partial3DContextStore; /* parital 3D context        */
     DRIInfoPtr		pDriverInfo;
     int                 nrWindows;
+    int                 nrWindowsVisible;
+    int                 nrWalked;
     drm_clip_rect_t  private_buffer_rect; /* management of private buffers */
     DrawablePtr         fullscreen; /* pointer to fullscreen drawable */
     drm_clip_rect_t  fullscreen_rect; /* fake rect for fullscreen mode */
     DRIWrappedFuncsRec	wrap;
+    DestroyWindowProcPtr DestroyWindow;
     DrawablePtr		DRIDrawables[SAREA_MAX_DRAWABLES];
     DRIContextPrivPtr   dummyCtxPriv; /* Pointer to dummy context */
     Bool		createDummyCtx;
@@ -100,6 +108,25 @@ typedef struct _DRIScreenPrivRec
     Bool		wrapped;
     Bool		windowsTouched;
     int			lockRefCount;
+    drm_handle_t        hLSAREA;      /* Handle to SAREA containing lock, for mapping */
+    XF86DRILSAREAPtr    pLSAREA;      /* Mapped pointer to SAREA containing lock */
+    int*                pLockRefCount;
+    int*                pLockingContext;
 } DRIScreenPrivRec, *DRIScreenPrivPtr;
 
+
+typedef struct _DRIEntPrivRec {
+    int drmFD;
+    Bool drmOpened;
+    Bool sAreaGrabbed;
+    drm_handle_t hLSAREA;
+    XF86DRILSAREAPtr pLSAREA;
+    unsigned long sAreaSize;
+    int lockRefCount;
+    int lockingContext;
+    ScreenPtr resOwner;
+    Bool keepFDOpen;
+    int refCount;
+} DRIEntPrivRec, *DRIEntPrivPtr;
+
 #endif /* DRI_STRUCT_H */
diff --git a/hw/xfree86/dri/sarea.h b/hw/xfree86/dri/sarea.h
index a0d6084..1528cc1 100644
--- a/hw/xfree86/dri/sarea.h
+++ b/hw/xfree86/dri/sarea.h
@@ -89,4 +89,9 @@ typedef struct _XF86DRISAREA {
     drm_context_t			dummy_context;
 } XF86DRISAREARec, *XF86DRISAREAPtr;
 
+typedef struct _XF86DRILSAREA  {
+    drmLock                     lock;
+    drmLock                     otherLocks[31];
+} XF86DRILSAREARec, *XF86DRILSAREAPtr;
+
 #endif
diff -up xorg-server-1.3.0.0/hw/xfree86/dri/xf86dri.c.newmesa xorg-server-1.3.0.0/hw/xfree86/dri/xf86dri.c
--- xorg-server-1.3.0.0/hw/xfree86/dri/xf86dri.c.newmesa	2006-09-18 16:04:18.000000000 +1000
+++ xorg-server-1.3.0.0/hw/xfree86/dri/xf86dri.c	2007-08-13 09:05:10.000000000 +1000
@@ -405,8 +405,7 @@ ProcXF86DRICreateDrawable(
 	return BadValue;
     }
 
-    if (!DRICreateDrawable( screenInfo.screens[stuff->screen],
-			    (Drawable)stuff->drawable,
+    if (!DRICreateDrawable( screenInfo.screens[stuff->screen], client,
 			    pDrawable,
 			    (drm_drawable_t *)&rep.hHWDrawable)) {
 	return BadValue;
@@ -436,8 +435,7 @@ ProcXF86DRIDestroyDrawable(
 	return BadValue;
     }
 
-    if (!DRIDestroyDrawable( screenInfo.screens[stuff->screen], 
-			     (Drawable)stuff->drawable,
+    if (!DRIDestroyDrawable( screenInfo.screens[stuff->screen], client,
 			     pDrawable)) {
 	return BadValue;
     }
@@ -453,7 +451,7 @@ ProcXF86DRIGetDrawableInfo(
     xXF86DRIGetDrawableInfoReply	rep;
     DrawablePtr pDrawable;
     int X, Y, W, H;
-    drm_clip_rect_t * pClipRects;
+    drm_clip_rect_t * pClipRects, *pClippedRects;
     drm_clip_rect_t * pBackClipRects;
     int backX, backY;
 
@@ -505,8 +503,35 @@ ProcXF86DRIGetDrawableInfo(
     if (rep.numBackClipRects) 
        rep.length += sizeof(drm_clip_rect_t) * rep.numBackClipRects;    
 
-    if (rep.numClipRects) 
+    pClippedRects = pClipRects;
+
+    if (rep.numClipRects) {
+       /* Clip cliprects to screen dimensions (redirected windows) */
+       pClippedRects = xalloc(rep.numClipRects * sizeof(drm_clip_rect_t));
+
+       if (pClippedRects) {
+	    ScreenPtr pScreen = screenInfo.screens[stuff->screen];
+	    int i, j;
+
+	    for (i = 0, j = 0; i < rep.numClipRects; i++) {
+		pClippedRects[j].x1 = max(pClipRects[i].x1, 0);
+		pClippedRects[j].y1 = max(pClipRects[i].y1, 0);
+		pClippedRects[j].x2 = min(pClipRects[i].x2, pScreen->width);
+		pClippedRects[j].y2 = min(pClipRects[i].y2, pScreen->height);
+
+		if (pClippedRects[j].x1 < pClippedRects[j].x2 &&
+		    pClippedRects[j].y1 < pClippedRects[j].y2) {
+		    j++;
+		}
+	    }
+
+	    rep.numClipRects = j;
+       } else {
+	    rep.numClipRects = 0;
+       }
+
        rep.length += sizeof(drm_clip_rect_t) * rep.numClipRects;
+    }
     
     rep.length = ((rep.length + 3) & ~3) >> 2;
 
@@ -515,7 +540,8 @@ ProcXF86DRIGetDrawableInfo(
     if (rep.numClipRects) {
 	WriteToClient(client,  
 		      sizeof(drm_clip_rect_t) * rep.numClipRects,
-		      (char *)pClipRects);
+		      (char *)pClippedRects);
+	xfree(pClippedRects);
     }
 
     if (rep.numBackClipRects) {
--- xorg-server-1.3.0.0.orig/hw/dmx/glxProxy/glxext.h	2006-09-18 16:04:17.000000000 +1000
+++ xorg-server-1.3.0.0/hw/dmx/glxProxy/glxext.h	2007-08-11 13:46:37.000000000 +1000
@@ -67,7 +67,7 @@
 
 extern void __glXNoSuchRenderOpcode(GLbyte*);
 extern int __glXNoSuchSingleOpcode(__GLXclientState*, GLbyte*);
-extern void __glXErrorCallBack(__GLinterface *gc, GLenum code);
+extern void __glXErrorCallBack(GLenum code);
 extern void __glXClearErrorOccured(void);
 extern GLboolean __glXErrorOccured(void);
 extern void __glXResetLargeCommandStatus(__GLXclientState*);
diff -up xorg-server-1.3.0.0/hw/xfree86/dixmods/glxmodule.c.newmesa xorg-server-1.3.0.0/hw/xfree86/dixmods/glxmodule.c
--- xorg-server-1.3.0.0/hw/xfree86/dixmods/glxmodule.c.newmesa	2007-08-13 09:50:37.000000000 +1000
+++ xorg-server-1.3.0.0/hw/xfree86/dixmods/glxmodule.c	2007-08-13 09:50:46.000000000 +1000
@@ -95,7 +95,7 @@ __glXMesaProxyScreenProbe(ScreenPtr pScr
   static __GLXprovider *provider;
 
   if (provider == NULL) {
-    GLcore = LoadSubModuleLocal(glxModule, "GLcore", NULL, NULL, NULL, NULL, 
+    GLcore = LoadSubModule(glxModule, "GLcore", NULL, NULL, NULL, NULL, 
 				NULL, NULL);
     if (GLcore == NULL)
       return NULL;
