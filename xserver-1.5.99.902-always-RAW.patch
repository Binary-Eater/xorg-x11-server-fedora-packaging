From b33905234025f005819c7e2acd653a3a0ecfeb82 Mon Sep 17 00:00:00 2001
From: Peter Hutterer <peter.hutterer@who-t.net>
Date: Fri, 9 Jan 2009 14:32:14 +1000
Subject: [PATCH] xfree86: always force RAW mode under linux.

The previous check for AEI on left us with the possibility that AEI is forced
off in the config, but devices are added through evdev nonetheless. A keyboard
added this way can CTRL+C the server. Even when we use kbd, we can set the
mode to RAW, so it's safer alround to to so.

Signed-off-by: Peter Hutterer <peter.hutterer@who-t.net>
---
 hw/xfree86/os-support/linux/lnx_init.c |   60 +++++++++++++------------------
 1 files changed, 25 insertions(+), 35 deletions(-)

diff --git a/hw/xfree86/os-support/linux/lnx_init.c b/hw/xfree86/os-support/linux/lnx_init.c
index 0ac97e8..17502a1 100644
--- a/hw/xfree86/os-support/linux/lnx_init.c
+++ b/hw/xfree86/os-support/linux/lnx_init.c
@@ -250,6 +250,8 @@ xf86OpenConsole(void)
 
         if (!ShareVTs)
         {
+            struct termios nTty;
+
 #if defined(DO_OS_FONTRESTORE)
 	    lnx_savefont();
 #endif
@@ -282,37 +284,27 @@ xf86OpenConsole(void)
 	        FatalError("xf86OpenConsole: KDSETMODE KD_GRAPHICS failed %s\n",
 		           strerror(errno));
 
-	    /* Set the keyboard to RAW mode. If we're using the keyboard
-	     * driver, the driver does it for us. If we have AEI on, then
-	     * we're expecting the devices to be added (i.e. evdev) and we
-	     * have to set it manually.
-	     */
-	    if (xf86Info.allowEmptyInput)
-	    {
-		struct termios nTty;
-
-		tcgetattr(xf86Info.consoleFd, &tty_attr);
-		ioctl(xf86Info.consoleFd, KDGKBMODE, &tty_mode);
-
-		if (ioctl(xf86Info.consoleFd, KDSKBMODE, K_RAW) < 0)
-		    FatalError("xf86OpenConsole: KDSKBMODE K_RAW failed %s\n",
-			    strerror(errno));
-
-		nTty = tty_attr;
-		nTty.c_iflag = (IGNPAR | IGNBRK) & (~PARMRK) & (~ISTRIP);
-		nTty.c_oflag = 0;
-		nTty.c_cflag = CREAD | CS8;
-		nTty.c_lflag = 0;
-		nTty.c_cc[VTIME]=0;
-		nTty.c_cc[VMIN]=1;
-		cfsetispeed(&nTty, 9600);
-		cfsetospeed(&nTty, 9600);
-		tcsetattr(xf86Info.consoleFd, TCSANOW, &nTty);
-
-		/* need to keep the buffer clean, else the kernel gets angry */
-		console_handler = xf86AddGeneralHandler(xf86Info.consoleFd,
-							drain_console, NULL);
-	    }
+            tcgetattr(xf86Info.consoleFd, &tty_attr);
+            ioctl(xf86Info.consoleFd, KDGKBMODE, &tty_mode);
+
+            if (ioctl(xf86Info.consoleFd, KDSKBMODE, K_RAW) < 0)
+                FatalError("xf86OpenConsole: KDSKBMODE K_RAW failed %s\n",
+                        strerror(errno));
+
+            nTty = tty_attr;
+            nTty.c_iflag = (IGNPAR | IGNBRK) & (~PARMRK) & (~ISTRIP);
+            nTty.c_oflag = 0;
+            nTty.c_cflag = CREAD | CS8;
+            nTty.c_lflag = 0;
+            nTty.c_cc[VTIME]=0;
+            nTty.c_cc[VMIN]=1;
+            cfsetispeed(&nTty, 9600);
+            cfsetospeed(&nTty, 9600);
+            tcsetattr(xf86Info.consoleFd, TCSANOW, &nTty);
+
+            /* need to keep the buffer clean, else the kernel gets angry */
+            console_handler = xf86AddGeneralHandler(xf86Info.consoleFd,
+                    drain_console, NULL);
 
 	    /* we really should have a InitOSInputDevices() function instead
 	     * of Init?$#*&Device(). So I just place it here */
@@ -376,10 +368,8 @@ xf86CloseConsole(void)
 	xf86Msg(X_WARNING, "xf86CloseConsole: KDSETMODE failed: %s\n",
 		strerror(errno));
 
-    if (xf86Info.allowEmptyInput) {
-	ioctl(xf86Info.consoleFd, KDSKBMODE, tty_mode);
-	tcsetattr(xf86Info.consoleFd, TCSANOW, &tty_attr);
-    }
+    ioctl(xf86Info.consoleFd, KDSKBMODE, tty_mode);
+    tcsetattr(xf86Info.consoleFd, TCSANOW, &tty_attr);
 
     if (ioctl(xf86Info.consoleFd, VT_GETMODE, &VT) < 0) 
 	xf86Msg(X_WARNING, "xf86CloseConsole: VT_GETMODE failed: %s\n",
-- 
1.6.0.6

