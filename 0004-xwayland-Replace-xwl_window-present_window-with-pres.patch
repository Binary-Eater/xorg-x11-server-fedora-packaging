From 5a1cb0989274fd745569a60c28c9a5ca729cabf6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michel=20D=C3=A4nzer?= <michel.daenzer@amd.com>
Date: Thu, 1 Nov 2018 18:44:24 +0100
Subject: [PATCH xserver 4/7] xwayland: Replace xwl_window::present_window with
 ::present_flipped

There's no need to keep track of the window which last performed a
Present flip. This fixes crashes due to the assertion in
xwl_present_flips_stop failing. Fixes issue #10.

The damage generated by a flip only needs to be ignored once, then
xwl_window::present_flipped can be cleared. This may fix freezing in
the (hypothetical) scenario where Present flips are performed on a
window, followed by other drawing requests using the window as the
destination, but nothing triggering xwl_present_flips_stop. The damage
from the latter drawing requests would continue being ignored.

(cherry picked from commit 6b016d58d23d16eaae9908a92ed90547d1926317)
---
 hw/xwayland/xwayland-present.c | 56 ++++++++--------------------------
 hw/xwayland/xwayland.c         | 17 ++++++++---
 hw/xwayland/xwayland.h         |  4 ++-
 3 files changed, 27 insertions(+), 50 deletions(-)

diff --git a/hw/xwayland/xwayland-present.c b/hw/xwayland/xwayland-present.c
index 4f517d46b..e6dca5ed0 100644
--- a/hw/xwayland/xwayland-present.c
+++ b/hw/xwayland/xwayland-present.c
@@ -90,24 +90,19 @@ xwl_present_has_events(struct xwl_present_window *xwl_present_window)
            !xorg_list_is_empty(&xwl_present_window->release_queue);
 }
 
-static inline Bool
-xwl_present_is_flipping(WindowPtr window, struct xwl_window *xwl_window)
-{
-    return xwl_window && xwl_window->present_window == window;
-}
-
 static void
 xwl_present_reset_timer(struct xwl_present_window *xwl_present_window)
 {
     if (xwl_present_has_events(xwl_present_window)) {
-        WindowPtr present_window = xwl_present_window->window;
-        Bool is_flipping = xwl_present_is_flipping(present_window,
-                                                   xwl_window_from_window(present_window));
+        CARD32 timeout;
+
+        if (xwl_present_window->frame_callback)
+            timeout = TIMER_LEN_FLIP;
+        else
+            timeout = TIMER_LEN_COPY;
 
         xwl_present_window->frame_timer = TimerSet(xwl_present_window->frame_timer,
-                                                   0,
-                                                   is_flipping ? TIMER_LEN_FLIP :
-                                                                 TIMER_LEN_COPY,
+                                                   0, timeout,
                                                    &xwl_present_timer_callback,
                                                    xwl_present_window);
     } else {
@@ -118,16 +113,12 @@ xwl_present_reset_timer(struct xwl_present_window *xwl_present_window)
 void
 xwl_present_cleanup(WindowPtr window)
 {
-    struct xwl_window *xwl_window = xwl_window_from_window(window);
     struct xwl_present_window *xwl_present_window = xwl_present_window_priv(window);
     struct xwl_present_event *event, *tmp;
 
     if (!xwl_present_window)
         return;
 
-    if (xwl_window && xwl_window->present_window == window)
-        xwl_window->present_window = NULL;
-
     if (xwl_present_window->frame_callback) {
         wl_callback_destroy(xwl_present_window->frame_callback);
         xwl_present_window->frame_callback = NULL;
@@ -361,10 +352,6 @@ xwl_present_queue_vblank(WindowPtr present_window,
     if (!xwl_window)
         return BadMatch;
 
-    if (xwl_window->present_window &&
-            xwl_window->present_window != present_window)
-        return BadMatch;
-
     event = malloc(sizeof *event);
     if (!event)
         return BadAlloc;
@@ -433,13 +420,6 @@ xwl_present_check_flip2(RRCrtcPtr crtc,
     if (!xwl_window)
         return FALSE;
 
-    /*
-     * Do not flip if there is already another child window doing flips.
-     */
-    if (xwl_window->present_window &&
-            xwl_window->present_window != present_window)
-        return FALSE;
-
     /*
      * We currently only allow flips of windows, that have the same
      * dimensions as their xwl_window parent window. For the case of
@@ -476,8 +456,6 @@ xwl_present_flip(WindowPtr present_window,
     if (!event)
         return FALSE;
 
-    xwl_window->present_window = present_window;
-
     buffer = xwl_glamor_pixmap_get_wl_buffer(pixmap, &buffer_created);
 
     event->event_id = event_id;
@@ -502,13 +480,6 @@ xwl_present_flip(WindowPtr present_window,
     /* We can flip directly to the main surface (full screen window without clips) */
     wl_surface_attach(xwl_window->surface, buffer, 0, 0);
 
-    if (!xwl_present_window->frame_timer ||
-            xwl_present_window->frame_timer_firing) {
-        /* Realign timer */
-        xwl_present_window->frame_timer_firing = FALSE;
-        xwl_present_reset_timer(xwl_present_window);
-    }
-
     if (!xwl_present_window->frame_callback) {
         xwl_present_window->frame_callback = wl_surface_frame(xwl_window->surface);
         wl_callback_add_listener(xwl_present_window->frame_callback,
@@ -516,6 +487,10 @@ xwl_present_flip(WindowPtr present_window,
                                  xwl_present_window);
     }
 
+    /* Realign timer */
+    xwl_present_window->frame_timer_firing = FALSE;
+    xwl_present_reset_timer(xwl_present_window);
+
     wl_surface_damage(xwl_window->surface, 0, 0,
                       damage_box->x2 - damage_box->x1,
                       damage_box->y2 - damage_box->y1);
@@ -531,22 +506,15 @@ xwl_present_flip(WindowPtr present_window,
     }
 
     wl_display_flush(xwl_window->xwl_screen->display);
+    xwl_window->present_flipped = TRUE;
     return TRUE;
 }
 
 static void
 xwl_present_flips_stop(WindowPtr window)
 {
-    struct xwl_window *xwl_window = xwl_window_from_window(window);
     struct xwl_present_window   *xwl_present_window = xwl_present_window_priv(window);
 
-    if (!xwl_window)
-        return;
-
-    assert(xwl_window->present_window == window);
-
-    xwl_window->present_window = NULL;
-
     /* Change back to the fast refresh rate */
     xwl_present_reset_timer(xwl_present_window);
 }
diff --git a/hw/xwayland/xwayland.c b/hw/xwayland/xwayland.c
index 96b4db18c..988b8e17d 100644
--- a/hw/xwayland/xwayland.c
+++ b/hw/xwayland/xwayland.c
@@ -370,6 +370,18 @@ damage_report(DamagePtr pDamage, RegionPtr pRegion, void *data)
     struct xwl_window *xwl_window = data;
     struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
 
+#ifdef GLAMOR_HAS_GBM
+    if (xwl_window->present_flipped) {
+        /* This damage is from a Present flip, which already committed a new
+         * buffer for the surface, so we don't need to do anything in response
+         */
+        RegionEmpty(DamageRegion(pDamage));
+        xorg_list_del(&xwl_window->link_damage);
+        xwl_window->present_flipped = FALSE;
+        return;
+    }
+#endif
+
     xorg_list_add(&xwl_window->link_damage, &xwl_screen->damage_window_list);
 }
 
@@ -721,11 +733,6 @@ xwl_screen_post_damage(struct xwl_screen *xwl_screen)
 
     xorg_list_for_each_entry_safe(xwl_window, next_xwl_window,
                                   &xwl_screen->damage_window_list, link_damage) {
-#ifdef GLAMOR_HAS_GBM
-        /* Present on the main surface. So don't commit here as well. */
-        if (xwl_window->present_window)
-            continue;
-#endif
         /* If we're waiting on a frame callback from the server,
          * don't attach a new buffer. */
         if (xwl_window->frame_callback)
diff --git a/hw/xwayland/xwayland.h b/hw/xwayland/xwayland.h
index 3f4a601fe..a79f836ad 100644
--- a/hw/xwayland/xwayland.h
+++ b/hw/xwayland/xwayland.h
@@ -182,7 +182,9 @@ struct xwl_window {
     struct xorg_list link_damage;
     struct wl_callback *frame_callback;
     Bool allow_commits;
-    WindowPtr present_window;
+#ifdef GLAMOR_HAS_GBM
+    Bool present_flipped;
+#endif
 };
 
 #ifdef GLAMOR_HAS_GBM
-- 
2.19.2

