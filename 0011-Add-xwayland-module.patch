From a426cf14900509b7836495cbc8310351c3d24dde Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Kristian=20H=C3=B8gsberg?= <krh@redhat.com>
Date: Fri, 18 Sep 2009 22:08:16 -0400
Subject: [PATCH 11/30] Add xwayland module
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Squashed and rebased from the xwayland-1.12 branch.  Contributions from

  Christopher James Halse Rogers <christopher.halse.rogers@canonical.com>
  Corentin Chary <corentin.chary@gmail.com>
  Daniel Stone <daniel@fooishbar.org>
  Kristian Høgsberg <krh@bitplanet.net>
  Robert Bragg <robert@linux.intel.com>
  Scott Moreau <oreaus@gmail.com>
  Tiago Vignatti <tiago.vignatti@intel.com>
---
 configure.ac                           |   13 +-
 configure.ac.orig                      | 2332 ++++++++++++++++++++++++++++++++
 hw/xfree86/Makefile.am                 |    8 +-
 hw/xfree86/Makefile.am.jx              |  126 ++
 hw/xfree86/Makefile.am.orig            |  122 ++
 hw/xfree86/Makefile.am.rej             |   17 +
 hw/xfree86/common/xf86Config.c         |   28 +-
 hw/xfree86/common/xf86Globals.c        |    2 +
 hw/xfree86/common/xf86Init.c           |   20 +
 hw/xfree86/common/xf86Init.c.orig      | 1656 +++++++++++++++++++++++
 hw/xfree86/common/xf86Priv.h           |    2 +
 hw/xfree86/dri2/dri2.c                 |    7 +-
 hw/xfree86/dri2/dri2.h                 |    2 +-
 hw/xfree86/xwayland/Makefile.am        |   44 +
 hw/xfree86/xwayland/drm.xml            |  139 ++
 hw/xfree86/xwayland/xserver.xml        |   18 +
 hw/xfree86/xwayland/xwayland-cursor.c  |  241 ++++
 hw/xfree86/xwayland/xwayland-drm.c     |  235 ++++
 hw/xfree86/xwayland/xwayland-input.c   |  610 +++++++++
 hw/xfree86/xwayland/xwayland-output.c  |  309 +++++
 hw/xfree86/xwayland/xwayland-private.h |  132 ++
 hw/xfree86/xwayland/xwayland-window.c  |  317 +++++
 hw/xfree86/xwayland/xwayland.c         |  392 ++++++
 hw/xfree86/xwayland/xwayland.h         |   83 ++
 include/xorg-server.h.in               |    3 +
 25 files changed, 6848 insertions(+), 10 deletions(-)
 create mode 100644 configure.ac.orig
 create mode 100644 hw/xfree86/Makefile.am.jx
 create mode 100644 hw/xfree86/Makefile.am.orig
 create mode 100644 hw/xfree86/Makefile.am.rej
 create mode 100644 hw/xfree86/common/xf86Init.c.orig
 create mode 100644 hw/xfree86/xwayland/Makefile.am
 create mode 100644 hw/xfree86/xwayland/drm.xml
 create mode 100644 hw/xfree86/xwayland/xserver.xml
 create mode 100644 hw/xfree86/xwayland/xwayland-cursor.c
 create mode 100644 hw/xfree86/xwayland/xwayland-drm.c
 create mode 100644 hw/xfree86/xwayland/xwayland-input.c
 create mode 100644 hw/xfree86/xwayland/xwayland-output.c
 create mode 100644 hw/xfree86/xwayland/xwayland-private.h
 create mode 100644 hw/xfree86/xwayland/xwayland-window.c
 create mode 100644 hw/xfree86/xwayland/xwayland.c
 create mode 100644 hw/xfree86/xwayland/xwayland.h

diff --git a/configure.ac b/configure.ac
index 737025c..c65e1a7 100644
--- a/configure.ac
+++ b/configure.ac
@@ -635,6 +635,7 @@ AC_ARG_ENABLE(windowswm,      AS_HELP_STRING([--enable-windowswm], [Build XWin w
 AC_ARG_ENABLE(libdrm,         AS_HELP_STRING([--enable-libdrm], [Build Xorg with libdrm support (default: enabled)]), [DRM=$enableval],[DRM=yes])
 AC_ARG_ENABLE(clientids,      AS_HELP_STRING([--disable-clientids], [Build Xorg with client ID tracking (default: enabled)]), [CLIENTIDS=$enableval], [CLIENTIDS=yes])
 AC_ARG_ENABLE(pciaccess, AS_HELP_STRING([--enable-pciaccess], [Build Xorg with pciaccess library (default: enabled)]), [PCI=$enableval], [PCI=yes])
+AC_ARG_ENABLE(wayland,      AS_HELP_STRING([--disable-wayland], [Build Wayland extension (default: enabled)]), [WAYLAND=$enableval], [WAYLAND=yes])
 
 dnl DDXes.
 AC_ARG_ENABLE(xorg,    	      AS_HELP_STRING([--enable-xorg], [Build Xorg server (default: auto)]), [XORG=$enableval], [XORG=auto])
@@ -1018,6 +1019,14 @@ fi
 if test "x$MITSHM" = xauto; then
 	MITSHM="$ac_cv_sysv_ipc"
 fi
+
+AM_CONDITIONAL(WAYLAND, [test "x$WAYLAND" = xyes])
+if test "x$WAYLAND" = xyes; then
+	AC_DEFINE(XORG_WAYLAND, 1, [Support wayland mode])
+	REQUIRED_MODULES="$REQUIRED_MODULES wayland-client"
+	WAYLAND_SCANNER_RULES(['$(top_srcdir)/hw/xfree86/xwayland'])
+fi
+
 AM_CONDITIONAL(MITSHM, [test "x$MITSHM" = xyes])
 if test "x$MITSHM" = xyes; then
 	AC_DEFINE(MITSHM, 1, [Support MIT-SHM extension])
@@ -1111,12 +1120,13 @@ case "$DRI2,$HAVE_DRI2PROTO" in
 esac
 AM_CONDITIONAL(DRI2, test "x$DRI2" = xyes)
 
-if test "x$DRI" = xyes || test "x$DRI2" = xyes || test "x$CONFIG_UDEV_KMS" = xyes; then
+if test "x$DRI" = xyes || test "x$DRI2" = xyes || test "x$CONFIG_UDEV_KMS" = xyes || test "x$WAYLAND" = xyes ; then
 	if test "x$DRM" = xyes; then
 		AC_DEFINE(WITH_LIBDRM, 1, [Building with libdrm support])
 		PKG_CHECK_MODULES([LIBDRM], $LIBDRM)
 	fi
 fi
+AM_CONDITIONAL(DRM, test "x$DRM" = xyes)
 
 if test "x$DRI2" = xyes; then
 	save_CFLAGS=$CFLAGS
@@ -2267,6 +2277,7 @@ hw/xfree86/dixmods/Makefile
 hw/xfree86/doc/Makefile
 hw/xfree86/dri/Makefile
 hw/xfree86/dri2/Makefile
+hw/xfree86/xwayland/Makefile
 hw/xfree86/exa/Makefile
 hw/xfree86/exa/man/Makefile
 hw/xfree86/fbdevhw/Makefile
diff --git a/configure.ac.orig b/configure.ac.orig
new file mode 100644
index 0000000..737025c
--- /dev/null
+++ b/configure.ac.orig
@@ -0,0 +1,2332 @@
+dnl Copyright © 2003-2007 Keith Packard, Daniel Stone
+dnl
+dnl Permission is hereby granted, free of charge, to any person obtaining a
+dnl copy of this software and associated documentation files (the "Software"),
+dnl to deal in the Software without restriction, including without limitation
+dnl the rights to use, copy, modify, merge, publish, distribute, sublicense,
+dnl and/or sell copies of the Software, and to permit persons to whom the
+dnl Software is furnished to do so, subject to the following conditions:
+dnl
+dnl The above copyright notice and this permission notice (including the next
+dnl paragraph) shall be included in all copies or substantial portions of the
+dnl Software.
+dnl
+dnl THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+dnl IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+dnl FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+dnl THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+dnl LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+dnl FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+dnl DEALINGS IN THE SOFTWARE.
+dnl
+dnl Authors: Keith Packard <keithp@keithp.com>
+dnl          Daniel Stone <daniel@fooishbar.org>
+dnl          an unwitting cast of miscellaneous others
+dnl
+dnl Process this file with autoconf to create configure.
+
+AC_PREREQ(2.60)
+AC_INIT([xorg-server], 1.14.3, [https://bugs.freedesktop.org/enter_bug.cgi?product=xorg], xorg-server)
+RELEASE_DATE="2013-09-12"
+RELEASE_NAME="September Rain"
+AC_CONFIG_SRCDIR([Makefile.am])
+AM_INIT_AUTOMAKE([foreign dist-bzip2])
+
+# Require xorg-macros minimum of 1.14 for XORG_COMPILER_BRAND in XORG_DEFAULT_OPTIONS
+m4_ifndef([XORG_MACROS_VERSION],
+          [m4_fatal([must install xorg-macros 1.14 or later before running autoconf/autogen])])
+XORG_MACROS_VERSION(1.14)
+XORG_DEFAULT_OPTIONS
+XORG_WITH_DOXYGEN(1.6.1)
+XORG_CHECK_SGML_DOCTOOLS(1.8)
+XORG_ENABLE_DOCS
+XORG_ENABLE_DEVEL_DOCS
+XORG_WITH_XMLTO(0.0.20)
+XORG_WITH_FOP
+XORG_WITH_XSLTPROC
+XORG_ENABLE_UNIT_TESTS
+XORG_LD_WRAP([optional])
+
+m4_ifndef([XORG_FONT_MACROS_VERSION], [m4_fatal([must install fontutil 1.1 or later before running autoconf/autogen])])
+XORG_FONT_MACROS_VERSION(1.1)
+
+dnl this gets generated by autoheader, and thus contains all the defines.  we
+dnl don't ever actually use it, internally.
+AC_CONFIG_HEADERS(include/do-not-use-config.h)
+dnl xorg-server.h is an external header, designed to be included by loadable
+dnl drivers.
+AC_CONFIG_HEADERS(include/xorg-server.h)
+dnl dix-config.h covers most of the DIX (i.e. everything but the DDX, not just
+dnl dix/).
+AC_CONFIG_HEADERS(include/dix-config.h)
+dnl xorg-config.h covers the Xorg DDX.
+AC_CONFIG_HEADERS(include/xorg-config.h)
+dnl xkb-config.h covers XKB for the Xorg and Xnest DDXs.
+AC_CONFIG_HEADERS(include/xkb-config.h)
+dnl xwin-config.h covers the XWin DDX.
+AC_CONFIG_HEADERS(include/xwin-config.h)
+dnl kdrive-config.h covers the kdrive DDX
+AC_CONFIG_HEADERS(include/kdrive-config.h)
+dnl version-config.h covers the version numbers so they can be bumped without
+dnl forcing an entire recompile.x
+AC_CONFIG_HEADERS(include/version-config.h)
+
+AM_PROG_AS
+AC_PROG_LN_S
+AC_LIBTOOL_WIN32_DLL
+AC_DISABLE_STATIC
+AC_PROG_LIBTOOL
+PKG_PROG_PKG_CONFIG
+AC_PROG_LEX
+AC_PROG_YACC
+AC_SYS_LARGEFILE
+XORG_PROG_RAWCPP
+
+# Quoted so that make will expand $(CWARNFLAGS) in makefiles to allow
+# easier overrides at build time.
+XSERVER_CFLAGS='$(CWARNFLAGS)'
+
+dnl Explicitly add -fno-strict-aliasing since this option should disappear
+dnl from util-macros CWARNFLAGS
+if  test "x$GCC" = xyes ; then
+    XSERVER_CFLAGS="$XSERVER_CFLAGS -fno-strict-aliasing"
+fi
+
+dnl Check for dtrace program (needed to build Xserver dtrace probes)
+dnl Also checks for <sys/sdt.h>, since some Linux distros have an 
+dnl ISDN trace program named dtrace
+AC_ARG_WITH(dtrace, AS_HELP_STRING([--with-dtrace=PATH],
+	     [Enable dtrace probes (default: enabled if dtrace found)]),
+	     [WDTRACE=$withval], [WDTRACE=auto])
+if test "x$WDTRACE" = "xyes" -o "x$WDTRACE" = "xauto" ; then
+	AC_PATH_PROG(DTRACE, [dtrace], [not_found], [$PATH:/usr/sbin])
+	if test "x$DTRACE" = "xnot_found" ; then
+		if test "x$WDTRACE" = "xyes" ; then
+			AC_MSG_FAILURE([dtrace requested but not found])
+		fi
+		WDTRACE="no"
+	else
+		AC_CHECK_HEADER(sys/sdt.h, [HAS_SDT_H="yes"], [HAS_SDT_H="no"])
+		if test "x$WDTRACE" = "xauto" -a "x$HAS_SDT_H" = "xno" ; then
+			WDTRACE="no"
+		fi
+	fi
+fi
+if test "x$WDTRACE" != "xno" ; then
+  AC_DEFINE(XSERVER_DTRACE, 1, 
+      [Define to 1 if the DTrace Xserver provider probes should be built in.])
+
+# Solaris/OpenSolaris require dtrace -G to build dtrace probe information into
+# object files, and require linking with those as relocatable objects, not .a
+# archives. MacOS X handles all this in the normal compiler toolchain, and on
+# some releases (like Tiger), will error out on dtrace -G.  For now, other
+# platforms with Dtrace ports are assumed to support -G (the FreeBSD and Linux
+# ports appear to, based on my web searches, but have not yet been tested).
+	case $host_os in
+		darwin*)	SPECIAL_DTRACE_OBJECTS=no ;;
+		*)		SPECIAL_DTRACE_OBJECTS=yes ;;
+	esac
+fi
+AM_CONDITIONAL(XSERVER_DTRACE, [test "x$WDTRACE" != "xno"])
+AM_CONDITIONAL(SPECIAL_DTRACE_OBJECTS, [test "x$SPECIAL_DTRACE_OBJECTS" = "xyes"])
+
+AC_HEADER_DIRENT
+AC_HEADER_STDC
+AC_CHECK_HEADERS([fcntl.h stdlib.h string.h unistd.h dlfcn.h stropts.h fnmatch.h sys/utsname.h])
+
+dnl Checks for typedefs, structures, and compiler characteristics.
+AC_C_CONST
+AC_C_TYPEOF
+AC_C_BIGENDIAN([ENDIAN="X_BIG_ENDIAN"], [ENDIAN="X_LITTLE_ENDIAN"])
+
+AC_CHECK_SIZEOF([unsigned long])
+if test "$ac_cv_sizeof_unsigned_long" = 8; then
+	AC_DEFINE(_XSERVER64, 1, [Define to 1 if unsigned long is 64 bits.])
+fi
+
+AC_TYPE_PID_T
+
+# Checks for headers/macros for byte swapping
+# Known variants:
+#	<byteswap.h> bswap_16, bswap_32, bswap_64  (glibc)
+#	<sys/endian.h> __swap16, __swap32, __swap64 (OpenBSD)
+#	<sys/endian.h> bswap16, bswap32, bswap64 (other BSD's)
+#	and a fallback to local macros if none of the above are found
+
+# if <byteswap.h> is found, assume it's the correct version
+AC_CHECK_HEADERS([byteswap.h])
+
+# if <sys/endian.h> is found, have to check which version
+AC_CHECK_HEADER([sys/endian.h], [HAVE_SYS_ENDIAN_H="yes"], [HAVE_SYS_ENDIAN_H="no"])
+
+if test "x$HAVE_SYS_ENDIAN_H" = "xyes" ; then
+	AC_MSG_CHECKING([for __swap16 variant of <sys/endian.h> byteswapping macros])
+	AC_LINK_IFELSE([AC_LANG_PROGRAM([
+#include <sys/types.h>
+#include <sys/endian.h>
+ ], [
+int a = 1, b;
+b = __swap16(a);
+ ])
+], [SYS_ENDIAN__SWAP='yes'], [SYS_ENDIAN__SWAP='no'])
+	AC_MSG_RESULT([$SYS_ENDIAN__SWAP])
+
+	AC_MSG_CHECKING([for bswap16 variant of <sys/endian.h> byteswapping macros])
+	AC_LINK_IFELSE([AC_LANG_PROGRAM([
+#include <sys/types.h>
+#include <sys/endian.h>
+ ], [
+int a = 1, b;
+b = bswap16(a);
+ ])
+], [SYS_ENDIAN_BSWAP='yes'], [SYS_ENDIAN_BSWAP='no'])
+	AC_MSG_RESULT([$SYS_ENDIAN_BSWAP])
+
+    	if test "$SYS_ENDIAN_BSWAP" = "yes" ; then
+		USE_SYS_ENDIAN_H=yes
+		BSWAP=bswap
+	else	
+	    	if test "$SYS_ENDIAN__SWAP" = "yes" ; then
+			USE_SYS_ENDIAN_H=yes
+			BSWAP=__swap
+		else
+			USE_SYS_ENDIAN_H=no
+		fi
+	fi
+
+	if test "$USE_SYS_ENDIAN_H" = "yes" ; then
+	    AC_DEFINE([USE_SYS_ENDIAN_H], 1, 
+		[Define to use byteswap macros from <sys/endian.h>])
+	    AC_DEFINE_UNQUOTED([bswap_16], ${BSWAP}16, 
+			[Define to 16-bit byteswap macro])
+	    AC_DEFINE_UNQUOTED([bswap_32], ${BSWAP}32, 
+			[Define to 32-bit byteswap macro])
+	    AC_DEFINE_UNQUOTED([bswap_64], ${BSWAP}64, 
+			[Define to 64-bit byteswap macro])
+	fi
+fi
+
+dnl Check to see if dlopen is in default libraries (like Solaris, which
+dnl has it in libc), or if libdl is needed to get it.
+AC_CHECK_FUNC([dlopen], [],
+	AC_CHECK_LIB([dl], [dlopen], DLOPEN_LIBS="-ldl"))
+AC_SUBST(DLOPEN_LIBS)
+
+dnl Checks for library functions.
+AC_CHECK_FUNCS([backtrace ffs geteuid getuid issetugid getresuid \
+	getdtablesize getifaddrs getpeereid getpeerucred getzoneid \
+	mmap shmctl64 strncasecmp vasprintf vsnprintf walkcontext])
+AC_REPLACE_FUNCS([strcasecmp strcasestr strlcat strlcpy strndup])
+
+dnl Find the math libary, then check for cbrt function in it.
+AC_CHECK_LIB(m, sqrt)
+AC_CHECK_FUNCS([cbrt])
+
+AC_CHECK_HEADERS([ndbm.h dbm.h rpcsvc/dbm.h])
+
+dnl AGPGART headers
+AC_CHECK_HEADERS([linux/agpgart.h sys/agpio.h sys/agpgart.h], AGP=yes)
+AM_CONDITIONAL(AGP, [test "x$AGP" = xyes])
+
+dnl APM header
+AC_CHECK_HEADERS([linux/apm_bios.h], LNXAPM=yes)
+AM_CONDITIONAL(LNXAPM, [test "x$LNXAPM" = xyes])
+
+dnl fbdev header
+AC_CHECK_HEADERS([linux/fb.h], FBDEV=yes)
+AM_CONDITIONAL(FBDEVHW, [test "x$FBDEV" = xyes])
+
+dnl MTRR header
+AC_CHECK_HEADERS([asm/mtrr.h], ac_cv_asm_mtrr_h=yes)
+if test "x$ac_cv_asm_mtrr_h" = xyes; then
+	HAVE_MTRR=yes
+fi
+
+dnl BSD MTRR header
+AC_CHECK_HEADERS([sys/memrange.h], ac_cv_memrange_h=yes)
+if test "x$ac_cv_memrange_h" = xyes; then
+	HAVE_MTRR=yes
+fi
+
+if test "x$HAVE_MTRR" = xyes; then
+	AC_DEFINE(HAS_MTRR_SUPPORT, 1, [MTRR support available])
+fi
+
+dnl A NetBSD MTRR header
+AC_CHECK_HEADERS([machine/mtrr.h], ac_cv_machine_mtrr_h=yes)
+if test "x$ac_cv_machine_mtrr_h" = xyes; then
+	AC_DEFINE(HAS_MTRR_BUILTIN, 1, [Define to 1 if NetBSD built-in MTRR
+		support is available])
+fi
+
+dnl FreeBSD kldload support (sys/linker.h)
+AC_CHECK_HEADERS([sys/linker.h],
+	[ac_cv_sys_linker_h=yes],
+	[ac_cv_sys_linker_h=no],
+	[#include <sys/param.h>])
+AM_CONDITIONAL(FREEBSD_KLDLOAD, [test "x$ac_cv_sys_linker_h" = xyes])
+
+AC_CACHE_CHECK([for SYSV IPC],
+		ac_cv_sysv_ipc,
+		[AC_TRY_LINK([
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/shm.h>
+#include <sys/stat.h>
+],[
+{ 
+    int id;
+    id = shmget(IPC_PRIVATE, 512, S_IRUSR | S_IWUSR);
+    if (id < 0) return -1;
+    return shmctl(id, IPC_RMID, 0);
+}],
+	[ac_cv_sysv_ipc=yes],
+	[ac_cv_sysv_ipc=no])])
+if test "x$ac_cv_sysv_ipc" = xyes; then
+	AC_DEFINE(HAVE_SYSV_IPC, 1, [Define to 1 if SYSV IPC is available])
+fi
+
+dnl OpenBSD /dev/xf86 aperture driver 
+if test -c /dev/xf86 ; then
+	AC_DEFINE(HAS_APERTURE_DRV, 1, [System has /dev/xf86 aperture driver])
+fi
+
+dnl BSD APM support 
+AC_CHECK_HEADER([machine/apmvar.h],[
+	AC_CHECK_HEADER([sys/event.h],
+		ac_cv_BSD_KQUEUE_APM=yes,
+		ac_cv_BSD_APM=yes)])
+
+AM_CONDITIONAL(BSD_APM, [test "x$ac_cv_BSD_APM" = xyes])
+AM_CONDITIONAL(BSD_KQUEUE_APM, [test "x$ac_cv_BSD_KQUEUE_APM" = xyes])
+	
+dnl glibc backtrace support check (hw/xfree86/common/xf86Events.c)
+AC_CHECK_HEADER([execinfo.h],[
+    AC_CHECK_LIB(c, backtrace, [
+        AC_DEFINE(HAVE_BACKTRACE, 1, [Has backtrace support])
+        AC_DEFINE(HAVE_EXECINFO_H, 1, [Have execinfo.h])
+    ])]
+)
+
+PKG_CHECK_MODULES(LIBUNWIND, libunwind, [HAVE_LIBUNWIND=yes], [HAVE_LIBUNWIND=no])
+if test "x$HAVE_LIBUNWIND" = xyes; then
+	AC_DEFINE(HAVE_LIBUNWIND, 1, [Have libunwind support])
+fi
+AM_CONDITIONAL(HAVE_LIBUNWIND, [test "x$HAVE_LIBUNWIND" = xyes])
+
+
+dnl ---------------------------------------------------------------------------
+dnl Bus options and CPU capabilities.  Replaces logic in
+dnl hw/xfree86/os-support/bus/Makefile.am, among others.
+dnl ---------------------------------------------------------------------------
+DEFAULT_INT10="x86emu"
+
+dnl Override defaults as needed for specific platforms:
+
+case $host_cpu in
+  alpha*)
+	ALPHA_VIDEO=yes
+	case $host_os in
+	        *freebsd*)	SYS_LIBS=-lio ;;
+		*netbsd*)	AC_DEFINE(USE_ALPHA_PIO, 1, [NetBSD PIO alpha IO]) ;;
+	esac
+	GLX_ARCH_DEFINES="-D__GLX_ALIGN64 -mieee"
+	;;
+  arm*)
+	ARM_VIDEO=yes
+	;;
+  i*86)
+	I386_VIDEO=yes
+	case $host_os in
+		*freebsd*)	AC_DEFINE(USE_DEV_IO) ;;
+		*dragonfly*)	AC_DEFINE(USE_DEV_IO) ;;
+		*netbsd*)	AC_DEFINE(USE_I386_IOPL)
+				SYS_LIBS=-li386
+				;;
+		*openbsd*)	AC_DEFINE(USE_I386_IOPL) 
+				SYS_LIBS=-li386
+				;;
+	esac
+        ;;
+  powerpc*)
+	PPC_VIDEO=yes
+	case $host_os in
+		*freebsd*)	DEFAULT_INT10=stub ;;
+	esac
+	;;
+  sparc*)
+	SPARC64_VIDEO=yes
+	BSD_ARCH_SOURCES="sparc64_video.c ioperm_noop.c"
+	GLX_ARCH_DEFINES="-D__GLX_ALIGN64"
+	;;
+  x86_64*|amd64*)
+	I386_VIDEO=yes
+	case $host_os in
+		*freebsd*)	AC_DEFINE(USE_DEV_IO, 1, [BSD /dev/io]) ;;
+		*dragonfly*)	AC_DEFINE(USE_DEV_IO, 1, [BSD /dev/io]) ;;
+		*netbsd*)	AC_DEFINE(USE_I386_IOPL, 1, [BSD i386 iopl])
+				SYS_LIBS=-lx86_64
+				;;
+		*openbsd*)	AC_DEFINE(USE_AMD64_IOPL, 1, [BSD AMD64 iopl])
+				SYS_LIBS=-lamd64
+				;;
+	esac
+	GLX_ARCH_DEFINES="-D__GLX_ALIGN64"
+	;;
+  ia64*)
+  	GLX_ARCH_DEFINES="-D__GLX_ALIGN64"
+	;;
+  s390*)
+  	GLX_ARCH_DEFINES="-D__GLX_ALIGN64"
+	;;
+esac
+AC_SUBST(GLX_ARCH_DEFINES)
+
+dnl BSD *_video.c selection
+AM_CONDITIONAL(ALPHA_VIDEO, [test "x$ALPHA_VIDEO" = xyes])
+AM_CONDITIONAL(ARM_VIDEO, [test "x$ARM_VIDEO" = xyes])
+AM_CONDITIONAL(I386_VIDEO, [test "x$I386_VIDEO" = xyes])
+AM_CONDITIONAL(PPC_VIDEO, [test "x$PPC_VIDEO" = xyes])
+AM_CONDITIONAL(SPARC64_VIDEO, [test "x$SPARC64_VIDEO" = xyes])
+
+DRI=no
+USE_SIGIO_BY_DEFAULT="yes"
+dnl it would be nice to autodetect these *CONS_SUPPORTs
+case $host_os in
+  *freebsd* | *dragonfly*)
+	case $host_os in
+		kfreebsd*-gnu) ;;
+		*) AC_DEFINE(CSRG_BASED, 1, [System is BSD-like]) ;;
+	esac
+	AC_DEFINE(PCCONS_SUPPORT, 1, [System has PC console])
+	AC_DEFINE(PCVT_SUPPORT, 1, [System has PCVT console])
+	AC_DEFINE(SYSCONS_SUPPORT, 1, [System has syscons console])
+	DRI=yes
+	;;
+  *netbsd*)
+	AC_DEFINE(CSRG_BASED, 1, [System is BSD-like])
+	AC_DEFINE(PCCONS_SUPPORT, 1, [System has PC console])
+	AC_DEFINE(PCVT_SUPPORT, 1, [System has PCVT console])
+	AC_DEFINE(WSCONS_SUPPORT, 1, [System has wscons console])
+	DRI=yes
+	;;
+  *openbsd*)
+	AC_DEFINE(CSRG_BASED, 1, [System is BSD-like])
+	AC_DEFINE(PCVT_SUPPORT, 1, [System has PC console])
+	AC_DEFINE(WSCONS_SUPPORT, 1, [System has wscons console])
+	;;
+  *linux*)
+	DRI=yes
+	;;
+  *solaris*)
+	PKG_CHECK_EXISTS(libdrm, DRI=yes, DRI=no)
+	# Disable use of SIGIO by default until some system bugs are
+	# fixed - see Sun/OpenSolaris bug id 6879897
+	USE_SIGIO_BY_DEFAULT="no"
+	;;
+  darwin*)
+	AC_DEFINE(CSRG_BASED, 1, [System is BSD-like])
+	;;
+  cygwin*|mingw*)
+	CFLAGS="$CFLAGS -DFD_SETSIZE=256"
+	;;
+esac
+
+dnl augment XORG_RELEASE_VERSION for our snapshot number and to expose the
+dnl major number
+PVMAJOR=`echo $PACKAGE_VERSION | cut -d . -f 1`
+PVS=`echo $PACKAGE_VERSION | cut -d . -f 4 | cut -d - -f 1`
+if test "x$PVS" = "x"; then
+	PVS="0"
+fi
+
+VENDOR_RELEASE="((($PVMAJOR) * 10000000) + (($PVM) * 100000) + (($PVP) * 1000) + $PVS)"
+VENDOR_MAN_VERSION="Version ${PACKAGE_VERSION}"
+
+VENDOR_NAME="The X.Org Foundation"
+VENDOR_NAME_SHORT="X.Org"
+VENDOR_WEB="http://wiki.x.org"
+
+m4_ifdef([AS_HELP_STRING], , [m4_define([AS_HELP_STRING], m4_defn([AC_HELP_STRING]))])
+
+dnl Build options.
+AC_ARG_ENABLE(werror,        AS_HELP_STRING([--enable-werror],
+		  [Obsolete - use --enable-strict-compilation instead]),
+  AC_MSG_ERROR([--enable-werror has been replaced by --enable-strict-compilation]))
+
+AC_ARG_ENABLE(debug,         AS_HELP_STRING([--enable-debug],
+				  [Enable debugging (default: disabled)]),
+			        [DEBUGGING=$enableval], [DEBUGGING=no])
+AC_ARG_ENABLE(use-sigio-by-default, AS_HELP_STRING([--enable-use-sigio-by-default]
+  [Enable SIGIO input handlers by default (default: $USE_SIGIO_BY_DEFAULT)]),
+                                [USE_SIGIO_BY_DEFAULT=$enableval], [])
+AC_ARG_WITH(int10,           AS_HELP_STRING([--with-int10=BACKEND], [int10 backend: vm86, x86emu or stub]),
+				[INT10="$withval"],
+				[INT10="$DEFAULT_INT10"])
+AC_ARG_WITH(vendor-name,     AS_HELP_STRING([--with-vendor-name=VENDOR],
+				  [Vendor string reported by the server]),
+				[ VENDOR_NAME="$withval" ], [])
+AC_ARG_WITH(vendor-name-short, AS_HELP_STRING([--with-vendor-name-short=VENDOR],
+				  [Short version of vendor string reported by the server]),
+				[ VENDOR_NAME_SHORT="$withval" ], [])
+AC_ARG_WITH(vendor-web,      AS_HELP_STRING([--with-vendor-web=URL],
+				  [Vendor web address reported by the server]),
+				[ VENDOR_WEB="$withval" ], [])
+AC_ARG_WITH(module-dir,      AS_HELP_STRING([--with-module-dir=DIR],
+				  [Directory where modules are installed (default: $libdir/xorg/modules)]),
+				[ moduledir="$withval" ],
+				[ moduledir="${libdir}/xorg/modules" ])
+AC_ARG_WITH(log-dir,         AS_HELP_STRING([--with-log-dir=DIR],
+				  [Directory where log files are kept (default: $localstatedir/log)]),
+				[ logdir="$withval" ],
+				[ logdir="$localstatedir/log" ])
+AC_ARG_WITH(builder-addr,    AS_HELP_STRING([--with-builder-addr=ADDRESS],
+				  [Builder address (default: xorg@lists.freedesktop.org)]),
+				[ BUILDERADDR="$withval" ],
+				[ BUILDERADDR="xorg@lists.freedesktop.org" ])
+AC_ARG_WITH(os-name,         AS_HELP_STRING([--with-os-name=OSNAME], [Name of OS (default: output of "uname -srm")]),
+				[ OSNAME="$withval" ],
+				[ OSNAME=`uname -srm` ])
+AC_ARG_WITH(os-vendor,       AS_HELP_STRING([--with-os-vendor=OSVENDOR], [Name of OS vendor]),
+				[ OSVENDOR="$withval" ],
+				[ OSVENDOR="" ])
+AC_ARG_WITH(builderstring,   AS_HELP_STRING([--with-builderstring=BUILDERSTRING], [Additional builder string]),
+				[ BUILDERSTRING="$withval" ]
+				[ ])
+
+dnl Determine font path
+XORG_FONTROOTDIR
+XORG_FONTSUBDIR(FONTMISCDIR, fontmiscdir, misc)
+XORG_FONTSUBDIR(FONTOTFDIR, fontotfdir, OTF)
+XORG_FONTSUBDIR(FONTTTFDIR, fontttfdir, TTF)
+XORG_FONTSUBDIR(FONTTYPE1DIR, fonttype1dir, Type1)
+XORG_FONTSUBDIR(FONT75DPIDIR, font75dpidir, 75dpi)
+XORG_FONTSUBDIR(FONT100DPIDIR, font100dpidir, 100dpi)
+
+dnl Uses --default-font-path if set, otherwise checks for /etc/X11/fontpath.d,
+dnl otherwise uses standard subdirectories of FONTROOTDIR. When cross
+dnl compiling, assume default font path uses standard FONTROOTDIR directories.
+DEFAULT_FONT_PATH="${FONTMISCDIR}/,${FONTTTFDIR}/,${FONTOTFDIR}/,${FONTTYPE1DIR}/,${FONT100DPIDIR}/,${FONT75DPIDIR}/"
+if test "$cross_compiling" != yes; then
+	AC_CHECK_FILE([${sysconfdir}/X11/fontpath.d],
+		[DEFAULT_FONT_PATH='catalogue:${sysconfdir}/X11/fontpath.d'],
+		[case $host_os in
+			darwin*) DEFAULT_FONT_PATH="${DEFAULT_FONT_PATH},/Library/Fonts,/System/Library/Fonts" ;;
+		esac])
+fi
+AC_ARG_WITH(default-font-path, AS_HELP_STRING([--with-default-font-path=PATH], [Comma separated list of font dirs]),
+				[ FONTPATH="$withval" ],
+				[ FONTPATH="${DEFAULT_FONT_PATH}" ])
+
+AC_MSG_CHECKING([for default font path])
+AC_MSG_RESULT([$FONTPATH])
+
+AC_ARG_WITH(xkb-path,         AS_HELP_STRING([--with-xkb-path=PATH], [Path to XKB base dir (default: ${datadir}/X11/xkb)]),
+				[ XKBPATH="$withval" ],
+				[ XKBPATH="${datadir}/X11/xkb" ])
+AC_ARG_WITH(xkb-output,       AS_HELP_STRING([--with-xkb-output=PATH], [Path to XKB output dir (default: ${datadir}/X11/xkb/compiled)]),
+				[ XKBOUTPUT="$withval" ],
+				[ XKBOUTPUT="compiled" ])
+AC_ARG_WITH(default-xkb-rules, AS_HELP_STRING([--with-default-xkb-rules=RULES],
+                                   [Keyboard ruleset (default: base/evdev)]),
+                                [ XKB_DFLT_RULES="$withval" ],
+                                [ XKB_DFLT_RULES="" ])
+AC_ARG_WITH(default-xkb-model, AS_HELP_STRING([--with-default-xkb-model=MODEL],
+                                   [Keyboard model (default: pc105)]),
+                                [ XKB_DFLT_MODEL="$withval" ],
+                                [ XKB_DFLT_MODEL="pc105" ])
+AC_ARG_WITH(default-xkb-layout, AS_HELP_STRING([--with-default-xkb-layout=LAYOUT],
+                                   [Keyboard layout (default: us)]),
+                                [ XKB_DFLT_LAYOUT="$withval" ],
+                                [ XKB_DFLT_LAYOUT="us" ])
+AC_ARG_WITH(default-xkb-variant, AS_HELP_STRING([--with-default-xkb-variant=VARIANT],
+                                   [Keyboard variant (default: (none))]),
+                                [ XKB_DFLT_VARIANT="$withval" ],
+                                [ XKB_DFLT_VARIANT="" ])
+AC_ARG_WITH(default-xkb-options, AS_HELP_STRING([--with-default-xkb-options=OPTIONS],
+                                   [Keyboard layout options (default: (none))]),
+                                [ XKB_DFLT_OPTIONS="$withval" ],
+                                [ XKB_DFLT_OPTIONS="" ])
+AC_ARG_WITH(serverconfig-path, AS_HELP_STRING([--with-serverconfig-path=PATH],
+				   [Directory where ancillary server config files are installed (default: ${libdir}/xorg)]),
+				[ SERVERCONFIG="$withval" ],
+				[ SERVERCONFIG="${libdir}/xorg" ])
+AC_ARG_WITH(apple-applications-dir,AS_HELP_STRING([--with-apple-applications-dir=PATH], [Path to the Applications directory (default: /Applications/Utilities)]),
+				[ APPLE_APPLICATIONS_DIR="${withval}" ],
+				[ APPLE_APPLICATIONS_DIR="/Applications/Utilities" ])
+AC_SUBST([APPLE_APPLICATIONS_DIR])
+AC_ARG_WITH(apple-application-name,AS_HELP_STRING([--with-apple-application-name=NAME], [Name for the .app (default: X11)]),
+				[ APPLE_APPLICATION_NAME="${withval}" ],
+				[ APPLE_APPLICATION_NAME="X11" ])
+AC_SUBST([APPLE_APPLICATION_NAME])
+AC_ARG_WITH(launchd-id-prefix,  AS_HELP_STRING([--with-launchd-id-prefix=PATH], [Deprecated: Use --with-bundle-id-prefix.]),
+                                [ BUNDLE_ID_PREFIX="${withval}" ],
+                                [ BUNDLE_ID_PREFIX="org.x" ])
+AC_ARG_WITH(bundle-id-prefix,  AS_HELP_STRING([--with-bundle-id-prefix=PATH], [Prefix to use for bundle identifiers (default: org.x)]),
+                               [ BUNDLE_ID_PREFIX="${withval}" ])
+AC_SUBST([BUNDLE_ID_PREFIX])
+AC_DEFINE_UNQUOTED(BUNDLE_ID_PREFIX, "$BUNDLE_ID_PREFIX", [Prefix to use for bundle identifiers])
+AC_ARG_ENABLE(sparkle,AS_HELP_STRING([--enable-sparkle], [Enable updating of X11.app using the Sparkle Framework (default: disabled)]),
+				[ XQUARTZ_SPARKLE="${enableval}" ],
+				[ XQUARTZ_SPARKLE="no" ])
+AC_SUBST([XQUARTZ_SPARKLE])
+AC_ARG_ENABLE(install-libxf86config,
+				AS_HELP_STRING([--enable-install-libxf86config],
+				[Install libxf86config (default: disabled)]),
+				[INSTALL_LIBXF86CONFIG=$enableval],
+				[INSTALL_LIBXF86CONFIG=no])
+AC_ARG_ENABLE(visibility,     AC_HELP_STRING([--enable-visibility], [Enable symbol visibility (default: auto)]),
+				[SYMBOL_VISIBILITY=$enableval],
+				[SYMBOL_VISIBILITY=auto])
+
+dnl GLX build options
+AC_ARG_ENABLE(aiglx,          AS_HELP_STRING([--enable-aiglx], [Build accelerated indirect GLX (default: enabled)]),
+                                [AIGLX=$enableval],
+                                [AIGLX=yes])
+XORG_TLS
+AC_ARG_ENABLE(glx-tls,        AS_HELP_STRING([--enable-glx-tls], [Build GLX with TLS support (default: auto)]),
+                                [GLX_USE_TLS=$enableval
+                                 if test "x$GLX_USE_TLS" = "xyes" && test "${ac_cv_tls}" = "none" ; then
+                                   AC_MSG_ERROR([GLX with TLS support requested, but the compiler does not support it.])
+                                 fi],
+                                [GLX_USE_TLS=no
+                                 if test "${ac_cv_tls}" != "none" ; then
+                                   GLX_USE_TLS=yes
+                                 fi])
+AC_SUBST(GLX_TLS, ${GLX_USE_TLS})
+AC_ARG_WITH(khronos-spec-dir, AS_HELP_STRING([--with-khronos-spec-dir=PATH], [Path to Khronos OpenGL registry database files (default: auto)]),
+				[KHRONOS_SPEC_DIR="${withval}"],
+				[KHRONOS_SPEC_DIR=auto])
+
+dnl Extensions.
+AC_ARG_ENABLE(registry,       AS_HELP_STRING([--disable-registry], [Build string registry module (default: enabled)]), [XREGISTRY=$enableval], [XREGISTRY=yes])
+AC_ARG_ENABLE(composite,      AS_HELP_STRING([--disable-composite], [Build Composite extension (default: enabled)]), [COMPOSITE=$enableval], [COMPOSITE=yes])
+AC_ARG_ENABLE(mitshm,         AS_HELP_STRING([--disable-mitshm], [Build SHM extension (default: auto)]), [MITSHM=$enableval], [MITSHM=auto])
+AC_ARG_ENABLE(xres,           AS_HELP_STRING([--disable-xres], [Build XRes extension (default: enabled)]), [RES=$enableval], [RES=yes])
+AC_ARG_ENABLE(record,         AS_HELP_STRING([--disable-record], [Build Record extension (default: enabled)]), [RECORD=$enableval], [RECORD=yes])
+AC_ARG_ENABLE(xv,             AS_HELP_STRING([--disable-xv], [Build Xv extension (default: enabled)]), [XV=$enableval], [XV=yes])
+AC_ARG_ENABLE(xvmc,           AS_HELP_STRING([--disable-xvmc], [Build XvMC extension (default: enabled)]), [XVMC=$enableval], [XVMC=yes])
+AC_ARG_ENABLE(dga,            AS_HELP_STRING([--disable-dga], [Build DGA extension (default: auto)]), [DGA=$enableval], [DGA=auto])
+AC_ARG_ENABLE(screensaver,    AS_HELP_STRING([--disable-screensaver], [Build ScreenSaver extension (default: enabled)]), [SCREENSAVER=$enableval], [SCREENSAVER=yes])
+AC_ARG_ENABLE(xdmcp,          AS_HELP_STRING([--disable-xdmcp], [Build XDMCP extension (default: auto)]), [XDMCP=$enableval], [XDMCP=auto])
+AC_ARG_ENABLE(xdm-auth-1,     AS_HELP_STRING([--disable-xdm-auth-1], [Build XDM-Auth-1 extension (default: auto)]), [XDMAUTH=$enableval], [XDMAUTH=auto])
+AC_ARG_ENABLE(glx,            AS_HELP_STRING([--disable-glx], [Build GLX extension (default: enabled)]), [GLX=$enableval], [GLX=yes])
+AC_ARG_ENABLE(dri,            AS_HELP_STRING([--enable-dri], [Build DRI extension (default: auto)]), [DRI=$enableval])
+AC_ARG_ENABLE(dri2,           AS_HELP_STRING([--enable-dri2], [Build DRI2 extension (default: auto)]), [DRI2=$enableval], [DRI2=auto])
+AC_ARG_ENABLE(xinerama,	      AS_HELP_STRING([--disable-xinerama], [Build Xinerama extension (default: enabled)]), [XINERAMA=$enableval], [XINERAMA=yes])
+AC_ARG_ENABLE(xf86vidmode,    AS_HELP_STRING([--disable-xf86vidmode], [Build XF86VidMode extension (default: auto)]), [XF86VIDMODE=$enableval], [XF86VIDMODE=auto])
+AC_ARG_ENABLE(xace,           AS_HELP_STRING([--disable-xace], [Build X-ACE extension (default: enabled)]), [XACE=$enableval], [XACE=yes])
+AC_ARG_ENABLE(xselinux,       AS_HELP_STRING([--enable-xselinux], [Build SELinux extension (default: disabled)]), [XSELINUX=$enableval], [XSELINUX=no])
+AC_ARG_ENABLE(xcsecurity,     AS_HELP_STRING([--enable-xcsecurity], [Build Security extension (default: disabled)]), [XCSECURITY=$enableval], [XCSECURITY=no])
+AC_ARG_ENABLE(tslib,          AS_HELP_STRING([--enable-tslib], [Build kdrive tslib touchscreen support (default: disabled)]), [TSLIB=$enableval], [TSLIB=no])
+AC_ARG_ENABLE(dbe,            AS_HELP_STRING([--disable-dbe], [Build DBE extension (default: enabled)]), [DBE=$enableval], [DBE=yes])
+AC_ARG_ENABLE(xf86bigfont,    AS_HELP_STRING([--enable-xf86bigfont], [Build XF86 Big Font extension (default: disabled)]), [XF86BIGFONT=$enableval], [XF86BIGFONT=no])
+AC_ARG_ENABLE(dpms,           AS_HELP_STRING([--disable-dpms], [Build DPMS extension (default: enabled)]), [DPMSExtension=$enableval], [DPMSExtension=yes])
+AC_ARG_ENABLE(config-udev,    AS_HELP_STRING([--enable-config-udev], [Build udev support (default: auto)]), [CONFIG_UDEV=$enableval], [CONFIG_UDEV=auto])
+AC_ARG_ENABLE(config-udev-kms,    AS_HELP_STRING([--enable-config-udev-kms], [Build udev kms support (default: auto)]), [CONFIG_UDEV_KMS=$enableval], [CONFIG_UDEV_KMS=auto])
+AC_ARG_ENABLE(config-dbus,    AS_HELP_STRING([--enable-config-dbus], [Build D-BUS API support (default: no)]), [CONFIG_DBUS_API=$enableval], [CONFIG_DBUS_API=no])
+AC_ARG_ENABLE(config-hal,     AS_HELP_STRING([--disable-config-hal], [Build HAL support (default: auto)]), [CONFIG_HAL=$enableval], [CONFIG_HAL=auto])
+AC_ARG_ENABLE(config-wscons,  AS_HELP_STRING([--enable-config-wscons], [Build wscons config support (default: auto)]), [CONFIG_WSCONS=$enableval], [CONFIG_WSCONS=auto])
+AC_ARG_ENABLE(xfree86-utils,     AS_HELP_STRING([--enable-xfree86-utils], [Build xfree86 DDX utilities (default: enabled)]), [XF86UTILS=$enableval], [XF86UTILS=yes])
+AC_ARG_ENABLE(vgahw,          AS_HELP_STRING([--enable-vgahw], [Build Xorg with vga access (default: enabled)]), [VGAHW=$enableval], [VGAHW=yes])
+AC_ARG_ENABLE(vbe,            AS_HELP_STRING([--enable-vbe], [Build Xorg with VBE module (default: enabled)]), [VBE=$enableval], [VBE=yes])
+AC_ARG_ENABLE(int10-module,     AS_HELP_STRING([--enable-int10-module], [Build Xorg with int10 module (default: enabled)]), [INT10MODULE=$enableval], [INT10MODULE=yes])
+AC_ARG_ENABLE(windowswm,      AS_HELP_STRING([--enable-windowswm], [Build XWin with WindowsWM extension (default: no)]), [WINDOWSWM=$enableval], [WINDOWSWM=no])
+AC_ARG_ENABLE(libdrm,         AS_HELP_STRING([--enable-libdrm], [Build Xorg with libdrm support (default: enabled)]), [DRM=$enableval],[DRM=yes])
+AC_ARG_ENABLE(clientids,      AS_HELP_STRING([--disable-clientids], [Build Xorg with client ID tracking (default: enabled)]), [CLIENTIDS=$enableval], [CLIENTIDS=yes])
+AC_ARG_ENABLE(pciaccess, AS_HELP_STRING([--enable-pciaccess], [Build Xorg with pciaccess library (default: enabled)]), [PCI=$enableval], [PCI=yes])
+
+dnl DDXes.
+AC_ARG_ENABLE(xorg,    	      AS_HELP_STRING([--enable-xorg], [Build Xorg server (default: auto)]), [XORG=$enableval], [XORG=auto])
+AC_ARG_ENABLE(dmx,    	      AS_HELP_STRING([--enable-dmx], [Build DMX server (default: auto)]), [DMX=$enableval], [DMX=auto])
+AC_ARG_ENABLE(xvfb,    	      AS_HELP_STRING([--enable-xvfb], [Build Xvfb server (default: yes)]), [XVFB=$enableval], [XVFB=yes])
+AC_ARG_ENABLE(xnest,   	      AS_HELP_STRING([--enable-xnest], [Build Xnest server (default: auto)]), [XNEST=$enableval], [XNEST=auto])
+AC_ARG_ENABLE(xquartz,        AS_HELP_STRING([--enable-xquartz], [Build Xquartz server for OS-X (default: auto)]), [XQUARTZ=$enableval], [XQUARTZ=auto])
+AC_ARG_ENABLE(standalone-xpbproxy, AS_HELP_STRING([--enable-standalone-xpbproxy], [Build a standalone xpbproxy (in addition to the one integrated into Xquartz as a separate thread) (default: no)]), [STANDALONE_XPBPROXY=$enableval], [STANDALONE_XPBPROXY=no])
+AC_ARG_ENABLE(xwin,    	      AS_HELP_STRING([--enable-xwin], [Build XWin server (default: auto)]), [XWIN=$enableval], [XWIN=auto])
+dnl kdrive and its subsystems
+AC_ARG_ENABLE(kdrive,         AS_HELP_STRING([--enable-kdrive], [Build kdrive servers (default: no)]), [KDRIVE=$enableval], [KDRIVE=no])
+AC_ARG_ENABLE(xephyr,         AS_HELP_STRING([--enable-xephyr], [Build the kdrive Xephyr server (default: auto)]), [XEPHYR=$enableval], [XEPHYR=auto])
+AC_ARG_ENABLE(xfake,          AS_HELP_STRING([--enable-xfake], [Build the kdrive 'fake' server (default: auto)]), [XFAKE=$enableval], [XFAKE=auto])
+AC_ARG_ENABLE(xfbdev,         AS_HELP_STRING([--enable-xfbdev], [Build the kdrive framebuffer device server (default: auto)]), [XFBDEV=$enableval], [XFBDEV=auto])
+dnl kdrive options
+AC_ARG_ENABLE(kdrive-kbd,     AS_HELP_STRING([--enable-kdrive-kbd], [Build kbd driver for kdrive (default: auto)]), [KDRIVE_KBD=$enableval], [KDRIVE_KBD=auto])
+AC_ARG_ENABLE(kdrive-mouse,   AC_HELP_STRING([--enable-kdrive-mouse], [Build mouse driver for kdrive (default: auto)]), [KDRIVE_MOUSE=$enableval], [KDRIVE_MOUSE=auto])
+AC_ARG_ENABLE(kdrive-evdev,   AC_HELP_STRING([--enable-kdrive-evdev], [Build evdev driver for kdrive (default: auto)]), [KDRIVE_EVDEV=$enableval], [KDRIVE_EVDEV=auto])
+
+
+dnl chown/chmod to be setuid root as part of build
+dnl Replaces InstallXserverSetUID in imake
+AC_ARG_ENABLE(install-setuid, 
+    AS_HELP_STRING([--enable-install-setuid],
+       [Install Xorg server as owned by root with setuid bit (default: auto)]),
+    [SETUID=$enableval], [SETUID=auto])
+AC_MSG_CHECKING([to see if we can install the Xorg server as root])
+if test "x$SETUID" = "xauto" ; then
+	case $host_os in
+	    cygwin*)		SETUID="no"  ;;
+	    mingw*)		SETUID="no"  ;;
+	    darwin*)		SETUID="no"  ;;
+	    *)
+	   	case $host_cpu in
+		    sparc)	SETUID="no"  ;;
+		    *)		SETUID="yes" ;;
+		esac
+	esac
+	if test "x$SETUID" = xyes; then
+		touch testfile
+		chown root testfile > /dev/null 2>&1 || SETUID="no"
+		rm -f testfile
+	fi
+fi
+AC_MSG_RESULT([$SETUID])
+AM_CONDITIONAL(INSTALL_SETUID, [test "x$SETUID" = "xyes"])
+
+dnl Issue an error if xtrans.m4 was not found and XTRANS_CONNECTION_FLAGS macro
+dnl was not expanded, since xorg-server with no transport types is rather useless.
+dnl
+dnl If you're seeing an error here, be sure you installed the lib/xtrans module
+dnl first and if it's not in the default location, that you set the ACLOCAL
+dnl environment variable to find it, such as:
+dnl	ACLOCAL="aclocal -I ${PREFIX}/share/aclocal"
+m4_pattern_forbid([^XTRANS_CONNECTION_FLAGS$])
+
+# Transport selection macro from xtrans.m4
+XTRANS_CONNECTION_FLAGS
+
+# Secure RPC detection macro from xtrans.m4
+XTRANS_SECURE_RPC_FLAGS
+AM_CONDITIONAL(SECURE_RPC, [test "x$SECURE_RPC" = xyes])
+
+AM_CONDITIONAL(INT10_VM86, [test "x$INT10" = xvm86])
+AM_CONDITIONAL(INT10_X86EMU, [test "x$INT10" = xx86emu])
+AM_CONDITIONAL(INT10_STUB, [test "x$INT10" = xstub])
+
+dnl Handle installing libxf86config
+AM_CONDITIONAL(INSTALL_LIBXF86CONFIG, [test "x$INSTALL_LIBXF86CONFIG" = xyes])
+
+dnl DDX Detection... Yes, it's ugly to have it here... but we need to
+dnl handle this early on so that we don't require unsupported extensions
+case $host_os in
+	cygwin* | mingw*)
+		CONFIG_DBUS_API=no
+		CONFIG_HAL=no
+		CONFIG_UDEV=no
+		CONFIG_UDEV_KMS=no
+		DGA=no
+		DRI2=no
+		INT10MODULE=no
+		PCI=no
+		VGAHW=no
+		VBE=no
+		XF86UTILS=no
+		XF86VIDMODE=no
+		XSELINUX=no
+		XV=no
+		SYMBOL_VISIBILITY=no
+		;;
+	darwin*)
+		PCI=no
+		INT10MODULE=no
+		VGAHW=no
+		VBE=no
+		DRM=no
+		DRI2=no
+
+		if test x$XQUARTZ = xauto; then
+			AC_CACHE_CHECK([whether to build Xquartz],xorg_cv_Carbon_framework,[
+		 		save_LDFLAGS=$LDFLAGS
+				LDFLAGS="$LDFLAGS -framework Carbon"
+				AC_LINK_IFELSE([AC_LANG_SOURCE([char FSFindFolder(); int main() { FSFindFolder(); return 0;}])],
+				               [xorg_cv_Carbon_framework=yes],
+				               [xorg_cv_Carbon_framework=no])
+			        LDFLAGS=$save_LDFLAGS])
+                
+			if test "X$xorg_cv_Carbon_framework" = Xyes; then
+				XQUARTZ=yes
+			else
+				XQUARTZ=no
+			fi
+		fi
+
+		AC_CHECK_FUNC(dispatch_async,
+		              AC_DEFINE([HAVE_LIBDISPATCH], 1, [Define to 1 if you have the libdispatch (GCD) available]),
+		              [])
+
+		if test "x$XQUARTZ" = xyes ; then
+			XQUARTZ=yes
+			XVFB=no
+			XNEST=no
+
+			COMPOSITE=no
+			DGA=no
+			DPMSExtension=no
+			XF86VIDMODE=no
+		fi
+		;;
+	*) XQUARTZ=no ;;
+esac
+
+dnl ---------------------------------------------------------------------------
+dnl Extension section
+dnl ---------------------------------------------------------------------------
+XEXT_INC='-I$(top_srcdir)/Xext'
+XEXT_LIB='$(top_builddir)/Xext/libXext.la'
+
+dnl Optional modules
+VIDEOPROTO="videoproto"
+COMPOSITEPROTO="compositeproto >= 0.4"
+RECORDPROTO="recordproto >= 1.13.99.1"
+SCRNSAVERPROTO="scrnsaverproto >= 1.1"
+RESOURCEPROTO="resourceproto >= 1.2.0"
+DRIPROTO="xf86driproto >= 2.1.0"
+DRI2PROTO="dri2proto >= 2.8"
+XINERAMAPROTO="xineramaproto"
+BIGFONTPROTO="xf86bigfontproto >= 1.2.0"
+DGAPROTO="xf86dgaproto >= 2.0.99.1"
+GLPROTO="glproto >= 1.4.16"
+DMXPROTO="dmxproto >= 2.2.99.1"
+VIDMODEPROTO="xf86vidmodeproto >= 2.2.99.1"
+WINDOWSWMPROTO="windowswmproto"
+APPLEWMPROTO="applewmproto >= 1.4"
+
+dnl Required modules
+XPROTO="xproto >= 7.0.22"
+RANDRPROTO="randrproto >= 1.4.0"
+RENDERPROTO="renderproto >= 0.11"
+XEXTPROTO="xextproto >= 7.1.99"
+INPUTPROTO="inputproto >= 2.3"
+KBPROTO="kbproto >= 1.0.3"
+FONTSPROTO="fontsproto"
+FIXESPROTO="fixesproto >= 5.0"
+DAMAGEPROTO="damageproto >= 1.1"
+XCMISCPROTO="xcmiscproto >= 1.2.0"
+BIGREQSPROTO="bigreqsproto >= 1.1.0"
+XTRANS="xtrans >= 1.2.7"
+
+dnl List of libraries that require a specific version
+LIBAPPLEWM="applewm >= 1.4"
+LIBDMX="dmx >= 1.0.99.1"
+LIBDRI="dri >= 7.8.0"
+LIBDRM="libdrm >= 2.3.0"
+LIBGL="gl >= 7.1.0"
+LIBXEXT="xext >= 1.0.99.4"
+LIBXFONT="xfont >= 1.4.2"
+LIBXI="xi >= 1.2.99.1"
+LIBXTST="xtst >= 1.0.99.2"
+LIBPCIACCESS="pciaccess >= 0.12.901"
+LIBUDEV="libudev >= 143"
+LIBSELINUX="libselinux >= 2.0.86"
+LIBDBUS="dbus-1 >= 1.0"
+LIBPIXMAN="pixman-1 >= 0.27.2"
+
+dnl Pixman is always required, but we separate it out so we can link
+dnl specific modules against it
+PKG_CHECK_MODULES(PIXMAN, $LIBPIXMAN)
+REQUIRED_LIBS="$REQUIRED_LIBS $LIBPIXMAN $LIBXFONT xau"
+
+dnl Core modules for most extensions, et al.
+SDK_REQUIRED_MODULES="$XPROTO $RANDRPROTO $RENDERPROTO $XEXTPROTO $INPUTPROTO $KBPROTO $FONTSPROTO $LIBPIXMAN"
+# Make SDK_REQUIRED_MODULES available for inclusion in xorg-server.pc
+AC_SUBST(SDK_REQUIRED_MODULES)
+
+REQUIRED_MODULES="$FIXESPROTO $DAMAGEPROTO $XCMISCPROTO $XTRANS $BIGREQSPROTO $SDK_REQUIRED_MODULES"
+
+if test "x$CONFIG_UDEV" = xyes &&
+ { test "x$CONFIG_DBUS_API" = xyes || test "x$CONFIG_HAL" = xyes; }; then
+	AC_MSG_ERROR([Hotplugging through both libudev and dbus/hal not allowed])
+fi
+
+PKG_CHECK_MODULES(UDEV, $LIBUDEV, [HAVE_LIBUDEV=yes], [HAVE_LIBUDEV=no])
+if test "x$CONFIG_UDEV" = xauto; then
+	CONFIG_UDEV="$HAVE_LIBUDEV"
+fi
+AM_CONDITIONAL(CONFIG_UDEV, [test "x$CONFIG_UDEV" = xyes])
+if test "x$CONFIG_UDEV" = xyes; then
+	CONFIG_DBUS_API=no
+	CONFIG_HAL=no
+	if test "x$CONFIG_UDEV_KMS" = xauto; then
+		CONFIG_UDEV_KMS="$HAVE_LIBUDEV"
+	fi
+	if ! test "x$HAVE_LIBUDEV" = xyes; then
+		AC_MSG_ERROR([udev configuration API requested, but libudev is not installed])
+	fi
+	AC_DEFINE(CONFIG_UDEV, 1, [Use libudev for input hotplug])
+	if test "x$CONFIG_UDEV_KMS" = xyes; then
+		AC_DEFINE(CONFIG_UDEV_KMS, 1, [Use libudev for kms enumeration])
+	fi
+	SAVE_LIBS=$LIBS
+	SAVE_CFLAGS=$CFLAGS
+	CFLAGS=$UDEV_CFLAGS
+	LIBS=$UDEV_LIBS
+	AC_CHECK_FUNCS([udev_monitor_filter_add_match_tag])
+	AC_CHECK_FUNCS([udev_enumerate_add_match_tag])
+	LIBS=$SAVE_LIBS
+	CFLAGS=$SAVE_CFLAGS
+fi
+AM_CONDITIONAL(CONFIG_UDEV_KMS, [test "x$CONFIG_UDEV_KMS" = xyes])
+
+dnl HAVE_DBUS is true if we actually have the D-Bus library, whereas
+dnl CONFIG_DBUS_API is true if we want to enable the D-Bus config
+dnl API.
+PKG_CHECK_MODULES(DBUS, $LIBDBUS, [HAVE_DBUS=yes], [HAVE_DBUS=no])
+if test "x$HAVE_DBUS" = xyes; then
+	AC_DEFINE(HAVE_DBUS, 1, [Have D-Bus support])
+fi
+AM_CONDITIONAL(HAVE_DBUS, [test "x$HAVE_DBUS" = xyes])
+
+if test "x$CONFIG_DBUS_API" = xauto; then
+	CONFIG_DBUS_API="$HAVE_DBUS"
+fi
+if test "x$CONFIG_DBUS_API" = xyes; then
+	if ! test "x$HAVE_DBUS" = xyes; then
+		AC_MSG_ERROR([D-Bus configuration API requested, but D-Bus is not installed.])
+	fi
+
+	AC_DEFINE(CONFIG_DBUS_API, 1, [Use the D-Bus input configuration API])
+	CONFIG_NEED_DBUS="yes"
+fi
+AM_CONDITIONAL(CONFIG_DBUS_API, [test "x$CONFIG_DBUS_API" = xyes])
+
+PKG_CHECK_MODULES(HAL, hal, [HAVE_HAL=yes], [HAVE_HAL=no])
+if test "x$CONFIG_HAL" = xauto; then
+	CONFIG_HAL="$HAVE_HAL"
+fi
+if test "x$CONFIG_HAL" = xyes; then
+	if ! test "x$HAVE_HAL" = xyes; then
+		AC_MSG_ERROR([HAL hotplug API requested, but HAL is not installed.])
+	fi
+
+	AC_DEFINE(CONFIG_HAL, 1, [Use the HAL hotplug API])
+	CONFIG_NEED_DBUS="yes"
+fi
+AM_CONDITIONAL(CONFIG_HAL, [test "x$CONFIG_HAL" = xyes])
+
+if test "x$CONFIG_NEED_DBUS" = xyes; then
+        AC_DEFINE(CONFIG_NEED_DBUS, 1, [Use D-Bus for input hotplug])
+fi
+AM_CONDITIONAL(CONFIG_NEED_DBUS, [test "x$CONFIG_NEED_DBUS" = xyes])
+
+if test "x$CONFIG_WSCONS" = xauto; then
+	case $host_os in
+		*openbsd*)
+			CONFIG_WSCONS=yes;
+			;;
+		*)
+			CONFIG_WSCONS=no;
+			;;
+	esac
+fi
+AM_CONDITIONAL(CONFIG_WSCONS, [test "x$CONFIG_WSCONS" = xyes])
+if test "x$CONFIG_WSCONS" = xyes; then
+	AC_DEFINE(CONFIG_WSCONS, 1, [Use wscons for input auto configuration])
+fi
+
+if test "x$USE_SIGIO_BY_DEFAULT" = xyes; then
+	USE_SIGIO_BY_DEFAULT_VALUE=TRUE
+else
+	USE_SIGIO_BY_DEFAULT_VALUE=FALSE
+fi
+AC_DEFINE_UNQUOTED([USE_SIGIO_BY_DEFAULT], [$USE_SIGIO_BY_DEFAULT_VALUE],
+		   [Use SIGIO handlers for input device events by default])
+
+AC_MSG_CHECKING([for glibc...])
+AC_PREPROC_IFELSE([AC_LANG_SOURCE([
+#include <features.h>
+#ifndef __GLIBC__
+#error
+#endif
+])], glibc=yes, glibc=no)
+AC_MSG_RESULT([$glibc])
+
+AC_CHECK_FUNCS([clock_gettime], [have_clock_gettime=yes],
+               [AC_CHECK_LIB([rt], [clock_gettime], [have_clock_gettime=-lrt],
+                             [have_clock_gettime=no])])
+
+AC_MSG_CHECKING([for a useful monotonic clock ...])
+
+if ! test "x$have_clock_gettime" = xno; then
+    if ! test "x$have_clock_gettime" = xyes; then
+        CLOCK_LIBS="$have_clock_gettime"
+    else
+        CLOCK_LIBS=""
+    fi
+
+    LIBS_SAVE="$LIBS"
+    LIBS="$CLOCK_LIBS"
+    CPPFLAGS_SAVE="$CPPFLAGS"
+
+    if test x"$glibc" = xyes; then
+        CPPFLAGS="$CPPFLAGS -D_POSIX_C_SOURCE=200112L"
+    fi
+
+    AC_RUN_IFELSE([AC_LANG_SOURCE([
+#include <time.h>
+
+int main(int argc, char *argv[[]]) {
+    struct timespec tp;
+
+    if (clock_gettime(CLOCK_MONOTONIC, &tp) == 0)
+        return 0;
+    else
+        return 1;
+}
+    ])], [MONOTONIC_CLOCK=yes], [MONOTONIC_CLOCK=no],
+       [MONOTONIC_CLOCK="cross compiling"])
+
+    LIBS="$LIBS_SAVE"
+    CPPFLAGS="$CPPFLAGS_SAVE"
+else
+    MONOTONIC_CLOCK=no
+fi
+
+AC_MSG_RESULT([$MONOTONIC_CLOCK])
+
+if test "x$MONOTONIC_CLOCK" = xyes; then
+    AC_DEFINE(MONOTONIC_CLOCK, 1, [Have monotonic clock from clock_gettime()])
+    LIBS="$LIBS $CLOCK_LIBS"
+fi
+
+AM_CONDITIONAL(XV, [test "x$XV" = xyes])
+if test "x$XV" = xyes; then
+	AC_DEFINE(XV, 1, [Support Xv extension])
+	AC_DEFINE(XvExtension, 1, [Build Xv extension])
+	REQUIRED_MODULES="$REQUIRED_MODULES $VIDEOPROTO"
+	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $VIDEOPROTO"
+else
+	XVMC=no
+fi
+
+AM_CONDITIONAL(XVMC, [test "x$XVMC" = xyes])
+if test "x$XVMC" = xyes; then
+	AC_DEFINE(XvMCExtension, 1, [Build XvMC extension])
+fi
+
+AM_CONDITIONAL(XREGISTRY, [test "x$XREGISTRY" = xyes])
+if test "x$XREGISTRY" = xyes; then
+	AC_DEFINE(XREGISTRY, 1, [Build registry module])
+fi
+
+AM_CONDITIONAL(COMPOSITE, [test "x$COMPOSITE" = xyes])
+if test "x$COMPOSITE" = xyes; then
+	AC_DEFINE(COMPOSITE, 1, [Support Composite Extension])
+	REQUIRED_MODULES="$REQUIRED_MODULES $COMPOSITEPROTO"
+	COMPOSITE_LIB='$(top_builddir)/composite/libcomposite.la'
+	COMPOSITE_INC='-I$(top_srcdir)/composite'
+fi
+
+if test "x$MITSHM" = xauto; then
+	MITSHM="$ac_cv_sysv_ipc"
+fi
+AM_CONDITIONAL(MITSHM, [test "x$MITSHM" = xyes])
+if test "x$MITSHM" = xyes; then
+	AC_DEFINE(MITSHM, 1, [Support MIT-SHM extension])
+	AC_DEFINE(HAS_SHM, 1, [Support SHM])
+fi
+
+AM_CONDITIONAL(RECORD, [test "x$RECORD" = xyes])
+if test "x$RECORD" = xyes; then
+	AC_DEFINE(XRECORD, 1, [Support Record extension])
+	REQUIRED_MODULES="$REQUIRED_MODULES $RECORDPROTO"
+	RECORD_LIB='$(top_builddir)/record/librecord.la'
+fi
+
+AM_CONDITIONAL(SCREENSAVER, [test "x$SCREENSAVER" = xyes])
+if test "x$SCREENSAVER" = xyes; then
+	AC_DEFINE(SCREENSAVER, 1, [Support MIT-SCREEN-SAVER extension])
+	REQUIRED_MODULES="$REQUIRED_MODULES $SCRNSAVERPROTO"
+fi
+
+AM_CONDITIONAL(RES, [test "x$RES" = xyes])
+if test "x$RES" = xyes; then
+	AC_DEFINE(RES, 1, [Support X resource extension])
+	REQUIRED_MODULES="$REQUIRED_MODULES $RESOURCEPROTO"
+fi
+
+# The XRes extension may support client ID tracking only if it has
+# been specifically enabled. Client ID tracking is implicitly not
+# supported if XRes extension is disabled.
+AC_MSG_CHECKING([whether to track client ids])
+if test "x$RES" = xyes && test "x$CLIENTIDS" = xyes; then
+	AC_DEFINE(CLIENTIDS, 1, [Support client ID tracking])
+else
+	CLIENTIDS=no
+fi
+if test "x$CLIENTIDS" = xyes; then
+	case $host_os in
+	openbsd*)
+		SYS_LIBS="$SYS_LIBS -lkvm"
+	;;
+	esac
+fi
+AC_MSG_RESULT([$CLIENTIDS])
+AM_CONDITIONAL(CLIENTIDS, [test "x$CLIENTIDS" = xyes])
+
+if test "x$GLX" = xyes; then
+	PKG_CHECK_MODULES([XLIB], [x11])
+	PKG_CHECK_MODULES([GL], $GLPROTO $LIBGL)
+	AC_SUBST(XLIB_CFLAGS)
+	AC_DEFINE(GLXEXT, 1, [Build GLX extension])
+	GLX_LIBS='$(top_builddir)/glx/libglx.la'
+	GLX_SYS_LIBS="$GLX_SYS_LIBS"
+else
+        GLX=no
+fi
+AM_CONDITIONAL(GLX, test "x$GLX" = xyes)
+
+if test "x$GLX" = xno; then
+        AIGLX=no
+fi
+
+if test "x$AIGLX" = xyes -a \( "x$DRI" = xyes -o "x$DRI2" = xyes \); then
+	AC_DEFINE(AIGLX, 1, [Build AIGLX loader])
+fi
+AM_CONDITIONAL(AIGLX_DRI_LOADER, { test "x$DRI" = xyes || test "x$DRI2" = xyes; } && test "x$AIGLX" = xyes)
+
+if test "x$GLX_USE_TLS" = xyes ; then
+	GLX_DEFINES="-DGLX_USE_TLS -DPTHREADS"
+	GLX_SYS_LIBS="$GLX_SYS_LIBS -lpthread"
+fi
+AC_SUBST([GLX_DEFINES])
+AC_SUBST([GLX_SYS_LIBS])
+
+AM_CONDITIONAL(DRI, test "x$DRI" = xyes)
+if test "x$DRI" = xyes; then
+	AC_DEFINE(XF86DRI, 1, [Build DRI extension])
+	REQUIRED_MODULES="$REQUIRED_MODULES $DRIPROTO $GLPROTO $LIBDRI"
+	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $DRIPROTO $GLPROTO $LIBDRI"
+fi
+
+PKG_CHECK_MODULES([DRI2PROTO], $DRI2PROTO,
+                  [HAVE_DRI2PROTO=yes], [HAVE_DRI2PROTO=no])
+case "$DRI2,$HAVE_DRI2PROTO" in
+	yes,no)
+		AC_MSG_ERROR([DRI2 requested, but dri2proto not found.])
+		;;
+	yes,yes | auto,yes)
+		AC_DEFINE(DRI2, 1, [Build DRI2 extension])
+		DRI2=yes
+		SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $DRI2PROTO"
+		;;
+esac
+AM_CONDITIONAL(DRI2, test "x$DRI2" = xyes)
+
+if test "x$DRI" = xyes || test "x$DRI2" = xyes || test "x$CONFIG_UDEV_KMS" = xyes; then
+	if test "x$DRM" = xyes; then
+		AC_DEFINE(WITH_LIBDRM, 1, [Building with libdrm support])
+		PKG_CHECK_MODULES([LIBDRM], $LIBDRM)
+	fi
+fi
+
+if test "x$DRI2" = xyes; then
+	save_CFLAGS=$CFLAGS
+	CFLAGS="$GL_CFLAGS $LIBDRM_CFLAGS"
+	AC_COMPILE_IFELSE([AC_LANG_SOURCE([[#include <GL/gl.h>
+#include <GL/internal/dri_interface.h>
+#ifndef __DRI_DRI2
+#error DRI2 extension not available.
+#endif]])],
+			  [HAVE_DRI2EXTENSION=yes],
+			  [HAVE_DRI2EXTENSION=no])
+	CFLAGS=$save_CFLAGS
+	if test "x$HAVE_DRI2EXTENSION" = xyes; then
+		AC_DEFINE(DRI2_AIGLX, 1, [Build DRI2 AIGLX loader])
+		DRI2_AIGLX=yes
+	else
+		AC_MSG_NOTICE([DRI2 AIGLX disabled, __DRI_DRI2 not defined in dri_interface.h.])
+		DRI2_AIGLX=no
+	fi
+fi
+AM_CONDITIONAL(DRI2_AIGLX, test "x$DRI2_AIGLX" = xyes)
+
+
+AM_CONDITIONAL(XINERAMA, [test "x$XINERAMA" = xyes])
+if test "x$XINERAMA" = xyes; then
+	AC_DEFINE(XINERAMA, 1, [Support Xinerama extension])
+	AC_DEFINE(PANORAMIX, 1, [Internal define for Xinerama])
+	REQUIRED_MODULES="$REQUIRED_MODULES $XINERAMAPROTO"
+	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $XINERAMAPROTO"
+fi
+
+AM_CONDITIONAL(XACE, [test "x$XACE" = xyes])
+if test "x$XACE" = xyes; then
+	AC_DEFINE(XACE, 1, [Build X-ACE extension])
+fi
+
+AM_CONDITIONAL(XSELINUX, [test "x$XSELINUX" = xyes])
+if test "x$XSELINUX" = xyes; then
+	if test "x$XACE" != xyes; then
+		AC_MSG_ERROR([cannot build SELinux extension without X-ACE])
+	fi
+	AC_CHECK_HEADERS([libaudit.h], [], AC_MSG_ERROR([SELinux extension requires audit system headers]))
+	AC_CHECK_LIB(audit, audit_open, [], AC_MSG_ERROR([SELinux extension requires audit system library]))
+	PKG_CHECK_MODULES([SELINUX], $LIBSELINUX)
+	SELINUX_LIBS="$SELINUX_LIBS -laudit"
+	AC_DEFINE(XSELINUX, 1, [Build SELinux extension])
+fi
+
+AM_CONDITIONAL(XCSECURITY, [test "x$XCSECURITY" = xyes])
+if test "x$XCSECURITY" = xyes; then
+	if test "x$XACE" != xyes; then
+		AC_MSG_ERROR([cannot build Security extension without X-ACE])
+	fi
+	AC_DEFINE(XCSECURITY, 1, [Build Security extension])
+fi
+
+AM_CONDITIONAL(DBE, [test "x$DBE" = xyes])
+if test "x$DBE" = xyes; then
+	AC_DEFINE(DBE, 1, [Support DBE extension])
+	DBE_LIB='$(top_builddir)/dbe/libdbe.la'
+	DBE_INC='-I$(top_srcdir)/dbe'
+fi
+
+AM_CONDITIONAL(XF86BIGFONT, [test "x$XF86BIGFONT" = xyes])
+if test "x$XF86BIGFONT" = xyes; then
+	AC_DEFINE(XF86BIGFONT, 1, [Support XF86 Big font extension])
+	REQUIRED_MODULES="$REQUIRED_MODULES $BIGFONTPROTO"
+fi
+
+AM_CONDITIONAL(DPMSExtension, [test "x$DPMSExtension" = xyes])
+if test "x$DPMSExtension" = xyes; then
+	AC_DEFINE(DPMSExtension, 1, [Support DPMS extension])
+fi
+
+AC_DEFINE(RENDER, 1, [Support RENDER extension])
+RENDER_LIB='$(top_builddir)/render/librender.la'
+RENDER_INC='-I$(top_srcdir)/render'
+
+AC_DEFINE(RANDR, 1, [Support RANDR extension])
+RANDR_LIB='$(top_builddir)/randr/librandr.la'
+RANDR_INC='-I$(top_srcdir)/randr'
+
+AC_DEFINE(XFIXES,1,[Support XFixes extension])
+FIXES_LIB='$(top_builddir)/xfixes/libxfixes.la'
+FIXES_INC='-I$(top_srcdir)/xfixes'
+
+AC_DEFINE(DAMAGE,1,[Support Damage extension])
+DAMAGE_LIB='$(top_builddir)/damageext/libdamageext.la'
+DAMAGE_INC='-I$(top_srcdir)/damageext'
+MIEXT_DAMAGE_LIB='$(top_builddir)/miext/damage/libdamage.la'
+MIEXT_DAMAGE_INC='-I$(top_srcdir)/miext/damage'
+
+# XINPUT extension is integral part of the server
+AC_DEFINE(XINPUT, 1, [Support X Input extension])
+XI_LIB='$(top_builddir)/Xi/libXi.la'
+XI_INC='-I$(top_srcdir)/Xi'
+
+AM_CONDITIONAL(XF86UTILS, test "x$XF86UTILS" = xyes)
+AM_CONDITIONAL(VGAHW, test "x$VGAHW" = xyes)
+AM_CONDITIONAL(VBE, test "x$VBE" = xyes)
+AM_CONDITIONAL(INT10MODULE, test "x$INT10MODULE" = xyes)
+
+AC_DEFINE(SHAPE, 1, [Support SHAPE extension])
+
+AC_DEFINE_DIR(XKB_BASE_DIRECTORY, XKBPATH, [Path to XKB data])
+AC_ARG_WITH(xkb-bin-directory,
+				AS_HELP_STRING([--with-xkb-bin-directory=DIR], [Directory containing xkbcomp program]),
+				[XKB_BIN_DIRECTORY="$withval"],
+				[XKB_BIN_DIRECTORY="$bindir"])
+
+AC_DEFINE_DIR(XKB_BIN_DIRECTORY, XKB_BIN_DIRECTORY, [Path to XKB bin dir])
+
+dnl Make sure XKM_OUTPUT_DIR is an absolute path
+XKBOUTPUT_FIRSTCHAR=`echo $XKBOUTPUT | cut -b 1`
+if [[ x$XKBOUTPUT_FIRSTCHAR != x/ -a x$XKBOUTPUT_FIRSTCHAR != 'x$' ]] ; then
+   XKBOUTPUT="$XKB_BASE_DIRECTORY/$XKBOUTPUT"
+fi
+
+dnl XKM_OUTPUT_DIR (used in code) must end in / or file names get hosed
+dnl XKB_COMPILED_DIR (used in Makefiles) must not or install-sh gets confused
+
+XKBOUTPUT=`echo $XKBOUTPUT/ | $SED 's|/*$|/|'`
+XKB_COMPILED_DIR=`echo $XKBOUTPUT | $SED 's|/*$||'`
+AC_DEFINE_DIR(XKM_OUTPUT_DIR, XKBOUTPUT, [Path to XKB output dir])
+AC_SUBST(XKB_COMPILED_DIR)
+
+if test "x$XKB_DFLT_RULES" = x; then
+    case $host_os in
+    linux*)
+        dnl doesn't take AutoAddDevices into account, but whatever.
+        XKB_DFLT_RULES="evdev"
+        ;;
+    *)
+        XKB_DFLT_RULES="base"
+        ;;
+    esac
+fi
+AC_DEFINE_UNQUOTED(XKB_DFLT_RULES, ["$XKB_DFLT_RULES"], [Default XKB ruleset])
+AC_DEFINE_UNQUOTED(XKB_DFLT_MODEL, ["$XKB_DFLT_MODEL"], [Default XKB model])
+AC_DEFINE_UNQUOTED(XKB_DFLT_LAYOUT, ["$XKB_DFLT_LAYOUT"], [Default XKB layout])
+AC_DEFINE_UNQUOTED(XKB_DFLT_VARIANT, ["$XKB_DFLT_VARIANT"], [Default XKB variant])
+AC_DEFINE_UNQUOTED(XKB_DFLT_OPTIONS, ["$XKB_DFLT_OPTIONS"], [Default XKB options])
+AC_SUBST([XKB_DFLT_RULES])
+AC_SUBST([XKB_DFLT_MODEL])
+AC_SUBST([XKB_DFLT_LAYOUT])
+AC_SUBST([XKB_DFLT_VARIANT])
+AC_SUBST([XKB_DFLT_OPTIONS])
+
+XKB_LIB='$(top_builddir)/xkb/libxkb.la'
+XKB_STUB_LIB='$(top_builddir)/xkb/libxkbstubs.la'
+REQUIRED_MODULES="$REQUIRED_MODULES xkbfile"
+
+PKG_CHECK_MODULES([XDMCP], [xdmcp], [have_libxdmcp="yes"], [have_libxdmcp="no"])
+if test "x$have_libxdmcp" = xyes; then
+	AC_CHECK_LIB(Xdmcp, XdmcpWrap, [have_xdmcpwrap="yes"], [have_xdmcpwrap="no"], [$XDMCP_LIBS])
+fi
+if test "x$XDMCP" = xauto; then
+	if test "x$have_libxdmcp" = xyes; then
+		XDMCP=yes
+	else
+		XDMCP=no
+	fi
+fi
+if test "x$XDMAUTH" = xauto; then
+	if test "x$have_libxdmcp" = xyes && test "x$have_xdmcpwrap" = xyes; then
+		XDMAUTH=yes
+	else
+		XDMAUTH=no
+	fi
+fi
+
+AM_CONDITIONAL(XDMCP, [test "x$XDMCP" = xyes])
+if test "x$XDMCP" = xyes; then
+	AC_DEFINE(XDMCP, 1, [Support XDM Control Protocol])
+	REQUIRED_LIBS="$REQUIRED_LIBS xdmcp"
+	XDMCP_MODULES="xdmcp"
+fi
+
+AM_CONDITIONAL(XDMAUTH, [test "x$XDMAUTH" = xyes])
+if test "x$XDMAUTH" = xyes; then
+	AC_DEFINE(HASXDMAUTH,1,[Support XDM-AUTH*-1])
+	if ! test "x$XDMCP" = xyes; then
+		REQUIRED_LIBS="$REQUIRED_LIBS xdmcp"
+		XDMCP_MODULES="xdmcp"
+	fi
+fi
+
+AC_DEFINE_DIR(COMPILEDDEFAULTFONTPATH, FONTPATH, [Default font path])
+AC_DEFINE_DIR(SERVER_MISC_CONFIG_PATH, SERVERCONFIG, [Server miscellaneous config path])
+AC_DEFINE_DIR(BASE_FONT_PATH, FONTROOTDIR, [Default base font path])
+dridriverdir=`$PKG_CONFIG --variable=dridriverdir dri`
+AC_DEFINE_DIR(DRI_DRIVER_PATH, dridriverdir, [Default DRI driver path])
+AC_DEFINE_UNQUOTED(XVENDORNAME, ["$VENDOR_NAME"], [Vendor name])
+AC_DEFINE_UNQUOTED(XVENDORNAMESHORT, ["$VENDOR_NAME_SHORT"], [Short vendor name])
+AC_DEFINE_UNQUOTED(XORG_DATE, ["$RELEASE_DATE"], [Vendor release])
+AC_DEFINE_UNQUOTED(XORG_MAN_VERSION, ["$VENDOR_MAN_VERSION"], [Vendor man version])
+AC_DEFINE_UNQUOTED(BUILDERADDR, ["$BUILDERADDR"], [Builder address])
+
+if test -z "$OSNAME"; then
+    OSNAME="UNKNOWN"
+fi
+
+AC_DEFINE_UNQUOTED(OSNAME, ["$OSNAME"], [Operating System Name])
+AC_DEFINE_UNQUOTED(OSVENDOR, ["$OSVENDOR"], [Operating System Vendor])
+AC_DEFINE_UNQUOTED(BUILDERSTRING, ["$BUILDERSTRING"], [Builder string])
+
+AC_SUBST([VENDOR_NAME_SHORT])
+AC_DEFINE_UNQUOTED(VENDOR_NAME, ["$VENDOR_NAME"], [Vendor name])
+AC_DEFINE_UNQUOTED(VENDOR_NAME_SHORT, ["$VENDOR_NAME_SHORT"], [Vendor name])
+AC_DEFINE_UNQUOTED(VENDOR_RELEASE, [$VENDOR_RELEASE], [Vendor release])
+AC_DEFINE_UNQUOTED(VENDOR_MAN_VERSION, ["$VENDOR_MAN_VERSION"], [Vendor man version])
+
+AC_DEFINE(NO_LIBCWRAPPER, 1, [Define to 1 if modules should avoid the libcwrapper])
+
+if test "x$DEBUGGING" = xyes; then
+       AC_DEFINE(DEBUG, 1, [Enable debugging code])
+fi
+AM_CONDITIONAL(DEBUG, [test "x$DEBUGGING" = xyes])
+
+AC_DEFINE(XTEST, 1, [Support XTest extension])
+AC_DEFINE(XSYNC, 1, [Support XSync extension])
+AC_DEFINE(XCMISC, 1, [Support XCMisc extension])
+AC_DEFINE(BIGREQS, 1, [Support BigRequests extension])
+
+if test "x$SPECIAL_DTRACE_OBJECTS" = "xyes" ; then
+  DIX_LIB='$(top_builddir)/dix/dix.O'
+  OS_LIB='$(top_builddir)/os/os.O $(SHA1_LIBS) $(DLOPEN_LIBS) $(LIBUNWIND_LIBS)'
+else
+  DIX_LIB='$(top_builddir)/dix/libdix.la'
+  OS_LIB='$(top_builddir)/os/libos.la'
+fi
+AC_SUBST([DIX_LIB])
+AC_SUBST([OS_LIB])
+
+MAIN_LIB='$(top_builddir)/dix/libmain.la'
+AC_SUBST([MAIN_LIB])
+
+MI_LIB='$(top_builddir)/mi/libmi.la'
+MI_EXT_LIB='$(top_builddir)/mi/libmiext.la'
+MI_INC='-I$(top_srcdir)/mi'
+FB_LIB='$(top_builddir)/fb/libfb.la'
+FB_INC='-I$(top_srcdir)/fb'
+MIEXT_SHADOW_INC='-I$(top_srcdir)/miext/shadow'
+MIEXT_SHADOW_LIB='$(top_builddir)/miext/shadow/libshadow.la'
+MIEXT_SYNC_INC='-I$(top_srcdir)/miext/sync'
+MIEXT_SYNC_LIB='$(top_builddir)/miext/sync/libsync.la'
+CORE_INCS='-I$(top_srcdir)/include -I$(top_builddir)/include'
+
+# SHA1 hashing
+AC_ARG_WITH([sha1],
+            [AS_HELP_STRING([--with-sha1=libc|libmd|libnettle|libgcrypt|libcrypto|libsha1|CommonCrypto|CryptoAPI],
+                            [choose SHA1 implementation])])
+AC_CHECK_FUNC([SHA1Init], [HAVE_SHA1_IN_LIBC=yes])
+if test "x$with_sha1" = x && test "x$HAVE_SHA1_IN_LIBC" = xyes; then
+	with_sha1=libc
+fi
+if test "x$with_sha1" = xlibc && test "x$HAVE_SHA1_IN_LIBC" != xyes; then
+	AC_MSG_ERROR([libc requested but not found])
+fi
+if test "x$with_sha1" = xlibc; then
+	AC_DEFINE([HAVE_SHA1_IN_LIBC], [1],
+		[Use libc SHA1 functions])
+	SHA1_LIBS=""
+fi
+AC_CHECK_FUNC([CC_SHA1_Init], [HAVE_SHA1_IN_COMMONCRYPTO=yes])
+if test "x$with_sha1" = x && test "x$HAVE_SHA1_IN_COMMONCRYPTO" = xyes; then
+	with_sha1=CommonCrypto
+fi
+if test "x$with_sha1" = xCommonCrypto && test "x$HAVE_SHA1_IN_COMMONCRYPTO" != xyes; then
+	AC_MSG_ERROR([CommonCrypto requested but not found])
+fi
+if test "x$with_sha1" = xCommonCrypto; then
+	AC_DEFINE([HAVE_SHA1_IN_COMMONCRYPTO], [1],
+		[Use CommonCrypto SHA1 functions])
+	SHA1_LIBS=""
+fi
+dnl stdcall functions cannot be tested with AC_CHECK_LIB
+AC_CHECK_HEADER([wincrypt.h], [HAVE_SHA1_IN_CRYPTOAPI=yes], [], [#include <windows.h>])
+if test "x$with_sha1" = x && test "x$HAVE_SHA1_IN_CRYPTOAPI" = xyes; then
+	with_sha1=CryptoAPI
+fi
+if test "x$with_sha1" = xCryptoAPI && test "x$HAVE_SHA1_IN_CRYPTOAPI" != xyes; then
+	AC_MSG_ERROR([CryptoAPI requested but not found])
+fi
+if test "x$with_sha1" = xCryptoAPI; then
+	AC_DEFINE([HAVE_SHA1_IN_CRYPTOAPI], [1],
+		[Use CryptoAPI SHA1 functions])
+	SHA1_LIBS=""
+fi
+AC_CHECK_LIB([md], [SHA1Init], [HAVE_LIBMD=yes])
+if test "x$with_sha1" = x && test "x$HAVE_LIBMD" = xyes; then
+	with_sha1=libmd
+fi
+if test "x$with_sha1" = xlibmd && test "x$HAVE_LIBMD" != xyes; then
+	AC_MSG_ERROR([libmd requested but not found])
+fi
+if test "x$with_sha1" = xlibmd; then
+	AC_DEFINE([HAVE_SHA1_IN_LIBMD], [1],
+	          [Use libmd SHA1 functions])
+	SHA1_LIBS=-lmd
+fi
+PKG_CHECK_MODULES([LIBSHA1], [libsha1], [HAVE_LIBSHA1=yes], [HAVE_LIBSHA1=no])
+if test "x$with_sha1" = x && test "x$HAVE_LIBSHA1" = xyes; then
+   with_sha1=libsha1
+fi
+if test "x$with_sha1" = xlibsha1 && test "x$HAVE_LIBSHA1" != xyes; then
+	AC_MSG_ERROR([libsha1 requested but not found])
+fi
+if test "x$with_sha1" = xlibsha1; then
+	AC_DEFINE([HAVE_SHA1_IN_LIBSHA1], [1],
+	          [Use libsha1 for SHA1])
+	SHA1_LIBS=-lsha1
+fi
+AC_CHECK_LIB([nettle], [nettle_sha1_init], [HAVE_LIBNETTLE=yes])
+if test "x$with_sha1" = x && test "x$HAVE_LIBNETTLE" = xyes; then
+	with_sha1=libnettle
+fi
+if test "x$with_sha1" = xlibnettle && test "x$HAVE_LIBNETTLE" != xyes; then
+	AC_MSG_ERROR([libnettle requested but not found])
+fi
+if test "x$with_sha1" = xlibnettle; then
+	AC_DEFINE([HAVE_SHA1_IN_LIBNETTLE], [1],
+	          [Use libnettle SHA1 functions])
+	SHA1_LIBS=-lnettle
+fi
+AC_CHECK_LIB([gcrypt], [gcry_md_open], [HAVE_LIBGCRYPT=yes])
+if test "x$with_sha1" = x && test "x$HAVE_LIBGCRYPT" = xyes; then
+	with_sha1=libgcrypt
+fi
+if test "x$with_sha1" = xlibgcrypt && test "x$HAVE_LIBGCRYPT" != xyes; then
+	AC_MSG_ERROR([libgcrypt requested but not found])
+fi
+if test "x$with_sha1" = xlibgcrypt; then
+	AC_DEFINE([HAVE_SHA1_IN_LIBGCRYPT], [1],
+	          [Use libgcrypt SHA1 functions])
+	SHA1_LIBS=-lgcrypt
+fi
+# We don't need all of the OpenSSL libraries, just libcrypto
+AC_CHECK_LIB([crypto], [SHA1_Init], [HAVE_LIBCRYPTO=yes])
+PKG_CHECK_MODULES([OPENSSL], [openssl], [HAVE_OPENSSL_PKC=yes],
+                  [HAVE_OPENSSL_PKC=no])
+if test "x$HAVE_LIBCRYPTO" = xyes || test "x$HAVE_OPENSSL_PKC" = xyes; then
+	if test "x$with_sha1" = x; then
+		with_sha1=libcrypto
+	fi
+else
+	if test "x$with_sha1" = xlibcrypto; then
+		AC_MSG_ERROR([OpenSSL libcrypto requested but not found])
+	fi
+fi
+if test "x$with_sha1" = xlibcrypto; then
+	if test "x$HAVE_LIBCRYPTO" = xyes; then
+		SHA1_LIBS=-lcrypto
+	else
+		SHA1_LIBS="$OPENSSL_LIBS"
+		SHA1_CFLAGS="$OPENSSL_CFLAGS"
+	fi
+fi
+AC_MSG_CHECKING([for SHA1 implementation])
+if test "x$with_sha1" = x; then
+	AC_MSG_ERROR([No suitable SHA1 implementation found])
+fi
+AC_MSG_RESULT([$with_sha1])
+AC_SUBST(SHA1_LIBS)
+AC_SUBST(SHA1_CFLAGS)
+
+PKG_CHECK_MODULES([XSERVERCFLAGS], [$REQUIRED_MODULES $REQUIRED_LIBS])
+PKG_CHECK_MODULES([XSERVERLIBS], [$REQUIRED_LIBS])
+
+# Autotools has some unfortunate issues with library handling.  In order to
+# get a server to rebuild when a dependency in the tree is changed, it must
+# be listed in SERVERNAME_DEPENDENCIES.  However, no system libraries may be
+# listed there, or some versions of autotools will break (especially if a -L
+# is required to find the library).  So, we keep two sets of libraries
+# detected: NAMESPACE_LIBS for in-tree libraries to be linked against, which
+# will go into the _DEPENDENCIES and _LDADD of the server, and
+# NAMESPACE_SYS_LIBS which will go into only the _LDADD.  The
+# NAMESPACEMODULES_LIBS detected from pkgconfig should always go in
+# NAMESPACE_SYS_LIBS.
+#
+# XSERVER_LIBS is the set of in-tree libraries which all servers require.
+# XSERVER_SYS_LIBS is the set of out-of-tree libraries which all servers
+# require.
+#
+XSERVER_CFLAGS="${XSERVER_CFLAGS} ${XSERVERCFLAGS_CFLAGS}"
+XSERVER_LIBS="$DIX_LIB $MI_LIB $OS_LIB"
+XSERVER_SYS_LIBS="${XSERVERLIBS_LIBS} ${SYS_LIBS} ${LIBS}"
+AC_SUBST([XSERVER_LIBS])
+AC_SUBST([XSERVER_SYS_LIBS])
+
+UTILS_SYS_LIBS="${SYS_LIBS}"
+AC_SUBST([UTILS_SYS_LIBS])
+
+# The Xorg binary needs to export symbols so that they can be used from modules
+# Some platforms require extra flags to do this.   libtool should set the
+# necessary flags for each platform when -export-dynamic is passed to it.
+LD_EXPORT_SYMBOLS_FLAG="-export-dynamic"
+LD_NO_UNDEFINED_FLAG=
+XORG_DRIVER_LIBS=
+case "$host_os" in
+    cygwin*)
+	LD_EXPORT_SYMBOLS_FLAG="-Wl,--export-all,--out-implib,lib\$@.a"
+	LD_NO_UNDEFINED_FLAG="-no-undefined -Wl,\$(top_builddir)/hw/xfree86/libXorg.exe.a"
+	XORG_DRIVER_LIBS="-lXorg.exe -L\${moduledir} -lshadow -lfb -no-undefined"
+	CYGWIN=yes
+	;;
+    solaris*)
+	# We use AC_LINK_IFELSE to generate a temporary program conftest$EXEEXT
+	# that we can link against for testing if the system linker is new
+	# enough to support -z parent=<program> for verifying loadable modules
+	# are only calling functions defined in either the loading program or
+	# the libraries they're linked with.
+	AC_LINK_IFELSE(
+	    [AC_LANG_SOURCE([int main(int argc, char **argv) { return 0; }])],
+	    [mv conftest$EXEEXT conftest.parent
+	     XORG_CHECK_LINKER_FLAGS([-Wl,-z,parent=conftest.parent -G],
+		[LD_NO_UNDEFINED_FLAG="-Wl,-z,defs -Wl,-z,parent=\$(top_builddir)/hw/xfree86/Xorg"
+# Not set yet, since this gets exported in xorg-server.pc to all the drivers,
+# and they're not all fixed to build correctly with it yet.
+#		 XORG_DRIVER_LIBS="-Wl,-z,defs -Wl,-z,parent=${bindir}/Xorg"
+         ],[],
+		[AC_LANG_SOURCE([extern int main(int argc, char **argv);
+			int call_main(void) { return main(0, NULL); }])])
+	     rm -f conftest.parent
+	    ])
+	;;
+esac
+AC_SUBST([LD_EXPORT_SYMBOLS_FLAG])
+AC_SUBST([LD_NO_UNDEFINED_FLAG])
+AC_SUBST([XORG_DRIVER_LIBS])
+AM_CONDITIONAL([CYGWIN], [test x"$CYGWIN" = xyes])
+AM_CONDITIONAL([NO_UNDEFINED], [test x"$LD_NO_UNDEFINED_FLAG" != x])
+
+dnl Imake defines SVR4 on SVR4 systems, and many files check for it, so
+dnl we need to replicate that here until those can all be fixed
+AC_MSG_CHECKING([if SVR4 needs to be defined])
+AC_EGREP_CPP([I_AM_SVR4],[
+#if defined(SVR4) || defined(__svr4__) || defined(__SVR4)
+ I_AM_SVR4
+#endif
+],[
+AC_DEFINE([SVR4],1,[Define to 1 on systems derived from System V Release 4])
+AC_MSG_RESULT([yes])], AC_MSG_RESULT([no]))
+
+XSERVER_CFLAGS="$XSERVER_CFLAGS $CORE_INCS $XEXT_INC $COMPOSITE_INC $DAMAGE_INC $FIXES_INC $XI_INC $MI_INC $MIEXT_SYNC_INC $MIEXT_SHADOW_INC $MIEXT_LAYER_INC $MIEXT_DAMAGE_INC $RENDER_INC $RANDR_INC $FB_INC $DBE_INC"
+
+dnl ---------------------------------------------------------------------------
+dnl DDX section.
+dnl ---------------------------------------------------------------------------
+
+dnl Xvfb DDX
+
+AC_MSG_CHECKING([whether to build Xvfb DDX])
+AC_MSG_RESULT([$XVFB])
+AM_CONDITIONAL(XVFB, [test "x$XVFB" = xyes])
+
+if test "x$XVFB" = xyes; then
+	XVFB_LIBS="$FB_LIB $FIXES_LIB $XEXT_LIB $DBE_LIB $RECORD_LIB $GLX_LIBS $RANDR_LIB $RENDER_LIB $DAMAGE_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $MIEXT_SHADOW_LIB $XI_LIB $XKB_LIB $XKB_STUB_LIB $COMPOSITE_LIB"
+	XVFB_SYS_LIBS="$XVFBMODULES_LIBS $GLX_SYS_LIBS"
+	AC_SUBST([XVFB_LIBS])
+	AC_SUBST([XVFB_SYS_LIBS])
+fi
+
+
+dnl Xnest DDX
+
+PKG_CHECK_MODULES(XNESTMODULES, [$LIBXEXT x11 xau $XDMCP_MODULES], [have_xnest=yes], [have_xnest=no])
+AC_MSG_CHECKING([whether to build Xnest DDX])
+if test "x$XNEST" = xauto; then
+	XNEST="$have_xnest"
+fi
+AC_MSG_RESULT([$XNEST])
+AM_CONDITIONAL(XNEST, [test "x$XNEST" = xyes])
+
+if test "x$XNEST" = xyes; then
+	if test "x$have_xnest" = xno; then
+		AC_MSG_ERROR([Xnest build explicitly requested, but required modules not found.])
+	fi
+	XNEST_LIBS="$FB_LIB $FIXES_LIB $MI_LIB $XEXT_LIB $DBE_LIB $RECORD_LIB $GLX_LIBS $RANDR_LIB $RENDER_LIB $DAMAGE_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $MIEXT_SHADOW_LIB $XI_LIB $XKB_LIB $XKB_STUB_LIB $COMPOSITE_LIB $MAIN_LIB $DIX_LIB $OS_LIB"
+	XNEST_SYS_LIBS="$XNESTMODULES_LIBS $GLX_SYS_LIBS"
+	AC_SUBST([XNEST_LIBS])
+	AC_SUBST([XNEST_SYS_LIBS])
+fi
+
+
+dnl Xorg DDX
+
+AC_MSG_CHECKING([whether to build Xorg DDX])
+if test "x$XORG" = xauto; then
+	XORG="yes"
+	case $host_os in
+		cygwin*) XORG="no" ;;
+		mingw*)  XORG="no" ;;
+		darwin*) XORG="no" ;;
+	esac
+fi
+AC_MSG_RESULT([$XORG])
+
+if test "x$XORG" = xyes; then
+	XORG_DDXINCS='-I$(top_srcdir)/hw/xfree86 -I$(top_srcdir)/hw/xfree86/include -I$(top_srcdir)/hw/xfree86/common'
+	XORG_OSINCS='-I$(top_srcdir)/hw/xfree86/os-support -I$(top_srcdir)/hw/xfree86/os-support/bus -I$(top_srcdir)/os'
+	XORG_INCS="$XORG_DDXINCS $XORG_OSINCS"
+	XORG_CFLAGS="$XORGSERVER_CFLAGS -DHAVE_XORG_CONFIG_H"
+	XORG_LIBS="$COMPOSITE_LIB $FIXES_LIB $XEXT_LIB $DBE_LIB $RECORD_LIB $RANDR_LIB $RENDER_LIB $DAMAGE_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $XI_LIB $XKB_LIB"
+
+	dnl ==================================================================
+	dnl symbol visibility
+	symbol_visibility=
+	have_visibility=disabled
+	if test x$SYMBOL_VISIBILITY != xno; then
+	    AC_MSG_CHECKING(for symbol visibility support)
+	    if test x$GCC = xyes; then
+		VISIBILITY_CFLAGS="-fvisibility=hidden"
+	    else
+		if test x$SUNCC = xyes; then
+		    VISIBILITY_CFLAGS="-xldscope=hidden"
+		else
+		    have_visibility=no
+		fi
+	    fi
+	    if test x$have_visibility != xno; then
+		save_CFLAGS="$CFLAGS"
+		proto_inc=`$PKG_CONFIG --cflags xproto`
+		CFLAGS="$CFLAGS $VISIBILITY_CFLAGS $proto_inc"
+		AC_TRY_COMPILE(
+		    [#include <X11/Xfuncproto.h>
+		     extern _X_HIDDEN int hidden_int;
+		     extern _X_EXPORT int public_int;
+		     extern _X_HIDDEN int hidden_int_func(void);
+		     extern _X_EXPORT int public_int_func(void);],
+		    [],
+		    have_visibility=yes,
+		    have_visibility=no)
+		CFLAGS=$save_CFLAGS
+	    fi
+	    AC_MSG_RESULT([$have_visibility])
+	    if test x$have_visibility != xno; then
+		symbol_visibility=$VISIBILITY_CFLAGS
+		XORG_CFLAGS="$XORG_CFLAGS $VISIBILITY_CFLAGS"
+		XSERVER_CFLAGS="$XSERVER_CFLAGS $VISIBILITY_CFLAGS"
+	    fi
+	fi
+	dnl added to xorg-server.pc
+	AC_SUBST([symbol_visibility])
+	dnl ===================================================================
+
+	dnl ===================================================================
+	dnl ================= beginning of PCI configuration ==================
+	dnl ===================================================================
+	xorg_bus_bsdpci=no
+	xorg_bus_sparc=no
+
+	AC_MSG_CHECKING([whether to build Xorg PCI functions])
+	if test "x$PCI" = xyes; then
+
+	PKG_CHECK_MODULES([PCIACCESS], $LIBPCIACCESS)
+	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $LIBPCIACCESS"
+	XORG_SYS_LIBS="$XORG_SYS_LIBS $PCIACCESS_LIBS $GLX_SYS_LIBS $LIBDRM_LIBS"
+	XORG_CFLAGS="$XORG_CFLAGS $PCIACCESS_CFLAGS $LIBDRM_CFLAGS"
+
+	AC_DEFINE(XSERVER_LIBPCIACCESS, 1, [Use libpciaccess for all pci manipulation])
+	AC_DEFINE_DIR(PCI_TXT_IDS_PATH, PCI_TXT_IDS_DIR, [Default PCI text file ID path])
+	case $host_os in
+	  gnu* | freebsd* | kfreebsd*-gnu | netbsd* | openbsd* | solaris* | dragonfly*)
+		xorg_bus_bsdpci="yes"
+		;;
+	esac
+	case $host_cpu in
+	  sparc*)
+		xorg_bus_sparc="yes"
+		;;
+	esac
+	fi
+	AC_MSG_RESULT([$PCI])
+
+	if test "x$CONFIG_UDEV_KMS" = xyes; then
+		AC_DEFINE(XSERVER_PLATFORM_BUS, 1, [X server supports platform device enumeration])
+	fi
+	AC_MSG_RESULT([$XSERVER_PLATFORM_BUS])
+	dnl ===================================================================
+	dnl ==================== end of PCI configuration =====================
+	dnl ===================================================================
+
+	case $host_os in
+	  linux*)
+		if test "x$LNXAPM" = xyes; then
+			XORG_CFLAGS="$XORG_CFLAGS -DXF86PM"
+		fi
+		XORG_OS_SUBDIR="linux"
+		linux_acpi="no"
+		case $host_cpu in
+		  alpha*)
+		  	linux_alpha=yes
+			;;
+		  i*86|amd64*|x86_64*|ia64*)
+			;;
+		  *)
+			;;
+		esac
+		;;
+	  freebsd* | kfreebsd*-gnu | dragonfly*)
+		XORG_OS_SUBDIR="bsd"
+		;;
+	  netbsd*)
+		XORG_OS_SUBDIR="bsd"
+		;;
+	  openbsd*)
+		if test "x$ac_cv_BSD_APM" = xyes \
+			-o "x$ac_cv_BSD_KQUEUE_APM" = xyes; then
+			XORG_CFLAGS="$XORG_CFLAGS -DXF86PM"
+		fi
+		XORG_OS_SUBDIR="bsd"
+		;;
+	  solaris*)
+		XORG_OS_SUBDIR="solaris"
+		XORG_CFLAGS="$XORG_CFLAGS -DXF86PM"
+		AC_CHECK_HEADERS([sys/kd.h])
+		AC_CHECK_HEADERS([sys/vt.h], [solaris_vt=yes], [solaris_vt=no])
+		# Check for minimum supported release
+		AC_MSG_CHECKING([Solaris version])
+	        OS_MINOR=`echo ${host_os}|$SED -e 's/^.*solaris2\.//' -e s'/\..*$//'`
+		if test "${OS_MINOR}" -ge 7 ; then
+	        	AC_MSG_RESULT(Solaris ${OS_MINOR})
+		else
+			AC_MSG_RESULT(Solaris `echo ${host_os}|$SED -e 's/^.*solaris//`)
+		fi
+		if test "${OS_MINOR}" -lt 8 ; then
+			AC_MSG_ERROR([This release no longer supports Solaris versions older than Solaris 8.])
+		fi
+		if test "x$SUNCC" = "xyes"; then
+			solaris_asm_inline="yes"
+		fi
+		AC_CHECK_DECL([_LP64], [SOLARIS_64="yes"], [SOLARIS_64="no"])
+			
+		case $host_cpu in
+		  sparc*)	
+			SOLARIS_INOUT_ARCH="sparcv8plus"
+			;;
+		  i*86)	
+			if test x$SOLARIS_64 = xyes ; then
+				SOLARIS_INOUT_ARCH="amd64"
+			else
+				SOLARIS_INOUT_ARCH="ia32"
+			fi
+			;;
+		  *)
+			AC_MSG_ERROR([Unsupported Solaris platform. Only SPARC & x86 \
+			are supported on Solaris in this release.   If you are \
+			interested in porting Xorg to your platform, please email \
+			xorg@lists.freedesktop.org.]) ;;
+		esac
+		AC_SUBST([SOLARIS_INOUT_ARCH])
+		if test x$solaris_asm_inline = xyes ; then
+			SOLARIS_ASM_CFLAGS='$(top_srcdir)/hw/xfree86/os-support/solaris/solaris-$(SOLARIS_INOUT_ARCH).il'
+			XORG_CFLAGS="${XORG_CFLAGS} "'$(SOLARIS_ASM_CFLAGS)'
+		fi
+		AC_SUBST([SOLARIS_ASM_CFLAGS])
+		;;
+	  gnu*)
+		XORG_OS_SUBDIR="hurd"
+		;;
+	  *)
+		XORG_OS_SUBDIR="stub"
+		AC_MSG_NOTICE([m4_text_wrap(m4_join([ ],
+		[Your OS is unknown. Xorg currently only supports Linux,],
+		[Free/Open/Net/DragonFlyBSD, Solaris/OpenSolaris, & GNU Hurd.],
+		[If you are interested in porting Xorg to your platform,],
+		[please email xorg@lists.freedesktop.org.]))])
+		;;
+	esac
+
+	case $host_cpu in
+	  i*86)
+		;;
+	esac
+
+	if test "x$DGA" = xauto; then
+		PKG_CHECK_MODULES(DGA, $DGAPROTO, [DGA=yes], [DGA=no])
+	fi
+	if test "x$DGA" = xyes; then
+		XORG_MODULES="$XORG_MODULES $DGAPROTO"
+		PKG_CHECK_MODULES(DGA, $DGAPROTO)
+		AC_DEFINE(DGA, 1, [Support DGA extension])
+		AC_DEFINE(XFreeXDGA, 1, [Build XDGA support])
+	fi
+
+	if test "x$XF86VIDMODE" = xauto; then
+		PKG_CHECK_MODULES(XF86VIDMODE, $VIDMODEPROTO, [XF86VIDMODE=yes], [XF86VIDMODE=no])
+	fi
+	if test "x$XF86VIDMODE" = xyes; then
+		XORG_MODULES="$XORG_MODULES $VIDMODEPROTO"
+		PKG_CHECK_MODULES(XF86VIDMODE, $VIDMODEPROTO)
+		AC_DEFINE(XF86VIDMODE, 1, [Support XFree86 Video Mode extension])
+	fi
+
+	if test -n "$XORG_MODULES"; then
+	        PKG_CHECK_MODULES(XORG_MODULES, [$XORG_MODULES])
+	        XORG_CFLAGS="$XORG_CFLAGS $XORG_MODULES_CFLAGS"
+	        XORG_SYS_LIBS="$XORG_SYS_LIBS $XORG_MODULES_LIBS"
+	fi
+
+	AC_SUBST([XORG_LIBS])
+	AC_SUBST([XORG_SYS_LIBS])
+	AC_SUBST([XORG_INCS])
+	AC_SUBST([XORG_OS_SUBDIR])
+	AC_SUBST([XORG_CFLAGS])
+
+	dnl these only go in xorg-config.h
+	XF86CONFIGFILE="xorg.conf"
+	XF86CONFIGDIR="xorg.conf.d"
+	AC_SUBST(XF86CONFIGDIR)
+	CONFIGFILE="$sysconfdir/$XF86CONFIGFILE"
+	LOGPREFIX="$logdir/Xorg."
+	AC_DEFINE(XORG_SERVER, 1, [Building Xorg server])
+	AC_DEFINE(XORGSERVER, 1, [Building Xorg server])
+	AC_DEFINE(XFree86Server, 1, [Building XFree86 server])
+	AC_DEFINE_UNQUOTED(XORG_VERSION_CURRENT, [$VENDOR_RELEASE], [Current Xorg version])
+	AC_DEFINE(NEED_XF86_TYPES, 1, [Need XFree86 typedefs])
+	AC_DEFINE(NEED_XF86_PROTOTYPES, 1, [Need XFree86 helper functions])
+	AC_DEFINE(__XSERVERNAME__, "Xorg", [Name of X server])
+	AC_DEFINE_DIR(__XCONFIGFILE__, XF86CONFIGFILE, [Name of configuration file])
+	AC_DEFINE_DIR(XF86CONFIGFILE, XF86CONFIGFILE, [Name of configuration file])
+	AC_DEFINE_DIR(__XCONFIGDIR__, XF86CONFIGDIR, [Name of configuration directory])
+	AC_DEFINE_DIR(DEFAULT_MODULE_PATH, moduledir, [Default module search path])
+	AC_DEFINE_DIR(DEFAULT_LIBRARY_PATH, libdir, [Default library install path])
+	AC_DEFINE_DIR(DEFAULT_LOGPREFIX, LOGPREFIX, [Default log location])
+	AC_DEFINE_UNQUOTED(__VENDORDWEBSUPPORT__, ["$VENDOR_WEB"], [Vendor web address for support])
+	if test "x$VGAHW" = xyes; then
+		AC_DEFINE(WITH_VGAHW, 1, [Building vgahw module])
+	fi
+
+	driverdir="$moduledir/drivers"
+	AC_SUBST([moduledir])
+	AC_SUBST([driverdir])
+	sdkdir="$includedir/xorg"
+	extdir="$includedir/X11/extensions"
+	sysconfigdir="$datadir/X11/$XF86CONFIGDIR"
+	AC_SUBST([sdkdir])
+	AC_SUBST([extdir])
+	AC_SUBST([sysconfigdir])
+	AC_SUBST([logdir])
+
+	# stuff the ABI versions into the pc file too
+	extract_abi() {
+	    grep ^.define.*${1}_VERSION ${srcdir}/hw/xfree86/common/xf86Module.h | tr '(),' '  .' | awk '{ print $4$5 }'
+	}
+	abi_ansic=`extract_abi ANSIC`
+	abi_videodrv=`extract_abi VIDEODRV`
+	abi_xinput=`extract_abi XINPUT`
+	abi_extension=`extract_abi EXTENSION`
+	AC_SUBST([abi_ansic])
+	AC_SUBST([abi_videodrv])
+	AC_SUBST([abi_xinput])
+	AC_SUBST([abi_extension])
+fi
+AM_CONDITIONAL([XORG], [test "x$XORG" = xyes])
+AM_CONDITIONAL([XORG_BUS_PCI], [test "x$PCI" = xyes])
+AM_CONDITIONAL([XORG_BUS_BSDPCI], [test "x$xorg_bus_bsdpci" = xyes])
+AM_CONDITIONAL([XORG_BUS_SPARC], [test "x$xorg_bus_sparc" = xyes])
+AM_CONDITIONAL([LINUX_ALPHA], [test "x$linux_alpha" = xyes])
+AM_CONDITIONAL([LNXACPI], [test "x$linux_acpi" = xyes])
+AM_CONDITIONAL([SOLARIS_ASM_INLINE], [test "x$solaris_asm_inline" = xyes])
+AM_CONDITIONAL([SOLARIS_VT], [test "x$solaris_vt" = xyes])
+AM_CONDITIONAL([DGA], [test "x$DGA" = xyes])
+AM_CONDITIONAL([XF86VIDMODE], [test "x$XF86VIDMODE" = xyes])
+AM_CONDITIONAL([XORG_BUS_PLATFORM], [test "x$CONFIG_UDEV_KMS" = xyes])
+dnl XWin DDX
+
+AC_MSG_CHECKING([whether to build XWin DDX])
+if test "x$XWIN" = xauto; then
+	case $host_os in
+		cygwin*) XWIN="yes" ;;
+		mingw*) XWIN="yes" ;;
+		*) XWIN="no" ;;
+	esac
+fi
+AC_MSG_RESULT([$XWIN])
+
+if test "x$XWIN" = xyes; then
+	AC_DEFINE_DIR(SYSCONFDIR, sysconfdir, [Location of system.XWinrc])
+	AC_DEFINE_DIR(DEFAULT_LOGDIR, logdir, [Default log location])
+	AC_DEFINE_UNQUOTED(XORG_VERSION_CURRENT, [$VENDOR_RELEASE], [Current Xorg version])
+	AC_DEFINE_UNQUOTED(__VENDORDWEBSUPPORT__, ["$VENDOR_WEB"], [Vendor web address for support])
+	AC_CHECK_TOOL(WINDRES, windres)
+
+	PKG_CHECK_MODULES([XWINMODULES],[x11 xdmcp xau])
+
+	if test "x$WINDOWSWM" = xauto; then
+		PKG_CHECK_EXISTS($WINDOWSWMPROTO, [WINDOWSWM=yes], [WINDOWSWM=no])
+	fi
+	if test "x$WINDOWSWM" = xyes ; then
+		PKG_CHECK_MODULES(WINDOWSWM, $WINDOWSWMPROTO)
+		XWINMODULES_CFLAGS="$XWINMODULES_CFLAGS $WINDOWSWM_CFLAGS"
+		AC_DEFINE(ROOTLESS,1,[Build Rootless code])
+	fi
+
+	case $host_os in
+		cygwin*)
+			XWIN_SERVER_NAME=XWin
+			AC_DEFINE(HAS_DEVWINDOWS,1,[Cygwin has /dev/windows for signaling new win32 messages])
+			;;
+		mingw*)
+			XWIN_SERVER_NAME=Xming
+			AC_DEFINE(RELOCATE_PROJECTROOT,1,[Make PROJECT_ROOT relative to the xserver location])
+			AC_DEFINE(HAS_WINSOCK,1,[Use Windows sockets])
+			XWIN_SYS_LIBS="-lpthread -lws2_32"
+			;;
+	esac
+
+	XWIN_LIBS="$FB_LIB $MI_LIB $FIXES_LIB $XEXT_LIB $RANDR_LIB $RENDER_LIB $DBE_LIB $RECORD_LIB $GLX_LIBS $XKB_LIB $XKB_STUB_LIB $COMPOSITE_LIB $DAMAGE_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $MIEXT_SHADOW_LIB $XI_LIB $OS_LIB"
+	XWIN_SYS_LIBS="$XWIN_SYS_LIBS $XWINMODULES_LIBS $GLX_SYS_LIBS"
+	AC_SUBST(XWIN_LIBS)
+	AC_SUBST(XWIN_SERVER_NAME)
+	AC_SUBST(XWIN_SYS_LIBS)
+
+	if test "x$DEBUGGING" = xyes; then
+		AC_DEFINE(CYGDEBUG, 1, [Simple debug messages])
+		AC_DEFINE(CYGWINDOWING_DEBUG, 1, [Debug messages for window handling])
+		AC_DEFINE(CYGMULTIWINDOW_DEBUG, 1, [Debug window manager])
+	fi
+
+	AC_DEFINE(DDXOSVERRORF, 1, [Use OsVendorVErrorF])
+	AC_DEFINE(DDXBEFORERESET, 1, [Use ddxBeforeReset ])
+
+dnl XWin with AIGLX requires OpenGL spec files in order to generate wrapper code for native GL functions
+	if [test "x$XWIN" = xyes && test "x$AIGLX" = xyes] ; then
+           if test "x$KHRONOS_SPEC_DIR" = "xauto" ; then
+		PKG_CHECK_MODULES([KHRONOS_OPENGL_REGISTRY], [khronos-opengl-registry])
+		KHRONOS_SPEC_DIR=`pkg-config khronos-opengl-registry --variable=specdir`
+           fi
+           AC_SUBST(KHRONOS_SPEC_DIR)
+	fi
+
+fi
+AM_CONDITIONAL(XWIN, [test "x$XWIN" = xyes])
+AM_CONDITIONAL(XWIN_MULTIWINDOW, [test "x$XWIN" = xyes])
+AM_CONDITIONAL(XWIN_MULTIWINDOWEXTWM, [test "x$XWIN" = xyes && test "x$WINDOWSWM" = xyes])
+AM_CONDITIONAL(XWIN_CLIPBOARD, [test "x$XWIN" = xyes])
+AM_CONDITIONAL(XWIN_GLX_WINDOWS, [test "x$XWIN" = xyes && test "x$AIGLX" = xyes])
+AM_CONDITIONAL(XWIN_NATIVEGDI, [test "x$XWIN" = xyes])
+AM_CONDITIONAL(XWIN_PRIMARYFB, [test "x$XWIN" = xyes])
+AM_CONDITIONAL(XWIN_RANDR, [test "x$XWIN" = xyes])
+AM_CONDITIONAL(XWIN_XV, [test "x$XWIN" = xyes && test "x$XV" = xyes])
+
+dnl Darwin / OS X DDX
+if test "x$XQUARTZ" = xyes; then
+	AC_DEFINE(XQUARTZ,1,[Have Quartz])
+	AC_DEFINE(ROOTLESS,1,[Build Rootless code])
+
+	XQUARTZ_LIBS="$MAIN_LIB $FB_LIB $FIXES_LIB $XEXT_LIB $DBE_LIB $RECORD_LIB $RANDR_LIB $RENDER_LIB $DAMAGE_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $MIEXT_SHADOW_LIB $XI_LIB $XKB_LIB $XKB_STUB_LIB $XPSTUBS_LIB"
+	AC_SUBST([XQUARTZ_LIBS])
+
+	AC_CHECK_LIB([Xplugin],[xp_init],[:])
+
+	CFLAGS="${CFLAGS} -DROOTLESS_WORKAROUND -DROOTLESS_SAFEALPHA -DNO_ALLOCA"
+
+	PKG_CHECK_MODULES(XPBPROXY, $APPLEWMPROTO $LIBAPPLEWM xfixes x11)
+
+        if test "x$XQUARTZ_SPARKLE" = xyes ; then
+                AC_DEFINE(XQUARTZ_SPARKLE,1,[Support application updating through sparkle.])
+        fi
+
+	if test "x$STANDALONE_XPBPROXY" = xyes ; then
+		AC_DEFINE(STANDALONE_XPBPROXY,1,[Build a standalone xpbproxy])
+	fi
+fi
+
+# Support for objc in autotools is minimal and not documented.
+OBJC='$(CC)'
+OBJCLD='$(CCLD)'
+OBJCLINK='$(LINK)'
+OBJCFLAGS='$(CFLAGS)'
+AC_SUBST([OBJC])
+AC_SUBST([OBJCCLD])
+AC_SUBST([OBJCLINK])
+AC_SUBST([OBJCFLAGS])
+# internal, undocumented automake func follows :(
+_AM_DEPENDENCIES([OBJC])
+AM_CONDITIONAL(XQUARTZ, [test "x$XQUARTZ" = xyes])
+AM_CONDITIONAL(XQUARTZ_SPARKLE, [test "x$XQUARTZ_SPARKLE" != "xno"])
+AM_CONDITIONAL(STANDALONE_XPBPROXY, [test "x$STANDALONE_XPBPROXY" = xyes])
+
+dnl DMX DDX
+PKG_CHECK_MODULES(
+	[DMXMODULES],
+	[xmuu $LIBXEXT x11 xrender xfixes $LIBXI $DMXPROTO xau $XDMCP_MODULES],
+	[PKG_CHECK_MODULES(
+		[XDMXCONFIG_DEP],
+		[xaw7 xmu xt xpm x11],
+		[have_dmx=yes],
+		[have_dmx=no])],
+	[have_dmx=no])
+AC_MSG_CHECKING([whether to build Xdmx DDX])
+if test "x$DMX" = xauto; then
+	DMX="$have_dmx"
+	case $host_os in
+		cygwin*) DMX="no" ;;
+		mingw*)  DMX="no" ;;
+		darwin*) DMX="no" ;;
+	esac
+fi
+AC_MSG_RESULT([$DMX])
+AM_CONDITIONAL(DMX, [test "x$DMX" = xyes])
+
+if test "x$DMX" = xyes; then
+	if test "x$have_dmx" = xno; then
+		AC_MSG_ERROR([Xdmx build explicitly requested, but required
+		              modules not found.])
+	fi
+	DMX_INCLUDES="$XEXT_INC $RENDER_INC $RECORD_INC"
+	XDMX_CFLAGS="$DMXMODULES_CFLAGS"
+	XDMX_LIBS="$FB_LIB $MI_LIB $XEXT_LIB $RENDER_LIB $RECORD_LIB $XI_LIB $XKB_LIB $XKB_STUB_LIB $MIEXT_SYNC_LIB $MIEXT_SHADOW_LIB $MIEXT_DAMAGE_LIB $COMPOSITE_LIB $DAMAGE_LIB $MAIN_LIB $DIX_LIB $CONFIG_LIB $OS_LIB $FIXES_LIB"
+	XDMX_SYS_LIBS="$DMXMODULES_LIBS"
+	AC_SUBST([XDMX_CFLAGS])
+	AC_SUBST([XDMX_LIBS])
+	AC_SUBST([XDMX_SYS_LIBS])
+
+dnl USB sources in DMX require <linux/input.h>
+	AC_CHECK_HEADER([linux/input.h], DMX_BUILD_USB="yes",
+			DMX_BUILD_USB="no")
+dnl Linux sources in DMX require <linux/keyboard.h>
+	AC_CHECK_HEADER([linux/keyboard.h], DMX_BUILD_LNX="yes",
+			DMX_BUILD_LNX="no")
+	AC_SUBST(XDMXCONFIG_DEP_CFLAGS)
+	AC_SUBST(XDMXCONFIG_DEP_LIBS)
+	PKG_CHECK_MODULES([DMXEXAMPLES_DEP], [$LIBDMX $LIBXEXT x11])
+	AC_SUBST(DMXEXAMPLES_DEP_LIBS)
+	PKG_CHECK_MODULES([DMXXMUEXAMPLES_DEP], [$LIBDMX xmu $LIBXEXT x11])
+	AC_SUBST(DMXXMUEXAMPLES_DEP_LIBS)
+	PKG_CHECK_MODULES([DMXXIEXAMPLES_DEP], [$LIBDMX $LIBXI $LIBXEXT x11])
+	AC_SUBST(DMXXIEXAMPLES_DEP_LIBS)
+	PKG_CHECK_MODULES([XTSTEXAMPLES_DEP], [$LIBXTST $LIBXEXT x11])
+	AC_SUBST(XTSTEXAMPLES_DEP_LIBS)
+	PKG_CHECK_MODULES([XRESEXAMPLES_DEP], [xres $LIBXEXT x11])
+	AC_SUBST(XRESEXAMPLES_DEP_LIBS)
+	PKG_CHECK_MODULES([X11EXAMPLES_DEP], [$LIBXEXT x11])
+	AC_SUBST(X11EXAMPLES_DEP_LIBS)
+
+fi
+AM_CONDITIONAL([DMX_BUILD_LNX], [test "x$DMX_BUILD_LNX" = xyes])
+AM_CONDITIONAL([DMX_BUILD_USB], [test "x$DMX_BUILD_USB" = xyes])
+
+dnl kdrive DDX
+
+XEPHYR_LIBS=
+XEPHYR_INCS=
+
+AM_CONDITIONAL(KDRIVE, [test x$KDRIVE = xyes])
+
+if test "$KDRIVE" = yes; then
+    AC_DEFINE(KDRIVESERVER,1,[Build Kdrive X server])
+    AC_DEFINE(KDRIVEDDXACTIONS,,[Build kdrive ddx])
+
+    AC_CHECK_HEADERS([linux/fb.h])
+    if test "$ac_cv_header_linux_fb_h" = yes && test "x$XFBDEV" = xauto; then
+        XFBDEV=yes
+    fi
+
+    if test "x$XFBDEV" = xyes; then
+        KDRIVEFBDEVLIB=yes
+        AC_DEFINE(KDRIVEFBDEV, 1, [Build fbdev-based kdrive server])
+    fi
+
+
+    PKG_CHECK_MODULES([TSLIB], [tslib-0.0], [HAVE_TSLIB="yes"], [HAVE_TSLIB="no"])
+    if test "x$HAVE_TSLIB" = xno; then
+        AC_CHECK_LIB(ts, ts_open, [
+			HAVE_TSLIB="yes"
+			TSLIB_LIBS="-lts"
+		])
+    fi
+
+    if test "xTSLIB" = xauto; then
+        TSLIB="$HAVE_TSLIB"
+    fi
+
+    if test "x$TSLIB" = xyes; then
+        if ! test "x$HAVE_TSLIB" = xyes; then
+            AC_MSG_ERROR([tslib must be installed to build the tslib driver. See http://tslib.berlios.de/])
+        else
+            AC_DEFINE(TSLIB, 1, [Have tslib support])
+        fi
+    fi
+
+    if test "x$KDRIVE_KBD" = xyes; then
+       AC_DEFINE(KDRIVE_KBD, 1, [Enable KDrive kbd driver])
+    fi
+    if test "x$KDRIVE_EVDEV" = xyes; then
+       AC_DEFINE(KDRIVE_EVDEV, 1, [Enable KDrive evdev driver])
+    fi
+    if test "x$KDRIVE_MOUSE" = xyes; then
+       AC_DEFINE(KDRIVE_MOUSE, 1, [Enable KDrive mouse driver])
+    fi
+
+    XEPHYR_REQUIRED_LIBS="x11 $LIBXEXT xau xdmcp"
+    if test "x$XV" = xyes; then
+        XEPHYR_REQUIRED_LIBS="$XEPHYR_REQUIRED_LIBS xv"
+    fi
+    if test "x$DRI" = xyes && test "x$GLX" = xyes; then
+        XEPHYR_REQUIRED_LIBS="$XEPHYR_REQUIRED_LIBS $LIBGL libdrm"
+    fi
+
+    if test "x$XEPHYR" = xauto; then
+        PKG_CHECK_MODULES(XEPHYR, $XEPHYR_REQUIRED_LIBS, [XEPHYR="yes"], [XEPHYR="no"])
+    elif test "x$XEPHYR" = xyes ; then
+        PKG_CHECK_MODULES(XEPHYR, $XEPHYR_REQUIRED_LIBS)
+    fi
+
+    # Xephyr needs nanosleep() which is in librt on Solaris
+    AC_CHECK_FUNC([nanosleep], [],
+        AC_CHECK_LIB([rt], [nanosleep], XEPHYR_LIBS="$XEPHYR_LIBS -lrt"))
+    
+    # damage shadow extension glx (NOTYET) fb mi
+    KDRIVE_INC='-I$(top_srcdir)/hw/kdrive/src'
+    KDRIVE_PURE_INCS="$KDRIVE_INC $MIEXT_SYNC_INC $MIEXT_DAMAGE_INC $MIEXT_SHADOW_INC $XEXT_INC $FB_INC $MI_INC"
+    KDRIVE_OS_INC='-I$(top_srcdir)/hw/kdrive/linux'
+    KDRIVE_INCS="$KDRIVE_PURE_INCS $KDRIVE_OS_INC"
+    
+    KDRIVE_CFLAGS="$XSERVER_CFLAGS -DHAVE_KDRIVE_CONFIG_H $TSLIB_CFLAGS"
+
+    KDRIVE_PURE_LIBS="$FB_LIB $MI_LIB $FIXES_LIB $XEXT_LIB $DBE_LIB $RECORD_LIB $GLX_LIBS $RANDR_LIB $RENDER_LIB $DAMAGE_LIB $MIEXT_SYNC_LIB $MIEXT_DAMAGE_LIB $MIEXT_SHADOW_LIB $XI_LIB $XKB_LIB $XKB_STUB_LIB $COMPOSITE_LIB $OS_LIB"
+    KDRIVE_LIB='$(top_builddir)/hw/kdrive/src/libkdrive.la'
+    case $host_os in
+	*linux*)
+	    KDRIVE_OS_LIB='$(top_builddir)/hw/kdrive/linux/liblinux.la'
+            KDRIVELINUX=yes
+	    if test "x$KDRIVE_EVDEV" = xauto; then
+		KDRIVE_EVDEV=yes
+	    fi
+	    if test "x$KDRIVE_KBD" = xauto; then
+		KDRIVE_KBD=yes
+	    fi
+	    if test "x$KDRIVE_MOUSE" = xauto; then
+		KDRIVE_MOUSE=yes
+	    fi
+	    ;;
+	*)
+	    if test "x$KDRIVE_EVDEV" = xauto; then
+		KDRIVE_EVDEV=no
+	    fi
+	    if test "x$KDRIVE_KBD" = xauto; then
+		KDRIVE_KBD=no
+	    fi
+	    if test "x$KDRIVE_MOUSE" = xauto; then
+		KDRIVE_MOUSE=no
+	    fi
+	    ;;
+    esac
+    KDRIVE_STUB_LIB='$(top_builddir)/hw/kdrive/src/libkdrivestubs.la'
+    KDRIVE_LOCAL_LIBS="$MAIN_LIB $DIX_LIB $KDRIVE_LIB $KDRIVE_STUB_LIB"
+    KDRIVE_LOCAL_LIBS="$KDRIVE_LOCAL_LIBS $FB_LIB $MI_LIB $KDRIVE_PURE_LIBS"
+    KDRIVE_LOCAL_LIBS="$KDRIVE_LOCAL_LIBS $KDRIVE_OS_LIB"
+    KDRIVE_LIBS="$KDRIVE_LOCAL_LIBS $XSERVER_SYS_LIBS $GLX_SYS_LIBS $DLOPEN_LIBS $TSLIB_LIBS"
+
+    AC_SUBST([XEPHYR_LIBS])
+    AC_SUBST([XEPHYR_INCS])
+fi
+AC_SUBST([KDRIVE_INCS])
+AC_SUBST([KDRIVE_PURE_INCS])
+AC_SUBST([KDRIVE_CFLAGS])
+AC_SUBST([KDRIVE_PURE_LIBS])
+AC_SUBST([KDRIVE_LOCAL_LIBS])
+AC_SUBST([KDRIVE_LIBS])
+AM_CONDITIONAL(KDRIVELINUX, [test "x$KDRIVELINUX" = xyes])
+AM_CONDITIONAL(KDRIVE_EVDEV, [test "x$KDRIVE_EVDEV" = xyes])
+AM_CONDITIONAL(KDRIVE_KBD,   [test "x$KDRIVE_KBD" = xyes])
+AM_CONDITIONAL(KDRIVE_MOUSE, [test "x$KDRIVE_MOUSE" = xyes])
+AM_CONDITIONAL(TSLIB, [test "x$HAVE_TSLIB" = xyes])
+AM_CONDITIONAL(KDRIVEFBDEV, [test "x$XFBDEV" = xyes])
+AM_CONDITIONAL(XEPHYR, [test "x$KDRIVE" = xyes && test "x$XEPHYR" = xyes])
+AM_CONDITIONAL(BUILD_KDRIVEFBDEVLIB, [test "x$KDRIVE" = xyes && test "x$KDRIVEFBDEVLIB" = xyes])
+AM_CONDITIONAL(XFAKESERVER, [test "x$KDRIVE" = xyes && test "x$XFAKE" = xyes])
+
+dnl and the rest of these are generic, so they're in config.h
+dnl 
+dnl though, thanks to the passing of some significant amount of time, the
+dnl above is probably a complete fallacy, and you should not rely on it.
+dnl but this is still actually better than imake, honest. -daniels
+
+AC_TRY_COMPILE([
+#include <features.h>
+#ifndef __GLIBC__
+#error not glibc
+#endif
+], [], [AC_DEFINE(_GNU_SOURCE, 1,
+	[ Enable GNU and other extensions to the C environment for glibc])])
+
+AC_DEFINE_DIR(PROJECTROOT, prefix, [Overall prefix])
+
+AC_SUBST([RELEASE_DATE])
+BUILD_DATE="`date +'%Y%m%d'`"
+AC_SUBST([BUILD_DATE])
+BUILD_TIME="`date +'1%H%M%S'`"
+AC_SUBST([BUILD_TIME])
+
+DIX_CFLAGS="-DHAVE_DIX_CONFIG_H $XSERVER_CFLAGS"
+
+AC_SUBST([DIX_CFLAGS])
+
+AC_SUBST([libdir])
+AC_SUBST([exec_prefix])
+AC_SUBST([prefix])
+
+AC_CONFIG_COMMANDS([sdksyms], [touch hw/xfree86/sdksyms.dep])
+
+if test "x$CONFIG_HAL" = xno && test "x$CONFIG_UDEV" = xno; then
+    AC_WARN([
+             ***********************************************
+             Neither HAL nor udev backend will be enabled.
+             Input device hotplugging will not be available!
+             ***********************************************])
+fi
+
+AC_OUTPUT([
+Makefile
+glx/Makefile
+include/Makefile
+composite/Makefile
+damageext/Makefile
+dbe/Makefile
+dix/Makefile
+doc/Makefile
+doc/dtrace/Makefile
+man/Makefile
+fb/Makefile
+record/Makefile
+config/Makefile
+mi/Makefile
+miext/Makefile
+miext/sync/Makefile
+miext/damage/Makefile
+miext/shadow/Makefile
+miext/rootless/Makefile
+os/Makefile
+randr/Makefile
+render/Makefile
+xkb/Makefile
+Xext/Makefile
+Xi/Makefile
+xfixes/Makefile
+exa/Makefile
+hw/Makefile
+hw/xfree86/Makefile
+hw/xfree86/common/Makefile
+hw/xfree86/common/xf86Build.h
+hw/xfree86/ddc/Makefile
+hw/xfree86/dixmods/Makefile
+hw/xfree86/doc/Makefile
+hw/xfree86/dri/Makefile
+hw/xfree86/dri2/Makefile
+hw/xfree86/exa/Makefile
+hw/xfree86/exa/man/Makefile
+hw/xfree86/fbdevhw/Makefile
+hw/xfree86/fbdevhw/man/Makefile
+hw/xfree86/i2c/Makefile
+hw/xfree86/int10/Makefile
+hw/xfree86/loader/Makefile
+hw/xfree86/man/Makefile
+hw/xfree86/modes/Makefile
+hw/xfree86/os-support/Makefile
+hw/xfree86/os-support/bsd/Makefile
+hw/xfree86/os-support/bus/Makefile
+hw/xfree86/os-support/hurd/Makefile
+hw/xfree86/os-support/misc/Makefile
+hw/xfree86/os-support/linux/Makefile
+hw/xfree86/os-support/solaris/Makefile
+hw/xfree86/os-support/stub/Makefile
+hw/xfree86/parser/Makefile
+hw/xfree86/ramdac/Makefile
+hw/xfree86/shadowfb/Makefile
+hw/xfree86/vbe/Makefile
+hw/xfree86/vgahw/Makefile
+hw/xfree86/x86emu/Makefile
+hw/xfree86/utils/Makefile
+hw/xfree86/utils/man/Makefile
+hw/xfree86/utils/cvt/Makefile
+hw/xfree86/utils/gtf/Makefile
+hw/dmx/config/Makefile
+hw/dmx/config/man/Makefile
+hw/dmx/doc/Makefile
+hw/dmx/doxygen/doxygen.conf
+hw/dmx/doxygen/Makefile
+hw/dmx/examples/Makefile
+hw/dmx/input/Makefile
+hw/dmx/glxProxy/Makefile
+hw/dmx/Makefile
+hw/dmx/man/Makefile
+hw/vfb/Makefile
+hw/vfb/man/Makefile
+hw/xnest/Makefile
+hw/xnest/man/Makefile
+hw/xwin/Makefile
+hw/xwin/glx/Makefile
+hw/xwin/man/Makefile
+hw/xquartz/Makefile
+hw/xquartz/GL/Makefile
+hw/xquartz/bundle/Makefile
+hw/xquartz/man/Makefile
+hw/xquartz/mach-startup/Makefile
+hw/xquartz/pbproxy/Makefile
+hw/xquartz/xpr/Makefile
+hw/kdrive/Makefile
+hw/kdrive/ephyr/Makefile
+hw/kdrive/ephyr/man/Makefile
+hw/kdrive/fake/Makefile
+hw/kdrive/fbdev/Makefile
+hw/kdrive/linux/Makefile
+hw/kdrive/src/Makefile
+test/Makefile
+test/xi2/Makefile
+xserver.ent
+xorg-server.pc
+])
diff --git a/hw/xfree86/Makefile.am b/hw/xfree86/Makefile.am
index f190b40..09bbc45 100644
--- a/hw/xfree86/Makefile.am
+++ b/hw/xfree86/Makefile.am
@@ -9,6 +9,10 @@ DRI2_SUBDIR = dri2
 DRI2_LIB = dri2/libdri2.la
 endif
 
+if WAYLAND
+WAYLAND_SUBDIR = xwayland
+endif
+
 if XF86UTILS
 XF86UTILS_SUBDIR = utils
 endif
@@ -19,12 +23,12 @@ endif
 
 SUBDIRS = common ddc x86emu int10 os-support parser \
 	  ramdac $(VGAHW_SUBDIR) loader modes $(DRI_SUBDIR) \
-	  $(DRI2_SUBDIR) . vbe i2c dixmods \
+	  $(DRI2_SUBDIR) $(WAYLAND_SUBDIR) . vbe i2c dixmods \
 	  fbdevhw shadowfb exa $(XF86UTILS_SUBDIR) doc man
 
 DIST_SUBDIRS = common ddc i2c x86emu int10 fbdevhw os-support \
                parser ramdac shadowfb vbe vgahw \
-               loader dixmods dri dri2 exa modes \
+               loader dixmods dri dri2 exa modes xwayland \
 	       utils doc man
 
 bin_PROGRAMS = Xorg
diff --git a/hw/xfree86/Makefile.am.jx b/hw/xfree86/Makefile.am.jx
new file mode 100644
index 0000000..58e5d97
--- /dev/null
+++ b/hw/xfree86/Makefile.am.jx
@@ -0,0 +1,126 @@
+
+if DRI
+DRI_SUBDIR = dri
+DRI_LIB = dri/libdri.la
+endif
+
+if DRI2
+DRI2_SUBDIR = dri2
+DRI2_LIB = dri2/libdri2.la
+endif
+
+if WAYLAND
+WAYLAND_SUBDIR = xwayland
+endif
+
+if XF86UTILS
+XF86UTILS_SUBDIR = utils
+endif
+
+if VGAHW
+VGAHW_SUBDIR = vgahw
+endif
+
+SUBDIRS = common ddc x86emu int10 os-support parser \
+	  ramdac $(VGAHW_SUBDIR) loader modes $(DRI_SUBDIR) \
+	  $(DRI2_SUBDIR) . vbe i2c dixmods \
+	  fbdevhw shadowfb exa $(XF86UTILS_SUBDIR) doc man
+
+DIST_SUBDIRS = common ddc i2c x86emu int10 fbdevhw os-support \
+               parser ramdac shadowfb vbe vgahw \
+               loader dixmods dri dri2 exa modes \
+	       utils doc man
+
+bin_PROGRAMS = Xorg
+nodist_Xorg_SOURCES = sdksyms.c
+
+AM_CFLAGS = $(DIX_CFLAGS) @XORG_CFLAGS@
+INCLUDES = $(XORG_INCS) -I$(srcdir)/parser -I$(top_srcdir)/miext/cw \
+	-I$(srcdir)/ddc -I$(srcdir)/i2c -I$(srcdir)/modes -I$(srcdir)/ramdac \
+	-I$(srcdir)/dri -I$(srcdir)/dri2
+
+LOCAL_LIBS = \
+            $(MAIN_LIB) \
+            $(XSERVER_LIBS) \
+            loader/libloader.la \
+            common/libcommon.la \
+            os-support/libxorgos.la \
+            parser/libxf86config_internal.la \
+            dixmods/libdixmods.la \
+            modes/libxf86modes.la \
+            ramdac/libramdac.la \
+            ddc/libddc.la \
+            i2c/libi2c.la \
+            $(XORG_LIBS) \
+            dixmods/libxorgxkb.la \
+            $(DRI_LIB) \
+            $(DRI2_LIB) \
+            $(top_builddir)/mi/libmi.la \
+            $(top_builddir)/os/libos.la
+Xorg_LDADD = \
+            $(LOCAL_LIBS) \
+            $(XORG_SYS_LIBS) \
+            $(XSERVER_SYS_LIBS)
+Xorg_DEPENDENCIES = $(LOCAL_LIBS)
+
+Xorg_LDFLAGS = $(LD_EXPORT_SYMBOLS_FLAG)
+
+BUILT_SOURCES = xorg.conf.example
+DISTCLEANFILES = xorg.conf.example
+EXTRA_DIST = xorgconf.cpp
+
+if SOLARIS_ASM_INLINE
+# Needs to be built before any files are compiled when using Sun compilers
+# so in*/out* inline definitions are properly processed.
+
+BUILT_SOURCES += os-support/solaris/solaris-@SOLARIS_INOUT_ARCH@.il
+
+os-support/solaris/solaris-@SOLARIS_INOUT_ARCH@.il:
+	cd os-support/solaris ; \
+	 $(MAKE) $(AM_MAKEFLAGS) solaris-@SOLARIS_INOUT_ARCH@.il
+endif
+
+# do not use $(mkdir_p) if you want automake 1.7 to work
+install-data-local:
+	mkdir -p $(DESTDIR)$(logdir)
+
+
+install-exec-local: install-binPROGRAMS
+	(cd $(DESTDIR)$(bindir) && rm -f X && ln -s Xorg X)
+if INSTALL_SETUID
+	chown root $(DESTDIR)$(bindir)/Xorg
+	chmod u+s $(DESTDIR)$(bindir)/Xorg
+endif
+if CYGWIN
+	$(INSTALL_DATA) libXorg.exe.a $(DESTDIR)$(libdir)/libXorg.exe.a
+endif
+
+# Use variables from XORG_MANPAGE_SECTIONS and X Server configuration
+# Do not include manpages.am as values are not appropriate for rc files
+CONF_SUBSTS =	-e 's|__filemansuffix__|$(FILE_MAN_SUFFIX)|g' \
+		-e 's|MODULEPATH|$(DEFAULT_MODULE_PATH)|g' \
+		-e 's|DEFAULTFONTPATH|$(COMPILEDDEFAULTFONTPATH)|g'
+
+xorg.conf.example: xorgconf.cpp
+	$(AM_V_GEN)$(SED) $(CONF_SUBSTS) < $(srcdir)/xorgconf.cpp > $@
+
+relink:
+	$(AM_V_at)rm -f Xorg$(EXEEXT) && $(MAKE) Xorg$(EXEEXT)
+
+CLEANFILES = sdksyms.c sdksyms.dep
+EXTRA_DIST += sdksyms.sh
+
+sdksyms.dep sdksyms.c: sdksyms.sh
+	$(AM_V_GEN)CPP='$(CPP)' AWK='$(AWK)' $(SHELL) $(srcdir)/sdksyms.sh $(top_srcdir) $(CFLAGS) $(AM_CFLAGS) $(INCLUDES)
+
+SDKSYMS_DEP = sdksyms.dep
+include $(SDKSYMS_DEP)
+
+i2c/libi2c.la:
+	$(AM_V_at)cd i2c && $(MAKE) libi2c.la
+
+dixmods/libdixmods.la:
+	$(AM_V_at)cd dixmods && $(MAKE) libdixmods.la
+
+dixmods/libxorgxkb.la:
+	$(AM_V_at)cd dixmods && $(MAKE) libxorgxkb.la
diff --git a/hw/xfree86/Makefile.am.orig b/hw/xfree86/Makefile.am.orig
new file mode 100644
index 0000000..f190b40
--- /dev/null
+++ b/hw/xfree86/Makefile.am.orig
@@ -0,0 +1,122 @@
+
+if DRI
+DRI_SUBDIR = dri
+DRI_LIB = dri/libdri.la
+endif
+
+if DRI2
+DRI2_SUBDIR = dri2
+DRI2_LIB = dri2/libdri2.la
+endif
+
+if XF86UTILS
+XF86UTILS_SUBDIR = utils
+endif
+
+if VGAHW
+VGAHW_SUBDIR = vgahw
+endif
+
+SUBDIRS = common ddc x86emu int10 os-support parser \
+	  ramdac $(VGAHW_SUBDIR) loader modes $(DRI_SUBDIR) \
+	  $(DRI2_SUBDIR) . vbe i2c dixmods \
+	  fbdevhw shadowfb exa $(XF86UTILS_SUBDIR) doc man
+
+DIST_SUBDIRS = common ddc i2c x86emu int10 fbdevhw os-support \
+               parser ramdac shadowfb vbe vgahw \
+               loader dixmods dri dri2 exa modes \
+	       utils doc man
+
+bin_PROGRAMS = Xorg
+nodist_Xorg_SOURCES = sdksyms.c
+
+AM_CFLAGS = $(DIX_CFLAGS) @XORG_CFLAGS@
+INCLUDES = $(XORG_INCS) -I$(srcdir)/parser -I$(top_srcdir)/miext/cw \
+	-I$(srcdir)/ddc -I$(srcdir)/i2c -I$(srcdir)/modes -I$(srcdir)/ramdac \
+	-I$(srcdir)/dri -I$(srcdir)/dri2
+
+LOCAL_LIBS = \
+            $(MAIN_LIB) \
+            $(XSERVER_LIBS) \
+            loader/libloader.la \
+            common/libcommon.la \
+            os-support/libxorgos.la \
+            parser/libxf86config_internal.la \
+            dixmods/libdixmods.la \
+            modes/libxf86modes.la \
+            ramdac/libramdac.la \
+            ddc/libddc.la \
+            i2c/libi2c.la \
+            $(XORG_LIBS) \
+            dixmods/libxorgxkb.la \
+            $(DRI_LIB) \
+            $(DRI2_LIB) \
+            $(top_builddir)/mi/libmi.la \
+            $(top_builddir)/os/libos.la
+Xorg_LDADD = \
+            $(LOCAL_LIBS) \
+            $(XORG_SYS_LIBS) \
+            $(XSERVER_SYS_LIBS)
+Xorg_DEPENDENCIES = $(LOCAL_LIBS)
+
+Xorg_LDFLAGS = $(LD_EXPORT_SYMBOLS_FLAG)
+
+BUILT_SOURCES = xorg.conf.example
+DISTCLEANFILES = xorg.conf.example
+EXTRA_DIST = xorgconf.cpp
+
+if SOLARIS_ASM_INLINE
+# Needs to be built before any files are compiled when using Sun compilers
+# so in*/out* inline definitions are properly processed.
+
+BUILT_SOURCES += os-support/solaris/solaris-@SOLARIS_INOUT_ARCH@.il
+
+os-support/solaris/solaris-@SOLARIS_INOUT_ARCH@.il:
+	cd os-support/solaris ; \
+	 $(MAKE) $(AM_MAKEFLAGS) solaris-@SOLARIS_INOUT_ARCH@.il
+endif
+
+# do not use $(mkdir_p) if you want automake 1.7 to work
+install-data-local:
+	mkdir -p $(DESTDIR)$(logdir)
+
+
+install-exec-local: install-binPROGRAMS
+	(cd $(DESTDIR)$(bindir) && rm -f X && ln -s Xorg X)
+if INSTALL_SETUID
+	chown root $(DESTDIR)$(bindir)/Xorg
+	chmod u+s $(DESTDIR)$(bindir)/Xorg
+endif
+if CYGWIN
+	$(INSTALL_DATA) libXorg.exe.a $(DESTDIR)$(libdir)/libXorg.exe.a
+endif
+
+# Use variables from XORG_MANPAGE_SECTIONS and X Server configuration
+# Do not include manpages.am as values are not appropriate for rc files
+CONF_SUBSTS =	-e 's|__filemansuffix__|$(FILE_MAN_SUFFIX)|g' \
+		-e 's|MODULEPATH|$(DEFAULT_MODULE_PATH)|g' \
+		-e 's|DEFAULTFONTPATH|$(COMPILEDDEFAULTFONTPATH)|g'
+
+xorg.conf.example: xorgconf.cpp
+	$(AM_V_GEN)$(SED) $(CONF_SUBSTS) < $(srcdir)/xorgconf.cpp > $@
+
+relink:
+	$(AM_V_at)rm -f Xorg$(EXEEXT) && $(MAKE) Xorg$(EXEEXT)
+
+CLEANFILES = sdksyms.c sdksyms.dep
+EXTRA_DIST += sdksyms.sh
+
+sdksyms.dep sdksyms.c: sdksyms.sh
+	$(AM_V_GEN)CPP='$(CPP)' AWK='$(AWK)' $(SHELL) $(srcdir)/sdksyms.sh $(top_srcdir) $(CFLAGS) $(AM_CFLAGS) $(INCLUDES)
+
+SDKSYMS_DEP = sdksyms.dep
+include $(SDKSYMS_DEP)
+
+i2c/libi2c.la:
+	$(AM_V_at)cd i2c && $(MAKE) libi2c.la
+
+dixmods/libdixmods.la:
+	$(AM_V_at)cd dixmods && $(MAKE) libdixmods.la
+
+dixmods/libxorgxkb.la:
+	$(AM_V_at)cd dixmods && $(MAKE) libxorgxkb.la
diff --git a/hw/xfree86/Makefile.am.rej b/hw/xfree86/Makefile.am.rej
new file mode 100644
index 0000000..1e1e7ab
--- /dev/null
+++ b/hw/xfree86/Makefile.am.rej
@@ -0,0 +1,17 @@
+--- hw/xfree86/Makefile.am
++++ hw/xfree86/Makefile.am
+@@ -31,12 +35,12 @@
+ 
+ SUBDIRS = common ddc x86emu $(INT10_SUBDIR) os-support parser \
+ 	  ramdac $(VGAHW_SUBDIR) loader modes $(DRI_SUBDIR) \
+-	  $(DRI2_SUBDIR) . $(VBE_SUBDIR) i2c dixmods \
++	  $(DRI2_SUBDIR)  $(WAYLAND_SUBDIR) . $(VBE_SUBDIR) i2c dixmods \
+ 	  fbdevhw shadowfb exa $(XF86UTILS_SUBDIR) doc man
+ 
+ DIST_SUBDIRS = common ddc i2c x86emu int10 fbdevhw os-support \
+                parser ramdac shadowfb vbe vgahw \
+-               loader dixmods dri dri2 exa modes \
++               loader dixmods dri dri2 exa modes xwayland \
+ 	       utils doc man
+ 
+ bin_PROGRAMS = Xorg
diff --git a/hw/xfree86/common/xf86Config.c b/hw/xfree86/common/xf86Config.c
index 486752b..55f9883 100644
--- a/hw/xfree86/common/xf86Config.c
+++ b/hw/xfree86/common/xf86Config.c
@@ -117,7 +117,8 @@ static ModuleDefault ModuleDefaults[] = {
     {.name = "fb",.toLoad = TRUE,.load_opt = NULL},
     {.name = "shadow",.toLoad = TRUE,.load_opt = NULL},
 #endif
-    {.name = NULL,.toLoad = FALSE,.load_opt = NULL}
+    {.name = "xwayland",.toLoad = FALSE,.load_opt=NULL},
+    {.name = NULL,.toLoad = FALSE,.load_opt=NULL}
 };
 
 /* Forward declarations */
@@ -259,6 +260,17 @@ xf86ModulelistFromConfig(pointer **optlist)
         return NULL;
     }
 
+    /*
+     * Set the xwayland module to autoload if requested.
+     */
+    if (xorgWayland) {
+        for (i=0 ; ModuleDefaults[i].name != NULL ; i++) {
+            if (strcmp(ModuleDefaults[i].name, "xwayland") == 0) {
+                ModuleDefaults[i].toLoad = TRUE;
+            }
+        }
+    }
+
     if (xf86configptr->conf_modules) {
         /* Walk the disable list and let people know what we've parsed to
          * not be loaded 
@@ -862,6 +874,13 @@ configServerFlags(XF86ConfFlagsPtr flagsconf, XF86OptionPtr layoutopts)
     }
     xf86Msg(from, "%sutomatically adding GPU devices\n",
             xf86Info.autoAddGPU ? "A" : "Not a");
+
+    /* FIXME: Do that at the right place (before xf86Msg). */
+    if (xorgWayland) {
+            xf86Info.autoAddDevices = FALSE;
+            xf86Info.autoEnableDevices = FALSE;
+    }
+
     /*
      * Set things up based on the config file information.  Some of these
      * settings may be overridden later when the command line options are
@@ -952,9 +971,10 @@ configServerFlags(XF86ConfFlagsPtr flagsconf, XF86OptionPtr layoutopts)
     }
 #endif
 
-    /* if we're not hotplugging, force some input devices to exist */
-    xf86Info.forceInputDevices = !(xf86Info.autoAddDevices &&
-                                   xf86Info.autoEnableDevices);
+    if (xorgWayland) /* Don't force input devices */
+	xf86Info.forceInputDevices = FALSE;
+    else /* if we're not hotplugging, force some input devices to exist */
+	xf86Info.forceInputDevices = !(xf86Info.autoAddDevices && xf86Info.autoEnableDevices);
 
     /* when forcing input devices, we use kbd. otherwise evdev, so use the
      * evdev rules set. */
diff --git a/hw/xfree86/common/xf86Globals.c b/hw/xfree86/common/xf86Globals.c
index 7df7a80..b41d2cc 100644
--- a/hw/xfree86/common/xf86Globals.c
+++ b/hw/xfree86/common/xf86Globals.c
@@ -204,3 +204,5 @@ Bool xf86VidModeAllowNonLocal = FALSE;
 #endif
 RootWinPropPtr *xf86RegisteredPropertiesTable = NULL;
 Bool xorgHWAccess = FALSE;
+Bool xorgWayland = FALSE;
+Bool xorgRootless = FALSE;
diff --git a/hw/xfree86/common/xf86Init.c b/hw/xfree86/common/xf86Init.c
index f95eec5..629d892 100644
--- a/hw/xfree86/common/xf86Init.c
+++ b/hw/xfree86/common/xf86Init.c
@@ -556,6 +556,13 @@ InitOutput(ScreenInfo * pScreenInfo, int argc, char **argv)
 
             if (!(flags & HW_SKIP_CONSOLE))
                 xorgHWOpenConsole = TRUE;
+
+	    if (xorgWayland &&
+		(NEED_IO_ENABLED(flags) || !(flags & HW_SKIP_CONSOLE))) {
+
+		xf86DeleteDriver(i);
+		continue;
+	    }
         }
 
         if (xorgHWOpenConsole)
@@ -969,6 +976,9 @@ InitInput(int argc, char **argv)
 
     mieqInit();
 
+    if (xorgWayland)
+	return;
+
     /* Initialize all configured input devices */
     for (pInfo = xf86ConfigLayout.inputs; pInfo && *pInfo; pInfo++) {
         (*pInfo)->options =
@@ -1467,6 +1477,16 @@ ddxProcessArgument(int argc, char **argv, int i)
         return 1;
     }
 
+    if (!strcmp(argv[i], "-wayland")) {
+        xorgWayland = TRUE;
+        return 1;
+    }
+
+    if (!strcmp(argv[i], "-rootless")) {
+        xorgRootless = TRUE;
+        return 1;
+    }
+
     /* OS-specific processing */
     return xf86ProcessArgument(argc, argv, i);
 }
diff --git a/hw/xfree86/common/xf86Init.c.orig b/hw/xfree86/common/xf86Init.c.orig
new file mode 100644
index 0000000..f95eec5
--- /dev/null
+++ b/hw/xfree86/common/xf86Init.c.orig
@@ -0,0 +1,1656 @@
+/*
+ * Loosely based on code bearing the following copyright:
+ *
+ *   Copyright 1990,91 by Thomas Roell, Dinkelscherben, Germany.
+ */
+/*
+ * Copyright (c) 1992-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include <stdlib.h>
+#include <errno.h>
+
+#undef HAS_UTSNAME
+#if !defined(WIN32)
+#define HAS_UTSNAME 1
+#include <sys/utsname.h>
+#endif
+
+#include <X11/X.h>
+#include <X11/Xmd.h>
+#include <X11/Xproto.h>
+#include <X11/Xatom.h>
+#include "input.h"
+#include "servermd.h"
+#include "windowstr.h"
+#include "scrnintstr.h"
+#include "site.h"
+#include "mi.h"
+
+#include "compiler.h"
+
+#include "loaderProcs.h"
+#ifdef XFreeXDGA
+#include "dgaproc.h"
+#endif
+
+#define XF86_OS_PRIVS
+#include "xf86.h"
+#include "xf86Priv.h"
+#include "xf86Config.h"
+#include "xf86_OSlib.h"
+#include "xf86cmap.h"
+#include "xorgVersion.h"
+#include "xf86Build.h"
+#include "mipointer.h"
+#include <X11/extensions/XI.h>
+#include <X11/extensions/XIproto.h>
+#include "xf86DDC.h"
+#include "xf86Xinput.h"
+#include "xf86InPriv.h"
+#include "picturestr.h"
+
+#include "xf86Bus.h"
+#ifdef XSERVER_LIBPCIACCESS
+#include "xf86VGAarbiter.h"
+#endif
+#include "globals.h"
+#include "xserver-properties.h"
+
+#ifdef DPMSExtension
+#include <X11/extensions/dpmsconst.h>
+#include "dpmsproc.h"
+#endif
+#include <hotplug.h>
+
+#ifdef XF86PM
+void (*xf86OSPMClose) (void) = NULL;
+#endif
+static Bool xorgHWOpenConsole = FALSE;
+
+/* Common pixmap formats */
+
+static PixmapFormatRec formats[MAXFORMATS] = {
+    {1, 1, BITMAP_SCANLINE_PAD},
+    {4, 8, BITMAP_SCANLINE_PAD},
+    {8, 8, BITMAP_SCANLINE_PAD},
+    {15, 16, BITMAP_SCANLINE_PAD},
+    {16, 16, BITMAP_SCANLINE_PAD},
+    {24, 32, BITMAP_SCANLINE_PAD},
+    {32, 32, BITMAP_SCANLINE_PAD},
+};
+
+static int numFormats = 7;
+static Bool formatsDone = FALSE;
+
+#ifndef OSNAME
+#define OSNAME " unknown"
+#endif
+#ifndef OSVENDOR
+#define OSVENDOR ""
+#endif
+#ifndef PRE_RELEASE
+#define PRE_RELEASE XORG_VERSION_SNAP
+#endif
+
+static void
+xf86PrintBanner(void)
+{
+#if PRE_RELEASE
+    xf86ErrorFVerb(0, "\n"
+                   "This is a pre-release version of the X server from "
+                   XVENDORNAME ".\n" "It is not supported in any way.\n"
+                   "Bugs may be filed in the bugzilla at http://bugs.freedesktop.org/.\n"
+                   "Select the \"xorg\" product for bugs you find in this release.\n"
+                   "Before reporting bugs in pre-release versions please check the\n"
+                   "latest version in the X.Org Foundation git repository.\n"
+                   "See http://wiki.x.org/wiki/GitPage for git access instructions.\n");
+#endif
+    xf86ErrorFVerb(0, "\nX.Org X Server %d.%d.%d",
+                   XORG_VERSION_MAJOR, XORG_VERSION_MINOR, XORG_VERSION_PATCH);
+#if XORG_VERSION_SNAP > 0
+    xf86ErrorFVerb(0, ".%d", XORG_VERSION_SNAP);
+#endif
+
+#if XORG_VERSION_SNAP >= 900
+    /* When the minor number is 99, that signifies that the we are making
+     * a release candidate for a major version.  (X.0.0)
+     * When the patch number is 99, that signifies that the we are making
+     * a release candidate for a minor version.  (X.Y.0)
+     * When the patch number is < 99, then we are making a release
+     * candidate for the next point release.  (X.Y.Z)
+     */
+#if XORG_VERSION_MINOR >= 99
+    xf86ErrorFVerb(0, " (%d.0.0 RC %d)", XORG_VERSION_MAJOR + 1,
+                   XORG_VERSION_SNAP - 900);
+#elif XORG_VERSION_PATCH == 99
+    xf86ErrorFVerb(0, " (%d.%d.0 RC %d)", XORG_VERSION_MAJOR,
+                   XORG_VERSION_MINOR + 1, XORG_VERSION_SNAP - 900);
+#else
+    xf86ErrorFVerb(0, " (%d.%d.%d RC %d)", XORG_VERSION_MAJOR,
+                   XORG_VERSION_MINOR, XORG_VERSION_PATCH + 1,
+                   XORG_VERSION_SNAP - 900);
+#endif
+#endif
+
+#ifdef XORG_CUSTOM_VERSION
+    xf86ErrorFVerb(0, " (%s)", XORG_CUSTOM_VERSION);
+#endif
+#ifndef XORG_DATE
+#define XORG_DATE "Unknown"
+#endif
+    xf86ErrorFVerb(0, "\nRelease Date: %s\n", XORG_DATE);
+    xf86ErrorFVerb(0, "X Protocol Version %d, Revision %d\n",
+                   X_PROTOCOL, X_PROTOCOL_REVISION);
+    xf86ErrorFVerb(0, "Build Operating System: %s %s\n", OSNAME, OSVENDOR);
+#ifdef HAS_UTSNAME
+    {
+        struct utsname name;
+
+        /* Linux & BSD state that 0 is success, SysV (including Solaris, HP-UX,
+           and Irix) and Single Unix Spec 3 just say that non-negative is success.
+           All agree that failure is represented by a negative number.
+         */
+        if (uname(&name) >= 0) {
+            xf86ErrorFVerb(0, "Current Operating System: %s %s %s %s %s\n",
+                           name.sysname, name.nodename, name.release,
+                           name.version, name.machine);
+#ifdef linux
+            do {
+                char buf[80];
+                int fd = open("/proc/cmdline", O_RDONLY);
+
+                if (fd != -1) {
+                    xf86ErrorFVerb(0, "Kernel command line: ");
+                    memset(buf, 0, 80);
+                    while (read(fd, buf, 80) > 0) {
+                        xf86ErrorFVerb(0, "%.80s", buf);
+                        memset(buf, 0, 80);
+                    }
+                    close(fd);
+                }
+            } while (0);
+#endif
+        }
+    }
+#endif
+#if defined(BUILD_DATE) && (BUILD_DATE > 19000000)
+    {
+        struct tm t;
+        char buf[100];
+
+        memset(&t, 0, sizeof(t));
+        memset(buf, 0, sizeof(buf));
+        t.tm_mday = BUILD_DATE % 100;
+        t.tm_mon = (BUILD_DATE / 100) % 100 - 1;
+        t.tm_year = BUILD_DATE / 10000 - 1900;
+#if defined(BUILD_TIME)
+        t.tm_sec = BUILD_TIME % 100;
+        t.tm_min = (BUILD_TIME / 100) % 100;
+        t.tm_hour = (BUILD_TIME / 10000) % 100;
+        if (strftime(buf, sizeof(buf), "%d %B %Y  %I:%M:%S%p", &t))
+            xf86ErrorFVerb(0, "Build Date: %s\n", buf);
+#else
+        if (strftime(buf, sizeof(buf), "%d %B %Y", &t))
+            xf86ErrorFVerb(0, "Build Date: %s\n", buf);
+#endif
+    }
+#endif
+#if defined(BUILDERSTRING)
+    xf86ErrorFVerb(0, "%s \n", BUILDERSTRING);
+#endif
+    xf86ErrorFVerb(0, "Current version of pixman: %s\n",
+                   pixman_version_string());
+    xf86ErrorFVerb(0, "\tBefore reporting problems, check "
+                   "" __VENDORDWEBSUPPORT__ "\n"
+                   "\tto make sure that you have the latest version.\n");
+}
+
+static void
+xf86PrintMarkers(void)
+{
+    LogPrintMarkers();
+}
+
+Bool
+xf86PrivsElevated(void)
+{
+    static Bool privsTested = FALSE;
+    static Bool privsElevated = TRUE;
+
+    if (!privsTested) {
+#if defined(WIN32)
+        privsElevated = FALSE;
+#else
+        if ((getuid() != geteuid()) || (getgid() != getegid())) {
+            privsElevated = TRUE;
+        }
+        else {
+#if defined(HAVE_ISSETUGID)
+            privsElevated = issetugid();
+#elif defined(HAVE_GETRESUID)
+            uid_t ruid, euid, suid;
+            gid_t rgid, egid, sgid;
+
+            if ((getresuid(&ruid, &euid, &suid) == 0) &&
+                (getresgid(&rgid, &egid, &sgid) == 0)) {
+                privsElevated = (euid != suid) || (egid != sgid);
+            }
+            else {
+                printf("Failed getresuid or getresgid");
+                /* Something went wrong, make defensive assumption */
+                privsElevated = TRUE;
+            }
+#else
+            if (getuid() == 0) {
+                /* running as root: uid==euid==0 */
+                privsElevated = FALSE;
+            }
+            else {
+                /*
+                 * If there are saved ID's the process might still be privileged
+                 * even though the above test succeeded. If issetugid() and
+                 * getresgid() aren't available, test this by trying to set
+                 * euid to 0.
+                 */
+                unsigned int oldeuid;
+
+                oldeuid = geteuid();
+
+                if (seteuid(0) != 0) {
+                    privsElevated = FALSE;
+                }
+                else {
+                    if (seteuid(oldeuid) != 0) {
+                        FatalError("Failed to drop privileges.  Exiting\n");
+                    }
+                    privsElevated = TRUE;
+                }
+            }
+#endif
+        }
+#endif
+        privsTested = TRUE;
+    }
+    return privsElevated;
+}
+
+static Bool
+xf86CreateRootWindow(WindowPtr pWin)
+{
+    int ret = TRUE;
+    int err = Success;
+    ScreenPtr pScreen = pWin->drawable.pScreen;
+    RootWinPropPtr pProp;
+    CreateWindowProcPtr CreateWindow = (CreateWindowProcPtr)
+        dixLookupPrivate(&pScreen->devPrivates, xf86CreateRootWindowKey);
+
+    DebugF("xf86CreateRootWindow(%p)\n", pWin);
+
+    if (pScreen->CreateWindow != xf86CreateRootWindow) {
+        /* Can't find hook we are hung on */
+        xf86DrvMsg(pScreen->myNum, X_WARNING /* X_ERROR */ ,
+                   "xf86CreateRootWindow %p called when not in pScreen->CreateWindow %p n",
+                   (void *) xf86CreateRootWindow,
+                   (void *) pScreen->CreateWindow);
+    }
+
+    /* Unhook this function ... */
+    pScreen->CreateWindow = CreateWindow;
+    dixSetPrivate(&pScreen->devPrivates, xf86CreateRootWindowKey, NULL);
+
+    /* ... and call the previous CreateWindow fuction, if any */
+    if (NULL != pScreen->CreateWindow) {
+        ret = (*pScreen->CreateWindow) (pWin);
+    }
+
+    /* Now do our stuff */
+    if (xf86RegisteredPropertiesTable != NULL) {
+        if (pWin->parent == NULL && xf86RegisteredPropertiesTable != NULL) {
+            for (pProp = xf86RegisteredPropertiesTable[pScreen->myNum];
+                 pProp != NULL && err == Success; pProp = pProp->next) {
+                Atom prop;
+
+                prop = MakeAtom(pProp->name, strlen(pProp->name), TRUE);
+                err = dixChangeWindowProperty(serverClient, pWin,
+                                              prop, pProp->type,
+                                              pProp->format, PropModeReplace,
+                                              pProp->size, pProp->data, FALSE);
+            }
+
+            /* Look at err */
+            ret &= (err == Success);
+
+        }
+        else {
+            xf86Msg(X_ERROR, "xf86CreateRootWindow unexpectedly called with "
+                    "non-root window %p (parent %p)\n",
+                    (void *) pWin, (void *) pWin->parent);
+            ret = FALSE;
+        }
+    }
+
+    DebugF("xf86CreateRootWindow() returns %d\n", ret);
+    return ret;
+}
+
+extern void xf86AutoConfigOutputDevice(ScrnInfoPtr pScrn, ScrnInfoPtr master);
+static void
+xf86AutoConfigOutputDevices(void)
+{
+    int i;
+
+    for (i = 0; i < xf86NumGPUScreens; i++)
+        xf86AutoConfigOutputDevice(xf86GPUScreens[i], xf86Screens[0]);
+}
+
+static void
+InstallSignalHandlers(void)
+{
+    /*
+     * Install signal handler for unexpected signals
+     */
+    xf86Info.caughtSignal = FALSE;
+    if (!xf86Info.notrapSignals) {
+        OsRegisterSigWrapper(xf86SigWrapper);
+    }
+    else {
+        signal(SIGSEGV, SIG_DFL);
+        signal(SIGILL, SIG_DFL);
+#ifdef SIGEMT
+        signal(SIGEMT, SIG_DFL);
+#endif
+        signal(SIGFPE, SIG_DFL);
+        signal(SIGBUS, SIG_DFL);
+        signal(SIGSYS, SIG_DFL);
+        signal(SIGXCPU, SIG_DFL);
+        signal(SIGXFSZ, SIG_DFL);
+    }
+}
+
+/*
+ * InitOutput --
+ *	Initialize screenInfo for all actually accessible framebuffers.
+ *      That includes vt-manager setup, querying all possible devices and
+ *      collecting the pixmap formats.
+ */
+void
+InitOutput(ScreenInfo * pScreenInfo, int argc, char **argv)
+{
+    int i, j, k, scr_index;
+    char **modulelist;
+    pointer *optionlist;
+    Pix24Flags screenpix24, pix24;
+    MessageType pix24From = X_DEFAULT;
+    Bool pix24Fail = FALSE;
+    Bool autoconfig = FALSE;
+    Bool sigio_blocked = FALSE;
+    Bool want_hw_access = FALSE;
+    GDevPtr configured_device;
+
+    xf86Initialising = TRUE;
+
+    config_pre_init();
+
+    if (serverGeneration == 1) {
+        if ((xf86ServerName = strrchr(argv[0], '/')) != 0)
+            xf86ServerName++;
+        else
+            xf86ServerName = argv[0];
+
+        xf86PrintBanner();
+        xf86PrintMarkers();
+        if (xf86LogFile) {
+            time_t t;
+            const char *ct;
+
+            t = time(NULL);
+            ct = ctime(&t);
+            xf86MsgVerb(xf86LogFileFrom, 0, "Log file: \"%s\", Time: %s",
+                        xf86LogFile, ct);
+        }
+
+        /* Read and parse the config file */
+        if (!xf86DoConfigure && !xf86DoShowOptions) {
+            switch (xf86HandleConfigFile(FALSE)) {
+            case CONFIG_OK:
+                break;
+            case CONFIG_PARSE_ERROR:
+                xf86Msg(X_ERROR, "Error parsing the config file\n");
+                return;
+            case CONFIG_NOFILE:
+                autoconfig = TRUE;
+                break;
+            }
+        }
+
+        InstallSignalHandlers();
+
+        /* Initialise the loader */
+        LoaderInit();
+
+        /* Tell the loader the default module search path */
+        LoaderSetPath(xf86ModulePath);
+
+        if (xf86Info.ignoreABI) {
+            LoaderSetOptions(LDR_OPT_ABI_MISMATCH_NONFATAL);
+        }
+
+        if (xf86DoShowOptions)
+            DoShowOptions();
+
+        /* Do a general bus probe.  This will be a PCI probe for x86 platforms */
+        xf86BusProbe();
+
+        if (xf86DoConfigure)
+            DoConfigure();
+
+        if (autoconfig) {
+            if (!xf86AutoConfig()) {
+                xf86Msg(X_ERROR, "Auto configuration failed\n");
+                return;
+            }
+        }
+
+#ifdef XF86PM
+        xf86OSPMClose = xf86OSPMOpen();
+#endif
+
+        xf86ExtensionInit();
+
+        /* Load all modules specified explicitly in the config file */
+        if ((modulelist = xf86ModulelistFromConfig(&optionlist))) {
+            xf86LoadModules(modulelist, optionlist);
+            free(modulelist);
+            free(optionlist);
+        }
+
+        /* Load all driver modules specified in the config file */
+        /* If there aren't any specified in the config file, autoconfig them */
+        /* FIXME: Does not handle multiple active screen sections, but I'm not
+         * sure if we really want to handle that case*/
+        configured_device = xf86ConfigLayout.screens->screen->device;
+        if ((!configured_device) || (!configured_device->driver)) {
+            if (!autoConfigDevice(configured_device)) {
+                xf86Msg(X_ERROR, "Automatic driver configuration failed\n");
+                return;
+            }
+        }
+        if ((modulelist = xf86DriverlistFromConfig())) {
+            xf86LoadModules(modulelist, NULL);
+            free(modulelist);
+        }
+
+        /* Load all input driver modules specified in the config file. */
+        if ((modulelist = xf86InputDriverlistFromConfig())) {
+            xf86LoadModules(modulelist, NULL);
+            free(modulelist);
+        }
+
+        /*
+         * It is expected that xf86AddDriver()/xf86AddInputDriver will be
+         * called for each driver as it is loaded.  Those functions save the
+         * module pointers for drivers.
+         * XXX Nothing keeps track of them for other modules.
+         */
+        /* XXX What do we do if not all of these could be loaded? */
+
+        /*
+         * At this point, xf86DriverList[] is all filled in with entries for
+         * each of the drivers to try and xf86NumDrivers has the number of
+         * drivers.  If there are none, return now.
+         */
+
+        if (xf86NumDrivers == 0) {
+            xf86Msg(X_ERROR, "No drivers available.\n");
+            return;
+        }
+
+        /*
+         * Call each of the Identify functions and call the driverFunc to check
+         * if HW access is required.  The Identify functions print out some
+         * identifying information, and anything else that might be
+         * needed at this early stage.
+         */
+
+        for (i = 0; i < xf86NumDrivers; i++) {
+            xorgHWFlags flags = HW_IO;
+
+            if (xf86DriverList[i]->Identify != NULL)
+                xf86DriverList[i]->Identify(0);
+
+            if (xf86DriverList[i]->driverFunc)
+                xf86DriverList[i]->driverFunc(NULL,
+                                              GET_REQUIRED_HW_INTERFACES,
+                                              &flags);
+
+            if (NEED_IO_ENABLED(flags))
+                want_hw_access = TRUE;
+
+            if (!(flags & HW_SKIP_CONSOLE))
+                xorgHWOpenConsole = TRUE;
+        }
+
+        if (xorgHWOpenConsole)
+            xf86OpenConsole();
+        else
+            xf86Info.dontVTSwitch = TRUE;
+
+	/* Enable full I/O access */
+	if (want_hw_access)
+	    xorgHWAccess = xf86EnableIO();
+
+        if (xf86BusConfig() == FALSE)
+            return;
+
+        xf86PostProbe();
+
+        /*
+         * Sort the drivers to match the requested ording.  Using a slow
+         * bubble sort.
+         */
+        for (j = 0; j < xf86NumScreens - 1; j++) {
+            for (i = 0; i < xf86NumScreens - j - 1; i++) {
+                if (xf86Screens[i + 1]->confScreen->screennum <
+                    xf86Screens[i]->confScreen->screennum) {
+                    ScrnInfoPtr tmpScrn = xf86Screens[i + 1];
+
+                    xf86Screens[i + 1] = xf86Screens[i];
+                    xf86Screens[i] = tmpScrn;
+                }
+            }
+        }
+        /* Fix up the indexes */
+        for (i = 0; i < xf86NumScreens; i++) {
+            xf86Screens[i]->scrnIndex = i;
+        }
+
+        /*
+         * Call the driver's PreInit()'s to complete initialisation for the first
+         * generation.
+         */
+
+        for (i = 0; i < xf86NumScreens; i++) {
+            xf86VGAarbiterScrnInit(xf86Screens[i]);
+            xf86VGAarbiterLock(xf86Screens[i]);
+            if (xf86Screens[i]->PreInit &&
+                xf86Screens[i]->PreInit(xf86Screens[i], 0))
+                xf86Screens[i]->configured = TRUE;
+            xf86VGAarbiterUnlock(xf86Screens[i]);
+        }
+        for (i = 0; i < xf86NumScreens; i++)
+            if (!xf86Screens[i]->configured)
+                xf86DeleteScreen(xf86Screens[i--]);
+
+        for (i = 0; i < xf86NumGPUScreens; i++) {
+            xf86VGAarbiterScrnInit(xf86GPUScreens[i]);
+            xf86VGAarbiterLock(xf86GPUScreens[i]);
+            if (xf86GPUScreens[i]->PreInit &&
+                xf86GPUScreens[i]->PreInit(xf86GPUScreens[i], 0))
+                xf86GPUScreens[i]->configured = TRUE;
+            xf86VGAarbiterUnlock(xf86GPUScreens[i]);
+        }
+        for (i = 0; i < xf86NumGPUScreens; i++)
+            if (!xf86GPUScreens[i]->configured)
+                xf86DeleteScreen(xf86GPUScreens[i--]);
+
+        /*
+         * If no screens left, return now.
+         */
+
+        if (xf86NumScreens == 0) {
+            xf86Msg(X_ERROR,
+                    "Screen(s) found, but none have a usable configuration.\n");
+            return;
+        }
+
+        for (i = 0; i < xf86NumScreens; i++) {
+            if (xf86Screens[i]->name == NULL) {
+                XNFasprintf(&xf86Screens[i]->name, "screen%d", i);
+                xf86MsgVerb(X_WARNING, 0,
+                            "Screen driver %d has no name set, using `%s'.\n",
+                            i, xf86Screens[i]->name);
+            }
+        }
+
+        /* Remove (unload) drivers that are not required */
+        for (i = 0; i < xf86NumDrivers; i++)
+            if (xf86DriverList[i] && xf86DriverList[i]->refCount <= 0)
+                xf86DeleteDriver(i);
+
+        /*
+         * At this stage we know how many screens there are.
+         */
+
+        for (i = 0; i < xf86NumScreens; i++)
+            xf86InitViewport(xf86Screens[i]);
+
+        /*
+         * Collect all pixmap formats and check for conflicts at the display
+         * level.  Should we die here?  Or just delete the offending screens?
+         */
+        screenpix24 = Pix24DontCare;
+        for (i = 0; i < xf86NumScreens; i++) {
+            if (xf86Screens[i]->imageByteOrder !=
+                xf86Screens[0]->imageByteOrder)
+                FatalError("Inconsistent display bitmapBitOrder.  Exiting\n");
+            if (xf86Screens[i]->bitmapScanlinePad !=
+                xf86Screens[0]->bitmapScanlinePad)
+                FatalError
+                    ("Inconsistent display bitmapScanlinePad.  Exiting\n");
+            if (xf86Screens[i]->bitmapScanlineUnit !=
+                xf86Screens[0]->bitmapScanlineUnit)
+                FatalError
+                    ("Inconsistent display bitmapScanlineUnit.  Exiting\n");
+            if (xf86Screens[i]->bitmapBitOrder !=
+                xf86Screens[0]->bitmapBitOrder)
+                FatalError("Inconsistent display bitmapBitOrder.  Exiting\n");
+
+            /* Determine the depth 24 pixmap format the screens would like */
+            if (xf86Screens[i]->pixmap24 != Pix24DontCare) {
+                if (screenpix24 == Pix24DontCare)
+                    screenpix24 = xf86Screens[i]->pixmap24;
+                else if (screenpix24 != xf86Screens[i]->pixmap24)
+                    FatalError
+                        ("Inconsistent depth 24 pixmap format.  Exiting\n");
+            }
+        }
+        /* check if screenpix24 is consistent with the config/cmdline */
+        if (xf86Info.pixmap24 != Pix24DontCare) {
+            pix24 = xf86Info.pixmap24;
+            pix24From = xf86Info.pix24From;
+            if (screenpix24 != Pix24DontCare &&
+                screenpix24 != xf86Info.pixmap24)
+                pix24Fail = TRUE;
+        }
+        else if (screenpix24 != Pix24DontCare) {
+            pix24 = screenpix24;
+            pix24From = X_PROBED;
+        }
+        else
+            pix24 = Pix24Use32;
+
+        if (pix24Fail)
+            FatalError("Screen(s) can't use the required depth 24 pixmap format"
+                       " (%d).  Exiting\n", PIX24TOBPP(pix24));
+
+        /* Initialise the depth 24 format */
+        for (j = 0; j < numFormats && formats[j].depth != 24; j++);
+        formats[j].bitsPerPixel = PIX24TOBPP(pix24);
+
+        /* Collect additional formats */
+        for (i = 0; i < xf86NumScreens; i++) {
+            for (j = 0; j < xf86Screens[i]->numFormats; j++) {
+                for (k = 0;; k++) {
+                    if (k >= numFormats) {
+                        if (k >= MAXFORMATS)
+                            FatalError("Too many pixmap formats!  Exiting\n");
+                        formats[k] = xf86Screens[i]->formats[j];
+                        numFormats++;
+                        break;
+                    }
+                    if (formats[k].depth == xf86Screens[i]->formats[j].depth) {
+                        if ((formats[k].bitsPerPixel ==
+                             xf86Screens[i]->formats[j].bitsPerPixel) &&
+                            (formats[k].scanlinePad ==
+                             xf86Screens[i]->formats[j].scanlinePad))
+                            break;
+                        FatalError("Inconsistent pixmap format for depth %d."
+                                   "  Exiting\n", formats[k].depth);
+                    }
+                }
+            }
+        }
+        formatsDone = TRUE;
+
+        if (xf86Info.vtno >= 0) {
+#define VT_ATOM_NAME         "XFree86_VT"
+            Atom VTAtom = -1;
+            CARD32 *VT = NULL;
+            int ret;
+
+            /* This memory needs to stay available until the screen has been
+               initialized, and we can create the property for real.
+             */
+            if ((VT = malloc(sizeof(CARD32))) == NULL) {
+                FatalError
+                    ("Unable to make VT property - out of memory. Exiting...\n");
+            }
+            *VT = xf86Info.vtno;
+
+            VTAtom = MakeAtom(VT_ATOM_NAME, sizeof(VT_ATOM_NAME) - 1, TRUE);
+
+            for (i = 0, ret = Success; i < xf86NumScreens && ret == Success;
+                 i++) {
+                ret =
+                    xf86RegisterRootWindowProperty(xf86Screens[i]->scrnIndex,
+                                                   VTAtom, XA_INTEGER, 32, 1,
+                                                   VT);
+                if (ret != Success)
+                    xf86DrvMsg(xf86Screens[i]->scrnIndex, X_WARNING,
+                               "Failed to register VT property\n");
+            }
+        }
+
+        if (SeatId) {
+            Atom SeatAtom;
+
+            SeatAtom =
+                MakeAtom(SEAT_ATOM_NAME, sizeof(SEAT_ATOM_NAME) - 1, TRUE);
+
+            for (i = 0; i < xf86NumScreens; i++) {
+                int ret;
+
+                ret = xf86RegisterRootWindowProperty(xf86Screens[i]->scrnIndex,
+                                                     SeatAtom, XA_STRING, 8,
+                                                     strlen(SeatId) + 1,
+                                                     SeatId);
+                if (ret != Success) {
+                    xf86DrvMsg(xf86Screens[i]->scrnIndex, X_WARNING,
+                               "Failed to register seat property\n");
+                }
+            }
+        }
+
+        /* If a screen uses depth 24, show what the pixmap format is */
+        for (i = 0; i < xf86NumScreens; i++) {
+            if (xf86Screens[i]->depth == 24) {
+                xf86Msg(pix24From, "Depth 24 pixmap format is %d bpp\n",
+                        PIX24TOBPP(pix24));
+                break;
+            }
+        }
+    }
+    else {
+        /*
+         * serverGeneration != 1; some OSs have to do things here, too.
+         */
+        if (xorgHWOpenConsole)
+            xf86OpenConsole();
+
+#ifdef XF86PM
+        /*
+           should we reopen it here? We need to deal with an already opened
+           device. We could leave this to the OS layer. For now we simply
+           close it here
+         */
+        if (xf86OSPMClose)
+            xf86OSPMClose();
+        if ((xf86OSPMClose = xf86OSPMOpen()) != NULL)
+            xf86MsgVerb(X_INFO, 3, "APM registered successfully\n");
+#endif
+
+        /* Make sure full I/O access is enabled */
+        if (xorgHWAccess)
+            xf86EnableIO();
+    }
+
+    /*
+     * Use the previously collected parts to setup pScreenInfo
+     */
+
+    pScreenInfo->imageByteOrder = xf86Screens[0]->imageByteOrder;
+    pScreenInfo->bitmapScanlinePad = xf86Screens[0]->bitmapScanlinePad;
+    pScreenInfo->bitmapScanlineUnit = xf86Screens[0]->bitmapScanlineUnit;
+    pScreenInfo->bitmapBitOrder = xf86Screens[0]->bitmapBitOrder;
+    pScreenInfo->numPixmapFormats = numFormats;
+    for (i = 0; i < numFormats; i++)
+        pScreenInfo->formats[i] = formats[i];
+
+    /* Make sure the server's VT is active */
+
+    if (serverGeneration != 1) {
+        xf86Resetting = TRUE;
+        /* All screens are in the same state, so just check the first */
+        if (!xf86VTOwner()) {
+#ifdef HAS_USL_VTS
+            ioctl(xf86Info.consoleFd, VT_RELDISP, VT_ACKACQ);
+#endif
+            xf86AccessEnter();
+            OsBlockSIGIO();
+            sigio_blocked = TRUE;
+        }
+    }
+
+    for (i = 0; i < xf86NumScreens; i++)
+        if (!xf86ColormapAllocatePrivates(xf86Screens[i]))
+            FatalError("Cannot register DDX private keys");
+
+    if (!dixRegisterPrivateKey(&xf86ScreenKeyRec, PRIVATE_SCREEN, 0) ||
+        !dixRegisterPrivateKey(&xf86CreateRootWindowKeyRec, PRIVATE_SCREEN, 0))
+        FatalError("Cannot register DDX private keys");
+
+    for (i = 0; i < xf86NumGPUScreens; i++) {
+        ScrnInfoPtr pScrn = xf86GPUScreens[i];
+        xf86VGAarbiterLock(pScrn);
+
+        /*
+         * Almost everything uses these defaults, and many of those that
+         * don't, will wrap them.
+         */
+        pScrn->EnableDisableFBAccess = xf86EnableDisableFBAccess;
+#ifdef XFreeXDGA
+        pScrn->SetDGAMode = xf86SetDGAMode;
+#endif
+        pScrn->DPMSSet = NULL;
+        pScrn->LoadPalette = NULL;
+        pScrn->SetOverscan = NULL;
+        pScrn->DriverFunc = NULL;
+        pScrn->pScreen = NULL;
+        scr_index = AddGPUScreen(pScrn->ScreenInit, argc, argv);
+        xf86VGAarbiterUnlock(pScrn);
+        if (scr_index == i) {
+            dixSetPrivate(&screenInfo.gpuscreens[scr_index]->devPrivates,
+                          xf86ScreenKey, xf86GPUScreens[i]);
+            pScrn->pScreen = screenInfo.gpuscreens[scr_index];
+            /* The driver should set this, but make sure it is set anyway */
+            pScrn->vtSema = TRUE;
+        } else {
+            FatalError("AddScreen/ScreenInit failed for gpu driver %d %d\n", i, scr_index);
+        }
+    }
+
+    for (i = 0; i < xf86NumScreens; i++) {
+        xf86VGAarbiterLock(xf86Screens[i]);
+        /*
+         * Almost everything uses these defaults, and many of those that
+         * don't, will wrap them.
+         */
+        xf86Screens[i]->EnableDisableFBAccess = xf86EnableDisableFBAccess;
+#ifdef XFreeXDGA
+        xf86Screens[i]->SetDGAMode = xf86SetDGAMode;
+#endif
+        xf86Screens[i]->DPMSSet = NULL;
+        xf86Screens[i]->LoadPalette = NULL;
+        xf86Screens[i]->SetOverscan = NULL;
+        xf86Screens[i]->DriverFunc = NULL;
+        xf86Screens[i]->pScreen = NULL;
+        scr_index = AddScreen(xf86Screens[i]->ScreenInit, argc, argv);
+        xf86VGAarbiterUnlock(xf86Screens[i]);
+        if (scr_index == i) {
+            /*
+             * Hook in our ScrnInfoRec, and initialise some other pScreen
+             * fields.
+             */
+            dixSetPrivate(&screenInfo.screens[scr_index]->devPrivates,
+                          xf86ScreenKey, xf86Screens[i]);
+            xf86Screens[i]->pScreen = screenInfo.screens[scr_index];
+            /* The driver should set this, but make sure it is set anyway */
+            xf86Screens[i]->vtSema = TRUE;
+        }
+        else {
+            /* This shouldn't normally happen */
+            FatalError("AddScreen/ScreenInit failed for driver %d\n", i);
+        }
+
+        DebugF("InitOutput - xf86Screens[%d]->pScreen = %p\n",
+               i, xf86Screens[i]->pScreen);
+        DebugF("xf86Screens[%d]->pScreen->CreateWindow = %p\n",
+               i, xf86Screens[i]->pScreen->CreateWindow);
+
+        dixSetPrivate(&screenInfo.screens[scr_index]->devPrivates,
+                      xf86CreateRootWindowKey,
+                      xf86Screens[i]->pScreen->CreateWindow);
+        xf86Screens[i]->pScreen->CreateWindow = xf86CreateRootWindow;
+
+        if (PictureGetSubpixelOrder(xf86Screens[i]->pScreen) == SubPixelUnknown) {
+            xf86MonPtr DDC = (xf86MonPtr) (xf86Screens[i]->monitor->DDC);
+
+            PictureSetSubpixelOrder(xf86Screens[i]->pScreen,
+                                    DDC ?
+                                    (DDC->features.input_type ?
+                                     SubPixelHorizontalRGB : SubPixelNone) :
+                                    SubPixelUnknown);
+        }
+#ifdef RANDR
+        if (!xf86Info.disableRandR)
+            xf86RandRInit(screenInfo.screens[scr_index]);
+        xf86Msg(xf86Info.randRFrom, "RandR %s\n",
+                xf86Info.disableRandR ? "disabled" : "enabled");
+#endif
+    }
+
+    for (i = 0; i < xf86NumGPUScreens; i++)
+        AttachUnboundGPU(xf86Screens[0]->pScreen, xf86GPUScreens[i]->pScreen);
+
+    xf86AutoConfigOutputDevices();
+
+    xf86VGAarbiterWrapFunctions();
+    if (sigio_blocked)
+        OsReleaseSIGIO();
+
+    xf86InitOrigins();
+
+    xf86Resetting = FALSE;
+    xf86Initialising = FALSE;
+
+    RegisterBlockAndWakeupHandlers((BlockHandlerProcPtr) NoopDDA, xf86Wakeup,
+                                   NULL);
+}
+
+/**
+ * Initialize all supported input devices present and referenced in the
+ * xorg.conf.
+ */
+void
+InitInput(int argc, char **argv)
+{
+    InputInfoPtr *pInfo;
+    DeviceIntPtr dev;
+
+    xf86Info.vtRequestsPending = FALSE;
+
+    mieqInit();
+
+    /* Initialize all configured input devices */
+    for (pInfo = xf86ConfigLayout.inputs; pInfo && *pInfo; pInfo++) {
+        (*pInfo)->options =
+            xf86AddNewOption((*pInfo)->options, "driver", (*pInfo)->driver);
+        (*pInfo)->options =
+            xf86AddNewOption((*pInfo)->options, "identifier", (*pInfo)->name);
+        /* If one fails, the others will too */
+        if (NewInputDeviceRequest((*pInfo)->options, NULL, &dev) == BadAlloc)
+            break;
+    }
+
+    config_init();
+}
+
+void
+CloseInput(void)
+{
+    config_fini();
+    mieqFini();
+}
+
+/*
+ * OsVendorInit --
+ *      OS/Vendor-specific initialisations.  Called from OsInit(), which
+ *      is called by dix before establishing the well known sockets.
+ */
+
+void
+OsVendorInit(void)
+{
+    static Bool beenHere = FALSE;
+
+    signal(SIGCHLD, SIG_DFL);   /* Need to wait for child processes */
+
+    if (!beenHere) {
+        umask(022);
+        xf86LogInit();
+    }
+
+    /* Set stderr to non-blocking. */
+#ifndef O_NONBLOCK
+#if defined(FNDELAY)
+#define O_NONBLOCK FNDELAY
+#elif defined(O_NDELAY)
+#define O_NONBLOCK O_NDELAY
+#endif
+
+#ifdef O_NONBLOCK
+    if (!beenHere) {
+        if (xf86PrivsElevated()) {
+            int status;
+
+            status = fcntl(fileno(stderr), F_GETFL, 0);
+            if (status != -1) {
+                fcntl(fileno(stderr), F_SETFL, status | O_NONBLOCK);
+            }
+        }
+    }
+#endif
+#endif
+
+    beenHere = TRUE;
+}
+
+/*
+ * ddxGiveUp --
+ *      Device dependent cleanup. Called by by dix before normal server death.
+ *      For SYSV386 we must switch the terminal back to normal mode. No error-
+ *      checking here, since there should be restored as much as possible.
+ */
+
+void
+ddxGiveUp(enum ExitCode error)
+{
+    int i;
+
+    xf86VGAarbiterFini();
+
+#ifdef XF86PM
+    if (xf86OSPMClose)
+        xf86OSPMClose();
+    xf86OSPMClose = NULL;
+#endif
+
+    for (i = 0; i < xf86NumScreens; i++) {
+        /*
+         * zero all access functions to
+         * trap calls when switched away.
+         */
+        xf86Screens[i]->vtSema = FALSE;
+    }
+
+#ifdef XFreeXDGA
+    DGAShutdown();
+#endif
+
+    if (xorgHWOpenConsole)
+        xf86CloseConsole();
+
+    xf86CloseLog(error);
+
+    /* If an unexpected signal was caught, dump a core for debugging */
+    if (xf86Info.caughtSignal)
+        OsAbort();
+}
+
+/*
+ * AbortDDX --
+ *      DDX - specific abort routine.  Called by AbortServer(). The attempt is
+ *      made to restore all original setting of the displays. Also all devices
+ *      are closed.
+ */
+
+void
+AbortDDX(enum ExitCode error)
+{
+    int i;
+
+    OsBlockSIGIO();
+
+    /*
+     * try to restore the original video state
+     */
+#ifdef DPMSExtension            /* Turn screens back on */
+    if (DPMSPowerLevel != DPMSModeOn)
+        DPMSSet(serverClient, DPMSModeOn);
+#endif
+    if (xf86Screens) {
+        for (i = 0; i < xf86NumScreens; i++)
+            if (xf86Screens[i]->vtSema) {
+                /*
+                 * if we are aborting before ScreenInit() has finished
+                 * we might not have been wrapped yet. Therefore enable
+                 * screen explicitely.
+                 */
+                xf86VGAarbiterLock(xf86Screens[i]);
+                (xf86Screens[i]->LeaveVT) (xf86Screens[i]);
+                xf86VGAarbiterUnlock(xf86Screens[i]);
+            }
+    }
+
+    xf86AccessLeave();
+
+    /*
+     * This is needed for an abnormal server exit, since the normal exit stuff
+     * MUST also be performed (i.e. the vt must be left in a defined state)
+     */
+    ddxGiveUp(error);
+}
+
+void
+OsVendorFatalError(const char *f, va_list args)
+{
+#ifdef VENDORSUPPORT
+    ErrorFSigSafe("\nPlease refer to your Operating System Vendor support "
+                 "pages\nat %s for support on this crash.\n", VENDORSUPPORT);
+#else
+    ErrorFSigSafe("\nPlease consult the " XVENDORNAME " support \n\t at "
+                 __VENDORDWEBSUPPORT__ "\n for help. \n");
+#endif
+    if (xf86LogFile && xf86LogFileWasOpened)
+        ErrorFSigSafe("Please also check the log file at \"%s\" for additional "
+                     "information.\n", xf86LogFile);
+    ErrorFSigSafe("\n");
+}
+
+int
+xf86SetVerbosity(int verb)
+{
+    int save = xf86Verbose;
+
+    xf86Verbose = verb;
+    LogSetParameter(XLOG_VERBOSITY, verb);
+    return save;
+}
+
+int
+xf86SetLogVerbosity(int verb)
+{
+    int save = xf86LogVerbose;
+
+    xf86LogVerbose = verb;
+    LogSetParameter(XLOG_FILE_VERBOSITY, verb);
+    return save;
+}
+
+static void
+xf86PrintDefaultModulePath(void)
+{
+    ErrorF("%s\n", DEFAULT_MODULE_PATH);
+}
+
+static void
+xf86PrintDefaultLibraryPath(void)
+{
+    ErrorF("%s\n", DEFAULT_LIBRARY_PATH);
+}
+
+/*
+ * ddxProcessArgument --
+ *	Process device-dependent command line args. Returns 0 if argument is
+ *      not device dependent, otherwise Count of number of elements of argv
+ *      that are part of a device dependent commandline option.
+ *
+ */
+
+/* ARGSUSED */
+int
+ddxProcessArgument(int argc, char **argv, int i)
+{
+#define CHECK_FOR_REQUIRED_ARGUMENT() \
+    if (((i + 1) >= argc) || (!argv[i + 1])) { 				\
+      ErrorF("Required argument to %s not specified\n", argv[i]); 	\
+      UseMsg(); 							\
+      FatalError("Required argument to %s not specified\n", argv[i]);	\
+    }
+
+    /* First the options that are not allowed with elevated privileges */
+    if (!strcmp(argv[i], "-modulepath") || !strcmp(argv[i], "-logfile")) {
+        if (xf86PrivsElevated()) {
+            FatalError("The '%s' option cannot be used with "
+                       "elevated privileges.\n", argv[i]);
+        }
+        else if (!strcmp(argv[i], "-modulepath")) {
+            char *mp;
+
+            CHECK_FOR_REQUIRED_ARGUMENT();
+            mp = strdup(argv[i + 1]);
+            if (!mp)
+                FatalError("Can't allocate memory for ModulePath\n");
+            xf86ModulePath = mp;
+            xf86ModPathFrom = X_CMDLINE;
+            return 2;
+        }
+        else if (!strcmp(argv[i], "-logfile")) {
+            char *lf;
+
+            CHECK_FOR_REQUIRED_ARGUMENT();
+            lf = strdup(argv[i + 1]);
+            if (!lf)
+                FatalError("Can't allocate memory for LogFile\n");
+            xf86LogFile = lf;
+            xf86LogFileFrom = X_CMDLINE;
+            return 2;
+        }
+    }
+    if (!strcmp(argv[i], "-config") || !strcmp(argv[i], "-xf86config")) {
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        if (xf86PrivsElevated() && !xf86PathIsSafe(argv[i + 1])) {
+            FatalError("\nInvalid argument for %s\n"
+                       "\tWith elevated privileges, the file specified with %s must be\n"
+                       "\ta relative path and must not contain any \"..\" elements.\n"
+                       "\tUsing default " __XCONFIGFILE__ " search path.\n\n",
+                       argv[i], argv[i]);
+        }
+        xf86ConfigFile = argv[i + 1];
+        return 2;
+    }
+    if (!strcmp(argv[i], "-configdir")) {
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        if (xf86PrivsElevated() && !xf86PathIsSafe(argv[i + 1])) {
+            FatalError("\nInvalid argument for %s\n"
+                       "\tWith elevated privileges, the file specified with %s must be\n"
+                       "\ta relative path and must not contain any \"..\" elements.\n"
+                       "\tUsing default " __XCONFIGDIR__ " search path.\n\n",
+                       argv[i], argv[i]);
+        }
+        xf86ConfigDir = argv[i + 1];
+        return 2;
+    }
+    if (!strcmp(argv[i], "-flipPixels")) {
+        xf86FlipPixels = TRUE;
+        return 1;
+    }
+#ifdef XF86VIDMODE
+    if (!strcmp(argv[i], "-disableVidMode")) {
+        xf86VidModeDisabled = TRUE;
+        return 1;
+    }
+    if (!strcmp(argv[i], "-allowNonLocalXvidtune")) {
+        xf86VidModeAllowNonLocal = TRUE;
+        return 1;
+    }
+#endif
+    if (!strcmp(argv[i], "-allowMouseOpenFail")) {
+        xf86AllowMouseOpenFail = TRUE;
+        return 1;
+    }
+    if (!strcmp(argv[i], "-ignoreABI")) {
+        LoaderSetOptions(LDR_OPT_ABI_MISMATCH_NONFATAL);
+        return 1;
+    }
+    if (!strcmp(argv[i], "-verbose")) {
+        if (++i < argc && argv[i]) {
+            char *end;
+            long val;
+
+            val = strtol(argv[i], &end, 0);
+            if (*end == '\0') {
+                xf86SetVerbosity(val);
+                return 2;
+            }
+        }
+        xf86SetVerbosity(++xf86Verbose);
+        return 1;
+    }
+    if (!strcmp(argv[i], "-logverbose")) {
+        if (++i < argc && argv[i]) {
+            char *end;
+            long val;
+
+            val = strtol(argv[i], &end, 0);
+            if (*end == '\0') {
+                xf86SetLogVerbosity(val);
+                return 2;
+            }
+        }
+        xf86SetLogVerbosity(++xf86LogVerbose);
+        return 1;
+    }
+    if (!strcmp(argv[i], "-quiet")) {
+        xf86SetVerbosity(-1);
+        return 1;
+    }
+    if (!strcmp(argv[i], "-showconfig") || !strcmp(argv[i], "-version")) {
+        xf86PrintBanner();
+        exit(0);
+    }
+    if (!strcmp(argv[i], "-showDefaultModulePath")) {
+        xf86PrintDefaultModulePath();
+        exit(0);
+    }
+    if (!strcmp(argv[i], "-showDefaultLibPath")) {
+        xf86PrintDefaultLibraryPath();
+        exit(0);
+    }
+    /* Notice the -fp flag, but allow it to pass to the dix layer */
+    if (!strcmp(argv[i], "-fp")) {
+        xf86fpFlag = TRUE;
+        return 0;
+    }
+    /* Notice the -bs flag, but allow it to pass to the dix layer */
+    if (!strcmp(argv[i], "-bs")) {
+        xf86bsDisableFlag = TRUE;
+        return 0;
+    }
+    /* Notice the +bs flag, but allow it to pass to the dix layer */
+    if (!strcmp(argv[i], "+bs")) {
+        xf86bsEnableFlag = TRUE;
+        return 0;
+    }
+    /* Notice the -s flag, but allow it to pass to the dix layer */
+    if (!strcmp(argv[i], "-s")) {
+        xf86sFlag = TRUE;
+        return 0;
+    }
+    if (!strcmp(argv[i], "-pixmap24")) {
+        xf86Pix24 = Pix24Use24;
+        return 1;
+    }
+    if (!strcmp(argv[i], "-pixmap32")) {
+        xf86Pix24 = Pix24Use32;
+        return 1;
+    }
+    if (!strcmp(argv[i], "-fbbpp")) {
+        int bpp;
+
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        if (sscanf(argv[++i], "%d", &bpp) == 1) {
+            xf86FbBpp = bpp;
+            return 2;
+        }
+        else {
+            ErrorF("Invalid fbbpp\n");
+            return 0;
+        }
+    }
+    if (!strcmp(argv[i], "-depth")) {
+        int depth;
+
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        if (sscanf(argv[++i], "%d", &depth) == 1) {
+            xf86Depth = depth;
+            return 2;
+        }
+        else {
+            ErrorF("Invalid depth\n");
+            return 0;
+        }
+    }
+    if (!strcmp(argv[i], "-weight")) {
+        int red, green, blue;
+
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        if (sscanf(argv[++i], "%1d%1d%1d", &red, &green, &blue) == 3) {
+            xf86Weight.red = red;
+            xf86Weight.green = green;
+            xf86Weight.blue = blue;
+            return 2;
+        }
+        else {
+            ErrorF("Invalid weighting\n");
+            return 0;
+        }
+    }
+    if (!strcmp(argv[i], "-gamma") || !strcmp(argv[i], "-rgamma") ||
+        !strcmp(argv[i], "-ggamma") || !strcmp(argv[i], "-bgamma")) {
+        double gamma;
+
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        if (sscanf(argv[++i], "%lf", &gamma) == 1) {
+            if (gamma < GAMMA_MIN || gamma > GAMMA_MAX) {
+                ErrorF("gamma out of range, only  %.2f <= gamma_value <= %.1f"
+                       " is valid\n", GAMMA_MIN, GAMMA_MAX);
+                return 0;
+            }
+            if (!strcmp(argv[i - 1], "-gamma"))
+                xf86Gamma.red = xf86Gamma.green = xf86Gamma.blue = gamma;
+            else if (!strcmp(argv[i - 1], "-rgamma"))
+                xf86Gamma.red = gamma;
+            else if (!strcmp(argv[i - 1], "-ggamma"))
+                xf86Gamma.green = gamma;
+            else if (!strcmp(argv[i - 1], "-bgamma"))
+                xf86Gamma.blue = gamma;
+            return 2;
+        }
+    }
+    if (!strcmp(argv[i], "-layout")) {
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        xf86LayoutName = argv[++i];
+        return 2;
+    }
+    if (!strcmp(argv[i], "-screen")) {
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        xf86ScreenName = argv[++i];
+        return 2;
+    }
+    if (!strcmp(argv[i], "-pointer")) {
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        xf86PointerName = argv[++i];
+        return 2;
+    }
+    if (!strcmp(argv[i], "-keyboard")) {
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        xf86KeyboardName = argv[++i];
+        return 2;
+    }
+    if (!strcmp(argv[i], "-nosilk")) {
+        xf86silkenMouseDisableFlag = TRUE;
+        return 1;
+    }
+#ifdef HAVE_ACPI
+    if (!strcmp(argv[i], "-noacpi")) {
+        xf86acpiDisableFlag = TRUE;
+        return 1;
+    }
+#endif
+    if (!strcmp(argv[i], "-configure")) {
+        if (getuid() != 0 && geteuid() == 0) {
+            ErrorF("The '-configure' option can only be used by root.\n");
+            exit(1);
+        }
+        xf86DoConfigure = TRUE;
+        xf86AllowMouseOpenFail = TRUE;
+        return 1;
+    }
+    if (!strcmp(argv[i], "-showopts")) {
+        if (getuid() != 0 && geteuid() == 0) {
+            ErrorF("The '-showopts' option can only be used by root.\n");
+            exit(1);
+        }
+        xf86DoShowOptions = TRUE;
+        return 1;
+    }
+#ifdef XSERVER_LIBPCIACCESS
+    if (!strcmp(argv[i], "-isolateDevice")) {
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        if (strncmp(argv[++i], "PCI:", 4)) {
+            FatalError("Bus types other than PCI not yet isolable\n");
+        }
+        xf86PciIsolateDevice(argv[i]);
+        return 2;
+    }
+#endif
+    /* Notice cmdline xkbdir, but pass to dix as well */
+    if (!strcmp(argv[i], "-xkbdir")) {
+        xf86xkbdirFlag = TRUE;
+        return 0;
+    }
+    if (!strcmp(argv[i], "-novtswitch")) {
+        xf86Info.autoVTSwitch = FALSE;
+        return 1;
+    }
+    if (!strcmp(argv[i], "-sharevts")) {
+        xf86Info.ShareVTs = TRUE;
+        return 1;
+    }
+
+    /* OS-specific processing */
+    return xf86ProcessArgument(argc, argv, i);
+}
+
+/*
+ * ddxUseMsg --
+ *	Print out correct use of device dependent commandline options.
+ *      Maybe the user now knows what really to do ...
+ */
+
+void
+ddxUseMsg(void)
+{
+    ErrorF("\n");
+    ErrorF("\n");
+    ErrorF("Device Dependent Usage\n");
+    if (!xf86PrivsElevated()) {
+        ErrorF("-modulepath paths      specify the module search path\n");
+        ErrorF("-logfile file          specify a log file name\n");
+        ErrorF("-configure             probe for devices and write an "
+               __XCONFIGFILE__ "\n");
+        ErrorF
+            ("-showopts              print available options for all installed drivers\n");
+    }
+    ErrorF
+        ("-config file           specify a configuration file, relative to the\n");
+    ErrorF("                       " __XCONFIGFILE__
+           " search path, only root can use absolute\n");
+    ErrorF
+        ("-configdir dir         specify a configuration directory, relative to the\n");
+    ErrorF("                       " __XCONFIGDIR__
+           " search path, only root can use absolute\n");
+    ErrorF("-verbose [n]           verbose startup messages\n");
+    ErrorF("-logverbose [n]        verbose log messages\n");
+    ErrorF("-quiet                 minimal startup messages\n");
+    ErrorF("-pixmap24              use 24bpp pixmaps for depth 24\n");
+    ErrorF("-pixmap32              use 32bpp pixmaps for depth 24\n");
+    ErrorF("-fbbpp n               set bpp for the framebuffer. Default: 8\n");
+    ErrorF("-depth n               set colour depth. Default: 8\n");
+    ErrorF
+        ("-gamma f               set gamma value (0.1 < f < 10.0) Default: 1.0\n");
+    ErrorF("-rgamma f              set gamma value for red phase\n");
+    ErrorF("-ggamma f              set gamma value for green phase\n");
+    ErrorF("-bgamma f              set gamma value for blue phase\n");
+    ErrorF
+        ("-weight nnn            set RGB weighting at 16 bpp.  Default: 565\n");
+    ErrorF("-layout name           specify the ServerLayout section name\n");
+    ErrorF("-screen name           specify the Screen section name\n");
+    ErrorF
+        ("-keyboard name         specify the core keyboard InputDevice name\n");
+    ErrorF
+        ("-pointer name          specify the core pointer InputDevice name\n");
+    ErrorF("-nosilk                disable Silken Mouse\n");
+    ErrorF("-flipPixels            swap default black/white Pixel values\n");
+#ifdef XF86VIDMODE
+    ErrorF("-disableVidMode        disable mode adjustments with xvidtune\n");
+    ErrorF
+        ("-allowNonLocalXvidtune allow xvidtune to be run as a non-local client\n");
+#endif
+    ErrorF
+        ("-allowMouseOpenFail    start server even if the mouse can't be initialized\n");
+    ErrorF("-ignoreABI             make module ABI mismatches non-fatal\n");
+#ifdef XSERVER_LIBPCIACCESS
+    ErrorF
+        ("-isolateDevice bus_id  restrict device resets to bus_id (PCI only)\n");
+#endif
+    ErrorF("-version               show the server version\n");
+    ErrorF("-showDefaultModulePath show the server default module path\n");
+    ErrorF("-showDefaultLibPath    show the server default library path\n");
+    ErrorF
+        ("-novtswitch            don't automatically switch VT at reset & exit\n");
+    ErrorF("-sharevts              share VTs with another X server\n");
+    /* OS-specific usage */
+    xf86UseMsg();
+    ErrorF("\n");
+}
+
+/*
+ * xf86LoadModules iterates over a list that is being passed in.
+ */
+Bool
+xf86LoadModules(char **list, pointer *optlist)
+{
+    int errmaj, errmin;
+    pointer opt;
+    int i;
+    char *name;
+    Bool failed = FALSE;
+
+    if (!list)
+        return TRUE;
+
+    for (i = 0; list[i] != NULL; i++) {
+
+        /* Normalise the module name */
+        name = xf86NormalizeName(list[i]);
+
+        /* Skip empty names */
+        if (name == NULL || *name == '\0') {
+            free(name);
+            continue;
+        }
+
+        /* Replace obsolete keyboard driver with kbd */
+        if (!xf86NameCmp(name, "keyboard")) {
+            strcpy(name, "kbd");
+        }
+
+        if (optlist)
+            opt = optlist[i];
+        else
+            opt = NULL;
+
+        if (!LoadModule(name, NULL, NULL, NULL, opt, NULL, &errmaj, &errmin)) {
+            LoaderErrorMsg(NULL, name, errmaj, errmin);
+            failed = TRUE;
+        }
+        free(name);
+    }
+    return !failed;
+}
+
+/* Pixmap format stuff */
+
+PixmapFormatPtr
+xf86GetPixFormat(ScrnInfoPtr pScrn, int depth)
+{
+    int i;
+    static PixmapFormatRec format;      /* XXX not reentrant */
+
+    /*
+     * When the formats[] list initialisation isn't complete, check the
+     * depth 24 pixmap config/cmdline options and screen-specified formats.
+     */
+
+    if (!formatsDone) {
+        if (depth == 24) {
+            Pix24Flags pix24 = Pix24DontCare;
+
+            format.depth = 24;
+            format.scanlinePad = BITMAP_SCANLINE_PAD;
+            if (xf86Info.pixmap24 != Pix24DontCare)
+                pix24 = xf86Info.pixmap24;
+            else if (pScrn->pixmap24 != Pix24DontCare)
+                pix24 = pScrn->pixmap24;
+            if (pix24 == Pix24Use24)
+                format.bitsPerPixel = 24;
+            else
+                format.bitsPerPixel = 32;
+            return &format;
+        }
+    }
+
+    for (i = 0; i < numFormats; i++)
+        if (formats[i].depth == depth)
+            break;
+    if (i != numFormats)
+        return &formats[i];
+    else if (!formatsDone) {
+        /* Check for screen-specified formats */
+        for (i = 0; i < pScrn->numFormats; i++)
+            if (pScrn->formats[i].depth == depth)
+                break;
+        if (i != pScrn->numFormats)
+            return &pScrn->formats[i];
+    }
+    return NULL;
+}
+
+int
+xf86GetBppFromDepth(ScrnInfoPtr pScrn, int depth)
+{
+    PixmapFormatPtr format;
+
+    format = xf86GetPixFormat(pScrn, depth);
+    if (format)
+        return format->bitsPerPixel;
+    else
+        return 0;
+}
+
+#ifdef DDXBEFORERESET
+void
+ddxBeforeReset(void)
+{
+}
+#endif
diff --git a/hw/xfree86/common/xf86Priv.h b/hw/xfree86/common/xf86Priv.h
index 58cfe0a..3dd2697 100644
--- a/hw/xfree86/common/xf86Priv.h
+++ b/hw/xfree86/common/xf86Priv.h
@@ -91,6 +91,8 @@ extern _X_EXPORT int xf86NumScreens;
 extern _X_EXPORT const char *xf86VisualNames[];
 extern _X_EXPORT int xf86Verbose;       /* verbosity level */
 extern _X_EXPORT int xf86LogVerbose;    /* log file verbosity level */
+extern _X_EXPORT Bool xorgWayland;
+extern _X_EXPORT Bool xorgRootless;
 
 extern _X_EXPORT RootWinPropPtr *xf86RegisteredPropertiesTable;
 
diff --git a/hw/xfree86/dri2/dri2.c b/hw/xfree86/dri2/dri2.c
index 8bf0392..b203d06 100644
--- a/hw/xfree86/dri2/dri2.c
+++ b/hw/xfree86/dri2/dri2.c
@@ -1349,13 +1349,16 @@ DRI2Connect(ClientPtr client, ScreenPtr pScreen,
 }
 
 static int
-DRI2AuthMagic (ScreenPtr pScreen, uint32_t magic)
+DRI2AuthMagic (ClientPtr client, ScreenPtr pScreen, uint32_t magic)
 {
     DRI2ScreenPtr ds = DRI2GetScreen(pScreen);
     if (ds == NULL)
         return -EINVAL;
 
-    return (*ds->LegacyAuthMagic) (ds->fd, magic);
+    if (ds->LegacyAuthMagic2)
+        return (*ds->LegacyAuthMagic2) (pScreen, magic);
+    else
+        return (*ds->LegacyAuthMagic) (ds->fd, magic);
 }
 
 Bool
diff --git a/hw/xfree86/dri2/dri2.h b/hw/xfree86/dri2/dri2.h
index 38b4f58..ed67d01 100644
--- a/hw/xfree86/dri2/dri2.h
+++ b/hw/xfree86/dri2/dri2.h
@@ -207,7 +207,7 @@ typedef int (*DRI2GetParamProcPtr) (ClientPtr client,
 /**
  * Version of the DRI2InfoRec structure defined in this header
  */
-#define DRI2INFOREC_VERSION 9
+#define DRI2INFOREC_VERSION 10
 
 typedef struct {
     unsigned int version;       /**< Version of this struct */
diff --git a/hw/xfree86/xwayland/Makefile.am b/hw/xfree86/xwayland/Makefile.am
new file mode 100644
index 0000000..b739145
--- /dev/null
+++ b/hw/xfree86/xwayland/Makefile.am
@@ -0,0 +1,44 @@
+AM_CPPFLAGS =					\
+	$(XORG_INCS)				\
+	-I$(srcdir)/../ddc			\
+	-I$(srcdir)/../ramdac			\
+	-I$(srcdir)/../i2c			\
+	-I$(srcdir)/../parser			\
+	-I$(srcdir)/../modes
+
+libxwayland_la_LTLIBRARIES = libxwayland.la
+libxwayland_la_CFLAGS = \
+	-DHAVE_XORG_CONFIG_H \
+	@DIX_CFLAGS@ @XORG_CFLAGS@ @LIBDRM_CFLAGS@ \
+	-I$(top_srcdir)/hw/xfree86/common \
+	-I$(top_srcdir)/hw/xfree86/os-support/bus
+
+libxwayland_la_LDFLAGS = -module -avoid-version @LIBDRM_LIBS@ -lwayland-client
+libxwayland_ladir = $(moduledir)/extensions
+libxwayland_la_SOURCES =			\
+	xwayland.c				\
+	xwayland-input.c			\
+	xwayland-output.c			\
+	xwayland-cursor.c			\
+	xwayland-window.c			\
+	xwayland-private.h			\
+	drm-client-protocol.h			\
+	drm-protocol.c				\
+	xserver-client-protocol.h		\
+	xserver-protocol.c
+
+if DRM
+libxwayland_la_SOURCES += xwayland-drm.c
+endif
+
+sdk_HEADERS = xwayland.h
+
+BUILT_SOURCES =					\
+	drm-client-protocol.h			\
+	drm-protocol.c				\
+	xserver-client-protocol.h		\
+	xserver-protocol.c
+
+CLEANFILES = $(BUILT_SOURCES)
+
+@wayland_scanner_rules@
diff --git a/hw/xfree86/xwayland/drm.xml b/hw/xfree86/xwayland/drm.xml
new file mode 100644
index 0000000..89fd8f0
--- /dev/null
+++ b/hw/xfree86/xwayland/drm.xml
@@ -0,0 +1,139 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<protocol name="drm">
+
+  <copyright>
+    Copyright © 2008-2011 Kristian Høgsberg
+    Copyright © 2010-2011 Intel Corporation
+
+    Permission to use, copy, modify, distribute, and sell this
+    software and its documentation for any purpose is hereby granted
+    without fee, provided that\n the above copyright notice appear in
+    all copies and that both that copyright notice and this permission
+    notice appear in supporting documentation, and that the name of
+    the copyright holders not be used in advertising or publicity
+    pertaining to distribution of the software without specific,
+    written prior permission.  The copyright holders make no
+    representations about the suitability of this software for any
+    purpose.  It is provided "as is" without express or implied
+    warranty.
+
+    THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+    SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+    FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+    SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+    AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
+    ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF
+    THIS SOFTWARE.
+  </copyright>
+
+  <!-- drm support. This object is created by the server and published
+       using the display's global event. -->
+  <interface name="wl_drm" version="1">
+    <enum name="error">
+      <entry name="authenticate_fail" value="0"/>
+      <entry name="invalid_format" value="1"/>
+      <entry name="invalid_name" value="2"/>
+    </enum>
+
+    <enum name="format">
+      <!-- The drm format codes match the #defines in drm_fourcc.h.
+           The formats actually supported by the compositor will be
+           reported by the format event. -->
+      <entry name="c8" value="0x20203843"/>
+      <entry name="rgb332" value="0x38424752"/>
+      <entry name="bgr233" value="0x38524742"/>
+      <entry name="xrgb4444" value="0x32315258"/>
+      <entry name="xbgr4444" value="0x32314258"/>
+      <entry name="rgbx4444" value="0x32315852"/>
+      <entry name="bgrx4444" value="0x32315842"/>
+      <entry name="argb4444" value="0x32315241"/>
+      <entry name="abgr4444" value="0x32314241"/>
+      <entry name="rgba4444" value="0x32314152"/>
+      <entry name="bgra4444" value="0x32314142"/>
+      <entry name="xrgb1555" value="0x35315258"/>
+      <entry name="xbgr1555" value="0x35314258"/>
+      <entry name="rgbx5551" value="0x35315852"/>
+      <entry name="bgrx5551" value="0x35315842"/>
+      <entry name="argb1555" value="0x35315241"/>
+      <entry name="abgr1555" value="0x35314241"/>
+      <entry name="rgba5551" value="0x35314152"/>
+      <entry name="bgra5551" value="0x35314142"/>
+      <entry name="rgb565" value="0x36314752"/>
+      <entry name="bgr565" value="0x36314742"/>
+      <entry name="rgb888" value="0x34324752"/>
+      <entry name="bgr888" value="0x34324742"/>
+      <entry name="xrgb8888" value="0x34325258"/>
+      <entry name="xbgr8888" value="0x34324258"/>
+      <entry name="rgbx8888" value="0x34325852"/>
+      <entry name="bgrx8888" value="0x34325842"/>
+      <entry name="argb8888" value="0x34325241"/>
+      <entry name="abgr8888" value="0x34324241"/>
+      <entry name="rgba8888" value="0x34324152"/>
+      <entry name="bgra8888" value="0x34324142"/>
+      <entry name="xrgb2101010" value="0x30335258"/>
+      <entry name="xbgr2101010" value="0x30334258"/>
+      <entry name="rgbx1010102" value="0x30335852"/>
+      <entry name="bgrx1010102" value="0x30335842"/>
+      <entry name="argb2101010" value="0x30335241"/>
+      <entry name="abgr2101010" value="0x30334241"/>
+      <entry name="rgba1010102" value="0x30334152"/>
+      <entry name="bgra1010102" value="0x30334142"/>
+      <entry name="yuyv" value="0x56595559"/>
+      <entry name="yvyu" value="0x55595659"/>
+      <entry name="uyvy" value="0x59565955"/>
+      <entry name="vyuy" value="0x59555956"/>
+      <entry name="ayuv" value="0x56555941"/>
+      <entry name="nv12" value="0x3231564e"/>
+      <entry name="nv21" value="0x3132564e"/>
+      <entry name="nv16" value="0x3631564e"/>
+      <entry name="nv61" value="0x3136564e"/>
+      <entry name="yuv410" value="0x39565559"/>
+      <entry name="yvu410" value="0x39555659"/>
+      <entry name="yuv411" value="0x31315559"/>
+      <entry name="yvu411" value="0x31315659"/>
+      <entry name="yuv420" value="0x32315559"/>
+      <entry name="yvu420" value="0x32315659"/>
+      <entry name="yuv422" value="0x36315559"/>
+      <entry name="yvu422" value="0x36315659"/>
+      <entry name="yuv444" value="0x34325559"/>
+      <entry name="yvu444" value="0x34325659"/>
+    </enum>
+
+    <!-- Call this request with the magic received from drmGetMagic().
+         It will be passed on to the drmAuthMagic() or
+         DRIAuthConnection() call.  This authentication must be
+         completed before create_buffer could be used. -->
+    <request name="authenticate">
+      <arg name="id" type="uint"/>
+    </request>
+
+    <!-- Create a wayland buffer for the named DRM buffer.  The DRM
+         surface must have a name using the flink ioctl -->
+    <request name="create_buffer">
+      <arg name="id" type="new_id" interface="wl_buffer"/>
+      <arg name="name" type="uint"/>
+      <arg name="width" type="int"/>
+      <arg name="height" type="int"/>
+      <arg name="stride" type="uint"/>
+      <arg name="format" type="uint"/>
+    </request>
+
+    <!-- Notification of the path of the drm device which is used by
+         the server.  The client should use this device for creating
+         local buffers.  Only buffers created from this device should
+         be be passed to the server using this drm object's
+         create_buffer request. -->
+    <event name="device">
+      <arg name="name" type="string"/>
+    </event>
+
+    <event name="format">
+      <arg name="format" type="uint"/>
+    </event>
+
+    <!-- Raised if the authenticate request succeeded -->
+    <event name="authenticated"/>
+  </interface>
+
+</protocol>
diff --git a/hw/xfree86/xwayland/xserver.xml b/hw/xfree86/xwayland/xserver.xml
new file mode 100644
index 0000000..9e25f5c
--- /dev/null
+++ b/hw/xfree86/xwayland/xserver.xml
@@ -0,0 +1,18 @@
+<protocol name="xserver">
+
+  <interface name="xserver" version="1">
+    <request name="set_window_id">
+      <arg name="surface" type="object" interface="wl_surface"/>
+      <arg name="id" type="uint"/>
+    </request>
+
+    <event name="client">
+      <arg name="fd" type="fd"/>
+    </event>
+
+    <event name="listen_socket">
+      <arg name="fd" type="fd"/>
+    </event>
+  </interface>
+
+</protocol>
diff --git a/hw/xfree86/xwayland/xwayland-cursor.c b/hw/xfree86/xwayland/xwayland-cursor.c
new file mode 100644
index 0000000..f8860bd
--- /dev/null
+++ b/hw/xfree86/xwayland/xwayland-cursor.c
@@ -0,0 +1,241 @@
+/*
+ * Copyright © 2011 Kristian Høgsberg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include "xorg-config.h"
+#endif
+
+#include <unistd.h>
+#include <errno.h>
+#include <sys/mman.h>
+#include <wayland-client.h>
+
+#include <xorg-server.h>
+#include <cursorstr.h>
+#include <xf86Crtc.h>
+#include <mipointrst.h>
+
+#include "xwayland.h"
+#include "xwayland-private.h"
+#include "xserver-client-protocol.h"
+
+static DevPrivateKeyRec xwl_cursor_private_key;
+
+static void
+expand_source_and_mask(CursorPtr cursor, void *data)
+{
+    CARD32 *argb, *p, d, fg, bg;
+    CursorBitsPtr bits = cursor->bits;
+    int size;
+    int x, y, stride, i, bit;
+
+    size = bits->width * bits->height * 4;
+    argb = malloc(size);
+    if (argb == NULL)
+	return;
+
+    p = argb;
+    fg = ((cursor->foreRed & 0xff00) << 8) |
+	(cursor->foreGreen & 0xff00) | (cursor->foreGreen >> 8);
+    bg = ((cursor->backRed & 0xff00) << 8) |
+	(cursor->backGreen & 0xff00) | (cursor->backGreen >> 8);
+    stride = (bits->width / 8 + 3) & ~3;
+    for (y = 0; y < bits->height; y++)
+	for (x = 0; x < bits->width; x++) {
+	    i = y * stride + x / 8;
+	    bit = 1 << (x & 7);
+	    if (bits->source[i] & bit)
+		d = fg;
+	    else
+		d = bg;
+	    if (bits->mask[i] & bit)
+		d |= 0xff000000;
+	    else
+		d = 0x00000000;
+
+	    *p++ = d;
+	}
+
+    memcpy(data, argb, size);
+    free(argb);
+}
+
+static Bool
+xwl_realize_cursor(DeviceIntPtr device, ScreenPtr screen, CursorPtr cursor)
+{
+    struct xwl_screen *xwl_screen;
+    int size;
+    char filename[] = "/tmp/wayland-shm-XXXXXX";
+    int fd;
+    struct wl_shm_pool *pool;
+    struct wl_buffer *buffer;
+    void *data;
+
+    xwl_screen = xwl_screen_get(screen);
+    size = cursor->bits->width * cursor->bits->height * 4;
+
+    fd = mkstemp(filename);
+    if (fd < 0) {
+	ErrorF("open %s failed: %s", filename, strerror(errno));
+	return FALSE;
+    }
+    if (ftruncate(fd, size) < 0) {
+	ErrorF("ftruncate failed: %s", strerror(errno));
+	close(fd);
+	return FALSE;
+    }
+
+    data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
+    unlink(filename);
+
+    if (data == MAP_FAILED) {
+	ErrorF("mmap failed: %s", strerror(errno));
+	close(fd);
+	return FALSE;
+    }
+
+    if (cursor->bits->argb)
+	memcpy(data, cursor->bits->argb, size);
+    else
+	expand_source_and_mask(cursor, data);
+    munmap(data, size);
+
+    pool = wl_shm_create_pool(xwl_screen->shm, fd, size);
+    close(fd);
+    buffer = wl_shm_pool_create_buffer(pool, 0,
+				  cursor->bits->width, cursor->bits->height,
+				  cursor->bits->width * 4,
+				  WL_SHM_FORMAT_ARGB8888);
+    wl_shm_pool_destroy(pool);
+
+    dixSetPrivate(&cursor->devPrivates, &xwl_cursor_private_key, buffer);
+
+    return TRUE;
+}
+
+static Bool
+xwl_unrealize_cursor(DeviceIntPtr device,
+			ScreenPtr screen, CursorPtr cursor)
+{
+    struct wl_buffer *buffer;
+
+    buffer = dixGetPrivate(&cursor->devPrivates, &xwl_cursor_private_key);
+    wl_buffer_destroy(buffer);
+
+    return TRUE;
+}
+
+void
+xwl_seat_set_cursor(struct xwl_seat *xwl_seat)
+{
+    struct wl_buffer *buffer;
+
+    if (!xwl_seat->x_cursor || !xwl_seat->wl_pointer)
+        return;
+
+    buffer = dixGetPrivate(&xwl_seat->x_cursor->devPrivates,
+                           &xwl_cursor_private_key);
+
+    wl_pointer_set_cursor(xwl_seat->wl_pointer,
+			  xwl_seat->pointer_enter_serial,
+			  xwl_seat->cursor,
+			  xwl_seat->x_cursor->bits->xhot,
+			  xwl_seat->x_cursor->bits->yhot);
+    wl_surface_attach(xwl_seat->cursor, buffer, 0, 0);
+    wl_surface_damage(xwl_seat->cursor, 0, 0,
+		      xwl_seat->x_cursor->bits->width,
+		      xwl_seat->x_cursor->bits->height);
+    wl_surface_commit(xwl_seat->cursor);
+}
+
+static void
+xwl_set_cursor(DeviceIntPtr device,
+	       ScreenPtr screen, CursorPtr cursor, int x, int y)
+{
+    struct xwl_screen *xwl_screen;
+    struct xwl_seat *xwl_seat;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    if (!xwl_screen || xorg_list_is_empty(&xwl_screen->seat_list))
+	return;
+
+    xwl_seat = xorg_list_first_entry(&xwl_screen->seat_list,
+		                     struct xwl_seat, link);
+
+    xwl_seat->x_cursor = cursor;
+    xwl_seat_set_cursor(xwl_seat);
+}
+
+static void
+xwl_move_cursor(DeviceIntPtr device, ScreenPtr screen, int x, int y)
+{
+}
+
+static Bool
+xwl_device_cursor_initialize(DeviceIntPtr device, ScreenPtr screen)
+{
+    struct xwl_screen *xwl_screen;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    return xwl_screen->sprite_funcs->DeviceCursorInitialize(device,
+							       screen);
+}
+
+static void
+xwl_device_cursor_cleanup(DeviceIntPtr device, ScreenPtr screen)
+{
+    struct xwl_screen *xwl_screen;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    xwl_screen->sprite_funcs->DeviceCursorCleanup(device, screen);
+}
+
+static miPointerSpriteFuncRec xwl_pointer_sprite_funcs =
+{
+    xwl_realize_cursor,
+    xwl_unrealize_cursor,
+    xwl_set_cursor,
+    xwl_move_cursor,
+    xwl_device_cursor_initialize,
+    xwl_device_cursor_cleanup
+};
+
+int
+xwl_screen_init_cursor(struct xwl_screen *xwl_screen, ScreenPtr screen)
+{
+    miPointerScreenPtr pointer_priv;
+
+    if (!dixRegisterPrivateKey(&xwl_cursor_private_key, PRIVATE_CURSOR, 0))
+	return BadAlloc;
+
+    pointer_priv = dixLookupPrivate(&screen->devPrivates, miPointerScreenKey);
+    xwl_screen->sprite_funcs = pointer_priv->spriteFuncs;
+    pointer_priv->spriteFuncs = &xwl_pointer_sprite_funcs;
+
+    return Success;
+}
diff --git a/hw/xfree86/xwayland/xwayland-drm.c b/hw/xfree86/xwayland/xwayland-drm.c
new file mode 100644
index 0000000..ce56e4c
--- /dev/null
+++ b/hw/xfree86/xwayland/xwayland-drm.c
@@ -0,0 +1,235 @@
+/*
+ * Copyright © 2011 Kristian Høgsberg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include "xorg-config.h"
+#endif
+
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <xf86drm.h>
+#include <wayland-util.h>
+#include <wayland-client.h>
+#include <drm-client-protocol.h>
+
+#include <xf86Xinput.h>
+#include <xf86Crtc.h>
+#include <xf86str.h>
+#include <windowstr.h>
+#include <input.h>
+#include <inputstr.h>
+#include <exevents.h>
+
+#include "xwayland.h"
+#include "xwayland-private.h"
+#include "../dri2/dri2.h"
+
+struct xwl_auth_req {
+    struct xorg_list link;
+
+    ClientPtr client;
+    struct xwl_screen *xwl_screen;
+    uint32_t magic;
+};
+
+static void
+drm_handle_device (void *data, struct wl_drm *drm, const char *device)
+{
+    struct xwl_screen *xwl_screen = data;
+
+    xwl_screen->device_name = strdup (device);
+}
+
+static void
+drm_handle_format(void *data, struct wl_drm *wl_drm, uint32_t format)
+{
+}
+
+static void
+drm_handle_authenticated (void *data, struct wl_drm *drm)
+{
+    struct xwl_screen *xwl_screen = data;
+    struct xwl_auth_req *req;
+
+    xwl_screen->authenticated = 1;
+
+    /* it does one authentication transaction at a time, so if there's an
+     * element in the list, we call DRI2SendAuthReply for that client, remove
+     * the head and free the struct. If there are still elements in the list,
+     * it means that we have one or more clients waiting to be authenticated
+     * and we send out a wl_drm authenticate request for the first client in
+     * the list */
+    if (xorg_list_is_empty(&xwl_screen->authenticate_client_list))
+	return;
+
+    req = xorg_list_first_entry(&xwl_screen->authenticate_client_list,
+	                        struct xwl_auth_req, link);
+    DRI2SendAuthReply(req->client, TRUE);
+    AttendClient(req->client);
+    xorg_list_del(&req->link);
+    free(req);
+
+    xorg_list_for_each_entry(req, &xwl_screen->authenticate_client_list,
+	                     link) {
+	wl_drm_authenticate (xwl_screen->drm, req->magic);
+	return;
+    }
+}
+
+static const struct wl_drm_listener xwl_drm_listener =
+{
+    drm_handle_device,
+    drm_handle_format,
+    drm_handle_authenticated
+};
+
+static void
+drm_handler(void *data, struct wl_registry *registry, uint32_t id,
+	    const char *interface, uint32_t version)
+{
+    struct xwl_screen *xwl_screen = data;
+
+    if (strcmp (interface, "wl_drm") == 0) {
+	xwl_screen->drm = wl_registry_bind(xwl_screen->registry, id,
+                                           &wl_drm_interface, 1);
+	wl_drm_add_listener(xwl_screen->drm, &xwl_drm_listener, xwl_screen);
+    }
+}
+
+static const struct wl_registry_listener drm_listener = {
+    drm_handler,
+};
+
+int
+xwl_drm_pre_init(struct xwl_screen *xwl_screen)
+{
+    uint32_t magic;
+
+    xwl_screen->drm_registry = wl_display_get_registry(xwl_screen->display);
+    wl_registry_add_listener(xwl_screen->drm_registry, &drm_listener,
+                             xwl_screen);
+
+    /* Ensure drm_handler has seen all the interfaces */
+    wl_display_roundtrip(xwl_screen->display);
+    /* Ensure the xwl_drm_listener has seen the drm device, if any */
+    wl_display_roundtrip(xwl_screen->display);
+
+    ErrorF("wayland_drm_screen_init, device name %s\n",
+	   xwl_screen->device_name);
+
+    xwl_screen->drm_fd = open(xwl_screen->device_name, O_RDWR);
+    if (xwl_screen->drm_fd < 0) {
+	ErrorF("failed to open the drm fd\n");
+	return BadAccess;
+    }
+
+    if (drmGetMagic(xwl_screen->drm_fd, &magic)) {
+	ErrorF("failed to get drm magic");
+	return BadAccess;
+    }
+
+    wl_drm_authenticate(xwl_screen->drm, magic);
+
+    wl_display_roundtrip(xwl_screen->display);
+
+    ErrorF("opened drm fd: %d\n", xwl_screen->drm_fd);
+
+    if (!xwl_screen->authenticated) {
+	ErrorF("Failed to auth drm fd\n");
+	return BadAccess;
+    }
+
+    return Success;
+}
+
+Bool xwl_drm_initialised(struct xwl_screen *xwl_screen)
+{
+    return xwl_screen->authenticated;
+}
+
+int xwl_screen_get_drm_fd(struct xwl_screen *xwl_screen)
+{
+    return xwl_screen->drm_fd;
+}
+
+int xwl_drm_authenticate(ClientPtr client, struct xwl_screen *xwl_screen,
+			    uint32_t magic)
+{
+    struct xwl_auth_req *req;
+
+    if (!xwl_screen->drm)
+	return BadAccess;
+
+    req = malloc (sizeof *req);
+    if (req == NULL)
+	return BadAlloc;
+
+    req->client = client;
+    req->xwl_screen = xwl_screen;
+    req->magic = magic;
+
+    if (xorg_list_is_empty(&xwl_screen->authenticate_client_list))
+	wl_drm_authenticate (xwl_screen->drm, magic);
+
+    xorg_list_append(&req->link, &xwl_screen->authenticate_client_list);
+
+    IgnoreClient(req->client);
+    xwl_screen->authenticated = 0;
+
+    return Success;
+}
+
+
+int
+xwl_create_window_buffer_drm(struct xwl_window *xwl_window,
+			     PixmapPtr pixmap, uint32_t name)
+{
+    VisualID visual;
+    WindowPtr window = xwl_window->window;
+    ScreenPtr screen = window->drawable.pScreen;
+    uint32_t format;
+    int i;
+
+    visual = wVisual(window);
+    for (i = 0; i < screen->numVisuals; i++)
+	if (screen->visuals[i].vid == visual)
+	    break;
+
+    if (screen->visuals[i].nplanes == 32)
+	format = WL_DRM_FORMAT_ARGB8888;
+    else
+	format = WL_DRM_FORMAT_XRGB8888;
+
+    xwl_window->buffer =
+      wl_drm_create_buffer(xwl_window->xwl_screen->drm,
+			   name,
+			   pixmap->drawable.width,
+			   pixmap->drawable.height,
+			   pixmap->devKind,
+			   format);
+
+    return xwl_window->buffer ? Success : BadDrawable;
+}
diff --git a/hw/xfree86/xwayland/xwayland-input.c b/hw/xfree86/xwayland/xwayland-input.c
new file mode 100644
index 0000000..2f8e0c7
--- /dev/null
+++ b/hw/xfree86/xwayland/xwayland-input.c
@@ -0,0 +1,610 @@
+/*
+ * Copyright © 2008 Kristian Høgsberg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include "xorg-config.h"
+#endif
+
+#include <errno.h>
+#include <stdint.h>
+#include <unistd.h>
+#include <linux/input.h>
+#include <wayland-util.h>
+#include <wayland-client.h>
+#include <X11/extensions/compositeproto.h>
+#include <xserver-properties.h>
+
+#include <compositeext.h>
+#include <selection.h>
+#include <extinit.h>
+#include <exevents.h>
+#include <input.h>
+#include <inpututils.h>
+#include <inputstr.h>
+#include <exevents.h>
+#include <xkbsrv.h>
+#include <xf86Xinput.h>
+#include <xf86Crtc.h>
+#include <xf86str.h>
+#include <windowstr.h>
+#include <xf86Priv.h>
+#include <mipointrst.h>
+#include <sys/mman.h>
+
+#include "xwayland.h"
+#include "xwayland-private.h"
+#include "xserver-client-protocol.h"
+
+static void
+xwl_pointer_control(DeviceIntPtr device, PtrCtrl *ctrl)
+{
+	/* Nothing to do, dix handles all settings */
+}
+
+static int
+xwl_pointer_proc(DeviceIntPtr device, int what)
+{
+#define NBUTTONS 10
+#define NAXES 2
+    BYTE map[NBUTTONS + 1];
+    int i = 0;
+    Atom btn_labels[NBUTTONS] = {0};
+    Atom axes_labels[NAXES] = {0};
+
+    switch (what) {
+    case DEVICE_INIT:
+	device->public.on = FALSE;
+
+        for (i = 1; i <= NBUTTONS; i++)
+            map[i] = i;
+
+        btn_labels[0] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_LEFT);
+        btn_labels[1] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_MIDDLE);
+        btn_labels[2] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_RIGHT);
+        btn_labels[3] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_UP);
+        btn_labels[4] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_WHEEL_DOWN);
+        btn_labels[5] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_LEFT);
+        btn_labels[6] = XIGetKnownProperty(BTN_LABEL_PROP_BTN_HWHEEL_RIGHT);
+        /* don't know about the rest */
+
+        axes_labels[0] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_X);
+        axes_labels[1] = XIGetKnownProperty(AXIS_LABEL_PROP_ABS_Y);
+
+        if (!InitValuatorClassDeviceStruct(device, 2, btn_labels,
+                                           GetMotionHistorySize(), Absolute))
+            return BadValue;
+
+        /* Valuators */
+        InitValuatorAxisStruct(device, 0, axes_labels[0],
+                               0, 0xFFFF, 10000, 0, 10000, Absolute);
+        InitValuatorAxisStruct(device, 1, axes_labels[1],
+                               0, 0xFFFF, 10000, 0, 10000, Absolute);
+
+        if (!InitPtrFeedbackClassDeviceStruct(device, xwl_pointer_control))
+            return BadValue;
+
+        if (!InitButtonClassDeviceStruct(device, 3, btn_labels, map))
+            return BadValue;
+
+        return Success;
+
+    case DEVICE_ON:
+	device->public.on = TRUE;
+        return Success;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+	device->public.on = FALSE;
+        return Success;
+    }
+
+    return BadMatch;
+
+#undef NBUTTONS
+#undef NAXES
+}
+
+static void
+xwl_keyboard_control(DeviceIntPtr device, KeybdCtrl *ctrl)
+{
+    /* FIXME: Set keyboard leds based on CAPSFLAG etc being set in
+     * ctrl->leds - needs private protocol. */
+}
+
+static int
+xwl_keyboard_proc(DeviceIntPtr device, int what)
+{
+    InputInfoPtr pInfo = device->public.devicePrivate;
+    struct xwl_seat *xwl_seat = pInfo->private;
+    int len;
+
+    switch (what) {
+    case DEVICE_INIT:
+	device->public.on = FALSE;
+	len = strnlen(xwl_seat->keymap, xwl_seat->keymap_size);
+        if (!InitKeyboardDeviceStructFromString(device, xwl_seat->keymap,
+						len,
+						NULL, xwl_keyboard_control))
+            return BadValue;
+
+        return Success;
+    case DEVICE_ON:
+	device->public.on = TRUE;
+        return Success;
+
+    case DEVICE_OFF:
+    case DEVICE_CLOSE:
+	device->public.on = FALSE;
+        return Success;
+    }
+
+    return BadMatch;
+}
+
+static void
+xwl_keyboard_uninit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
+{
+}
+
+static int
+xwl_keyboard_init(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
+{
+    pInfo->type_name = "xwayland-keyboard";
+    pInfo->device_control = xwl_keyboard_proc;
+    pInfo->read_input = NULL;
+    pInfo->control_proc = NULL;
+    pInfo->switch_mode = NULL;
+    pInfo->fd = -1;
+
+    return Success;
+}
+
+_X_EXPORT InputDriverRec xwl_keyboard_driver = {
+    1,
+    "xwayland-keyboard",
+    NULL,
+    xwl_keyboard_init,
+    xwl_keyboard_uninit,
+    NULL,
+};
+
+static void
+xwl_pointer_uninit(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
+{
+}
+
+static int
+xwl_pointer_init(InputDriverPtr drv, InputInfoPtr pInfo, int flags)
+{
+    pInfo->type_name = "xwayland-pointer";
+    pInfo->device_control = xwl_pointer_proc;
+    pInfo->read_input = NULL;
+    pInfo->control_proc = NULL;
+    pInfo->switch_mode = NULL;
+    pInfo->fd = -1;
+
+    return Success;
+}
+
+_X_EXPORT InputDriverRec xwl_pointer_driver = {
+    1,
+    "xwayland-pointer",
+    NULL,
+    xwl_pointer_init,
+    xwl_pointer_uninit,
+    NULL,
+};
+
+void
+xwl_input_teardown(pointer p)
+{
+}
+
+pointer
+xwl_input_setup(pointer module, pointer opts, int *errmaj, int *errmin)
+{
+    xf86AddInputDriver(&xwl_keyboard_driver, module, 0);
+    xf86AddInputDriver(&xwl_pointer_driver, module, 0);
+
+    return module;
+}
+
+static DeviceIntPtr
+device_added(struct xwl_seat *xwl_seat, const char *driver)
+{
+    DeviceIntPtr dev = NULL;
+    InputInfoPtr pInfo;
+    int rc;
+
+    pInfo = xf86AllocateInput();
+    if (!pInfo)
+        return NULL;
+
+    pInfo->driver = xstrdup(driver);
+
+    if (asprintf(&pInfo->name, "%s:%d", pInfo->driver, xwl_seat->id) == -1) {
+	free(pInfo);
+	return NULL;
+    }
+
+    pInfo->private = xwl_seat;
+
+    rc = xf86NewInputDevice(pInfo, &dev, 1);
+    if (rc != Success) {
+	free(pInfo);
+	return NULL;
+    }
+
+    LogMessage(X_INFO, "config/xwayland: Adding input device %s\n",
+	       pInfo->name);
+
+    return dev;
+}
+
+static void
+pointer_handle_enter(void *data, struct wl_pointer *pointer,
+		     uint32_t serial, struct wl_surface *surface,
+		     wl_fixed_t sx_w, wl_fixed_t sy_w)
+
+{
+    struct xwl_seat *xwl_seat = data;
+    DeviceIntPtr dev = xwl_seat->pointer;
+    int i;
+    int sx = wl_fixed_to_int(sx_w);
+    int sy = wl_fixed_to_int(sy_w);
+    ScreenPtr pScreen = xwl_seat->xwl_screen->screen;
+
+    xwl_seat->xwl_screen->serial = serial;
+    xwl_seat->pointer_enter_serial = serial;
+
+    xwl_seat->focus_window = wl_surface_get_user_data(surface);
+
+    (*pScreen->SetCursorPosition) (dev, pScreen, sx, sy, TRUE);
+
+    SetDeviceRedirectWindow(xwl_seat->pointer, xwl_seat->focus_window->window);
+
+    /* Ideally, X clients shouldn't see these button releases.  When
+     * the pointer leaves a window with buttons down, it means that
+     * the wayland compositor has grabbed the pointer.  The button
+     * release event is consumed by whatever grab in the compositor
+     * and won't be sent to clients (the X server is a client).
+     * However, we need to reset X's idea of which buttons are up and
+     * down, and they're all up (by definition) when the pointer
+     * enters a window.  We should figure out a way to swallow these
+     * events, perhaps using an X grab whenever the pointer is not in
+     * any X window, but for now just send the events. */
+    for (i = 0; i < dev->button->numButtons; i++)
+	if (BitIsOn(dev->button->down, i))
+		xf86PostButtonEvent(dev, TRUE, i, 0, 0, 0);
+
+    (*pScreen->DisplayCursor)(dev, pScreen, dev->spriteInfo->sprite->current);
+}
+
+static void
+pointer_handle_leave(void *data, struct wl_pointer *pointer,
+		     uint32_t serial, struct wl_surface *surface)
+{
+    struct xwl_seat *xwl_seat = data;
+    DeviceIntPtr dev = xwl_seat->pointer;
+    ScreenPtr pScreen = xwl_seat->xwl_screen->screen;
+
+    xwl_seat->xwl_screen->serial = serial;
+
+    xwl_seat->focus_window = NULL;
+    SetDeviceRedirectWindow(xwl_seat->pointer, PointerRootWin);
+    (*pScreen->DisplayCursor)(dev, pScreen, NullCursor);
+}
+
+static void
+pointer_handle_motion(void *data, struct wl_pointer *pointer,
+		      uint32_t time, wl_fixed_t sx_w, wl_fixed_t sy_w)
+{
+    struct xwl_seat *xwl_seat = data;
+    int32_t dx, dy;
+    int sx = wl_fixed_to_int(sx_w);
+    int sy = wl_fixed_to_int(sy_w);
+    ValuatorMask mask;
+
+    if (!xwl_seat->focus_window)
+	return ;
+
+    dx = xwl_seat->focus_window->window->drawable.x;
+    dy = xwl_seat->focus_window->window->drawable.y;
+
+    valuator_mask_zero(&mask);
+    valuator_mask_set(&mask, 0, dx + sx);
+    valuator_mask_set(&mask, 1, dy + sy);
+
+    QueuePointerEvents(xwl_seat->pointer, MotionNotify, 0,
+		       POINTER_ABSOLUTE | POINTER_SCREEN, &mask);
+}
+
+static void
+pointer_handle_button(void *data, struct wl_pointer *pointer, uint32_t serial,
+		      uint32_t time, uint32_t button, uint32_t state)
+{
+    struct xwl_seat *xwl_seat = data;
+    int index;
+
+    xwl_seat->xwl_screen->serial = serial;
+
+    switch (button) {
+    case BTN_MIDDLE:
+	index = 2;
+	break;
+    case BTN_RIGHT:
+	index = 3;
+	break;
+    default:
+	index = button - BTN_LEFT + 1;
+	break;
+    }
+
+    xf86PostButtonEvent(xwl_seat->pointer, TRUE, index, state, 0, 0);
+}
+
+static void
+pointer_handle_axis(void *data, struct wl_pointer *pointer,
+		    uint32_t time, uint32_t axis, wl_fixed_t value)
+{
+    struct xwl_seat *xwl_seat = data;
+    int index, count;
+    int i, val;
+    const int divisor = 10;
+
+    if (time - xwl_seat->scroll_time > 2000) {
+	xwl_seat->vertical_scroll = 0;
+	xwl_seat->horizontal_scroll = 0;
+    }
+    xwl_seat->scroll_time = time;
+
+    /* FIXME: Need to do proper smooth scrolling here! */
+    switch (axis) {
+    case WL_POINTER_AXIS_VERTICAL_SCROLL:
+	xwl_seat->vertical_scroll += value / divisor;
+	val = wl_fixed_to_int(xwl_seat->vertical_scroll);
+	xwl_seat->vertical_scroll -= wl_fixed_from_int(val);
+
+	if (val <= -1)
+            index = 4;
+	else if (val >= 1)
+            index = 5;
+	else
+            return;
+	break;
+    case WL_POINTER_AXIS_HORIZONTAL_SCROLL:
+	xwl_seat->horizontal_scroll += value / divisor;
+	val = wl_fixed_to_int(xwl_seat->horizontal_scroll);
+	xwl_seat->horizontal_scroll -= wl_fixed_from_int(val);
+
+	if (val <= -1)
+            index = 6;
+	else if (val >= 1)
+            index = 7;
+	else
+            return;
+	break;
+    default:
+	return;
+    }
+
+    count = abs(val);
+    for (i = 0; i < count; i++) {
+	xf86PostButtonEvent(xwl_seat->pointer, TRUE, index, 1, 0, 0);
+	xf86PostButtonEvent(xwl_seat->pointer, TRUE, index, 0, 0, 0);
+    }
+}
+
+static const struct wl_pointer_listener pointer_listener = {
+	pointer_handle_enter,
+	pointer_handle_leave,
+	pointer_handle_motion,
+	pointer_handle_button,
+	pointer_handle_axis,
+};
+
+static void
+keyboard_handle_key(void *data, struct wl_keyboard *keyboard, uint32_t serial,
+		    uint32_t time, uint32_t key, uint32_t state)
+{
+    struct xwl_seat *xwl_seat = data;
+    uint32_t *k, *end;
+
+    xwl_seat->xwl_screen->serial = serial;
+
+    end = xwl_seat->keys.data + xwl_seat->keys.size;
+    for (k = xwl_seat->keys.data; k < end; k++) {
+	if (*k == key)
+	    *k = *--end;
+    }
+    xwl_seat->keys.size = (void *) end - xwl_seat->keys.data;
+    if (state) {
+	k = wl_array_add(&xwl_seat->keys, sizeof *k);
+	*k = key;
+    }
+
+    xf86PostKeyboardEvent(xwl_seat->keyboard, key + 8, state);
+}
+
+static void
+keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+		       uint32_t format, int fd, uint32_t size)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    xwl_seat->keymap_size = size;
+    xwl_seat->keymap = mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
+    if (xwl_seat->keymap == MAP_FAILED)
+	;	/* wah wah */
+
+    close(fd);
+}
+
+static void
+keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+		      uint32_t serial,
+		      struct wl_surface *surface, struct wl_array *keys)
+{
+    struct xwl_seat *xwl_seat = data;
+    uint32_t *k;
+
+    xwl_seat->xwl_screen->serial = serial;
+
+    wl_array_copy(&xwl_seat->keys, keys);
+    wl_array_for_each(k, &xwl_seat->keys)
+	xf86PostKeyboardEvent(xwl_seat->keyboard, *k + 8, 1);
+}
+
+static void
+keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+		      uint32_t serial, struct wl_surface *surface)
+{
+    struct xwl_seat *xwl_seat = data;
+    uint32_t *k;
+
+    xwl_seat->xwl_screen->serial = serial;
+
+    wl_array_for_each(k, &xwl_seat->keys)
+	xf86PostKeyboardEvent(xwl_seat->keyboard, *k + 8, 0);
+}
+
+static void
+keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+			  uint32_t serial, uint32_t mods_depressed,
+			  uint32_t mods_latched, uint32_t mods_locked,
+			  uint32_t group)
+{
+    /* FIXME: Need more server XKB API here. */
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+	keyboard_handle_keymap,
+	keyboard_handle_enter,
+	keyboard_handle_leave,
+	keyboard_handle_key,
+	keyboard_handle_modifiers,
+};
+
+static void
+add_devices(void *data, struct wl_callback *callback, uint32_t time)
+{
+    struct xwl_seat *xwl_seat = data;
+
+    wl_callback_destroy(callback);
+
+    if (xwl_seat->wl_pointer)
+	xwl_seat->pointer = device_added(xwl_seat, "xwayland-pointer");
+    if (xwl_seat->wl_keyboard)
+	xwl_seat->keyboard = device_added(xwl_seat, "xwayland-keyboard");
+}
+
+static const struct wl_callback_listener add_devices_listener = {
+	add_devices
+};
+
+static void
+seat_handle_capabilities(void *data, struct wl_seat *seat,
+			 enum wl_seat_capability caps)
+{
+	struct xwl_seat *xwl_seat = data;
+	struct wl_callback *callback;
+
+	if (caps & WL_SEAT_CAPABILITY_POINTER) {
+	    xwl_seat->wl_pointer = wl_seat_get_pointer(seat);
+	    wl_pointer_add_listener(xwl_seat->wl_pointer,
+				    &pointer_listener, xwl_seat);
+            xwl_seat_set_cursor(xwl_seat);
+	}
+
+	if (caps & WL_SEAT_CAPABILITY_KEYBOARD) {
+	    xwl_seat->wl_keyboard = wl_seat_get_keyboard(seat);
+	    wl_keyboard_add_listener(xwl_seat->wl_keyboard,
+				     &keyboard_listener, xwl_seat);
+
+	}
+        /* FIXME: Touch ... */
+
+	/* Add devices after we've received keymaps. */
+	if (caps) {
+	    callback = wl_display_sync(xwl_seat->xwl_screen->display);
+	    wl_callback_add_listener(callback,
+				     &add_devices_listener, xwl_seat);
+	}
+}
+
+static const struct wl_seat_listener seat_listener = {
+	seat_handle_capabilities,
+};
+
+static void
+create_input_device(struct xwl_screen *xwl_screen, uint32_t id)
+{
+    struct xwl_seat *xwl_seat;
+
+    xwl_seat = calloc(sizeof *xwl_seat, 1);
+    if (xwl_seat == NULL) {
+	ErrorF("create_input ENOMEM");
+	return ;
+    }
+
+    xwl_seat->xwl_screen = xwl_screen;
+    xorg_list_add(&xwl_seat->link, &xwl_screen->seat_list);
+
+    xwl_seat->seat =
+	wl_registry_bind(xwl_screen->registry, id, &wl_seat_interface, 1);
+    xwl_seat->id = id;
+
+    xwl_seat->cursor = wl_compositor_create_surface(xwl_screen->compositor);
+    wl_seat_add_listener(xwl_seat->seat, &seat_listener, xwl_seat);
+    wl_array_init(&xwl_seat->keys);
+}
+
+static void
+input_handler(void *data, struct wl_registry *registry, uint32_t id,
+	      const char *interface, uint32_t version)
+{
+    struct xwl_screen *xwl_screen = data;
+
+    if (strcmp (interface, "wl_seat") == 0) {
+        create_input_device(xwl_screen, id);
+    } else if (strcmp(interface, "xserver") == 0) {
+        xwl_screen->xorg_server =
+            wl_registry_bind(registry, id, &xserver_interface, 1);
+        xserver_add_listener(xwl_screen->xorg_server, &xwl_server_listener,
+                             xwl_screen);
+    }
+}
+
+static const struct wl_registry_listener input_listener = {
+    input_handler,
+};
+
+void
+xwl_input_init(struct xwl_screen *xwl_screen)
+{
+    xwl_screen->input_registry = wl_display_get_registry(xwl_screen->display);
+    wl_registry_add_listener(xwl_screen->input_registry, &input_listener,
+                             xwl_screen);
+}
diff --git a/hw/xfree86/xwayland/xwayland-output.c b/hw/xfree86/xwayland/xwayland-output.c
new file mode 100644
index 0000000..8f087f6
--- /dev/null
+++ b/hw/xfree86/xwayland/xwayland-output.c
@@ -0,0 +1,309 @@
+/*
+ * Copyright © 2011 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include "xorg-config.h"
+#endif
+
+#include <unistd.h>
+#include <errno.h>
+#include <sys/mman.h>
+#include <wayland-client.h>
+
+#include <xorg-server.h>
+#include <cursorstr.h>
+#include <xf86Crtc.h>
+#include <mipointrst.h>
+
+#include "xwayland.h"
+#include "xwayland-private.h"
+#include "xserver-client-protocol.h"
+
+static void
+crtc_dpms(xf86CrtcPtr drmmode_crtc, int mode)
+{
+}
+
+static Bool
+crtc_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
+		    Rotation rotation, int x, int y)
+{
+	return TRUE;
+}
+
+static void
+crtc_set_cursor_colors (xf86CrtcPtr crtc, int bg, int fg)
+{
+}
+
+static void
+crtc_set_cursor_position (xf86CrtcPtr crtc, int x, int y)
+{
+}
+
+static void
+crtc_show_cursor (xf86CrtcPtr crtc)
+{
+}
+
+static void
+crtc_hide_cursor (xf86CrtcPtr crtc)
+{
+}
+
+static void
+crtc_load_cursor_argb (xf86CrtcPtr crtc, CARD32 *image)
+{
+}
+
+static PixmapPtr
+crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
+{
+	return NULL;
+}
+
+static void *
+crtc_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
+{
+	return NULL;
+}
+
+static void
+crtc_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rotate_pixmap, void *data)
+{
+}
+
+static const xf86CrtcFuncsRec crtc_funcs = {
+    .dpms                = crtc_dpms,
+    .set_mode_major      = crtc_set_mode_major,
+    .set_cursor_colors   = crtc_set_cursor_colors,
+    .set_cursor_position = crtc_set_cursor_position,
+    .show_cursor         = crtc_show_cursor,
+    .hide_cursor         = crtc_hide_cursor,
+    .load_cursor_argb    = crtc_load_cursor_argb,
+    .shadow_create       = crtc_shadow_create,
+    .shadow_allocate     = crtc_shadow_allocate,
+    .shadow_destroy      = crtc_shadow_destroy,
+    .destroy		 = NULL, /* XXX */
+};
+
+static void
+output_dpms(xf86OutputPtr output, int mode)
+{
+	return;
+}
+
+static xf86OutputStatus
+output_detect(xf86OutputPtr output)
+{
+	return XF86OutputStatusConnected;
+}
+
+static Bool
+output_mode_valid(xf86OutputPtr output, DisplayModePtr pModes)
+{
+	return MODE_OK;
+}
+
+static DisplayModePtr
+output_get_modes(xf86OutputPtr xf86output)
+{
+    struct xwl_output *output = xf86output->driver_private;
+    struct monitor_ranges *ranges;
+    DisplayModePtr modes;
+
+    modes = xf86CVTMode(output->width, output->height, 60, TRUE, FALSE);
+    output->xf86monitor.det_mon[0].type = DS_RANGES;
+    ranges = &output->xf86monitor.det_mon[0].section.ranges;
+    ranges->min_h = modes->HSync - 10;
+    ranges->max_h = modes->HSync + 10;
+    ranges->min_v = modes->VRefresh - 10;
+    ranges->max_v = modes->VRefresh + 10;
+    ranges->max_clock = modes->Clock + 100;
+    output->xf86monitor.det_mon[1].type = DT;
+    output->xf86monitor.det_mon[2].type = DT;
+    output->xf86monitor.det_mon[3].type = DT;
+    output->xf86monitor.no_sections = 0;
+
+    xf86output->MonInfo = &output->xf86monitor;
+
+    return modes;
+}
+
+static void
+output_destroy(xf86OutputPtr xf86output)
+{
+    struct xwl_output *output = xf86output->driver_private;
+
+    free(output);
+}
+
+static const xf86OutputFuncsRec output_funcs = {
+    .dpms	= output_dpms,
+    .detect	= output_detect,
+    .mode_valid	= output_mode_valid,
+    .get_modes	= output_get_modes,
+    .destroy	= output_destroy
+};
+
+struct xwl_output *
+xwl_output_create(struct xwl_screen *xwl_screen)
+{
+    struct xwl_output *xwl_output;
+    xf86OutputPtr xf86output;
+    xf86CrtcPtr xf86crtc;
+
+    xwl_output = calloc(sizeof *xwl_output, 1);
+    if (xwl_output == NULL) {
+	ErrorF("create_output ENOMEM");
+	return NULL;
+    }
+
+    xwl_output->xwl_screen = xwl_screen;
+
+    xf86output = xf86OutputCreate(xwl_screen->scrninfo,
+				  &output_funcs, "XWAYLAND-1");
+    xf86output->driver_private = xwl_output;
+    xf86output->possible_crtcs = 1;
+    xf86output->possible_clones = 1;
+
+    xf86crtc = xf86CrtcCreate(xwl_screen->scrninfo, &crtc_funcs);
+    xf86crtc->driver_private = xwl_output;
+
+    xwl_output->xf86output = xf86output;
+    xwl_output->xf86crtc = xf86crtc;
+
+    return xwl_output;
+}
+
+static Bool
+resize(ScrnInfoPtr scrn, int width, int height)
+{
+    if (scrn->virtualX == width && scrn->virtualY == height)
+	return TRUE;
+    /* We don't handle resize at all, we must match the compositor size */
+    return FALSE;
+}
+
+static const xf86CrtcConfigFuncsRec config_funcs = {
+    resize
+};
+
+static void
+display_handle_geometry(void *data, struct wl_output *wl_output, int x, int y,
+			int physical_width, int physical_height, int subpixel,
+			const char *make, const char *model, int transform)
+{
+    struct xwl_output *xwl_output = data;
+    struct xwl_screen *xwl_screen = xwl_output->xwl_screen;
+
+    xwl_output->xf86output->mm_width = physical_width;
+    xwl_output->xf86output->mm_height = physical_height;
+
+    switch (subpixel) {
+    case WL_OUTPUT_SUBPIXEL_UNKNOWN:
+	xwl_output->xf86output->subpixel_order = SubPixelUnknown;
+	break;
+    case WL_OUTPUT_SUBPIXEL_NONE:
+	xwl_output->xf86output->subpixel_order = SubPixelNone;
+	break;
+    case WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB:
+	xwl_output->xf86output->subpixel_order = SubPixelHorizontalRGB;
+	break;
+    case WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR:
+	xwl_output->xf86output->subpixel_order = SubPixelHorizontalBGR;
+	break;
+    case WL_OUTPUT_SUBPIXEL_VERTICAL_RGB:
+	xwl_output->xf86output->subpixel_order = SubPixelVerticalRGB;
+	break;
+    case WL_OUTPUT_SUBPIXEL_VERTICAL_BGR:
+	xwl_output->xf86output->subpixel_order = SubPixelVerticalBGR;
+	break;
+    }
+
+    xwl_output->x = x;
+    xwl_output->y = y;
+
+    xwl_screen->xwl_output = xwl_output;
+}
+
+static void
+display_handle_mode(void *data, struct wl_output *wl_output, uint32_t flags,
+		    int width, int height, int refresh)
+{
+    struct xwl_output *xwl_output = data;
+
+    if (flags & WL_OUTPUT_MODE_CURRENT) {
+	xwl_output->width = width;
+	xwl_output->height = height;
+    }
+}
+
+static const struct wl_output_listener output_listener = {
+    display_handle_geometry,
+    display_handle_mode
+};
+
+static void
+global_handler(void *data, struct wl_registry *registry, uint32_t id,
+	       const char *interface, uint32_t version)
+{
+    struct xwl_screen *xwl_screen = data;
+    struct xwl_output *xwl_output;
+
+    if (strcmp (interface, "wl_output") == 0) {
+	xwl_output = xwl_output_create(xwl_screen);
+	xwl_output->output = wl_registry_bind(registry, id,
+	                                      &wl_output_interface, 1);
+	wl_output_add_listener(xwl_output->output,
+			       &output_listener, xwl_output);
+    }
+}
+
+static const struct wl_registry_listener global_listener = {
+    global_handler,
+};
+
+void
+xwayland_screen_preinit_output(struct xwl_screen *xwl_screen, ScrnInfoPtr scrninfo)
+{
+    int ret;
+
+    xf86CrtcConfigInit(scrninfo, &config_funcs);
+
+    xf86CrtcSetSizeRange(scrninfo, 320, 200, 8192, 8192);
+
+    xwl_screen->output_registry = wl_display_get_registry(xwl_screen->display);
+    wl_registry_add_listener(xwl_screen->output_registry, &global_listener,
+                             xwl_screen);
+
+    while (!xwl_screen->xwl_output) {
+        ret = wl_display_roundtrip(xwl_screen->display);
+        if (ret == -1)
+            FatalError("failed to dispatch Wayland events: %s\n", strerror(errno));
+    }
+
+    xf86InitialConfiguration(scrninfo, TRUE);
+}
diff --git a/hw/xfree86/xwayland/xwayland-private.h b/hw/xfree86/xwayland/xwayland-private.h
new file mode 100644
index 0000000..e427316
--- /dev/null
+++ b/hw/xfree86/xwayland/xwayland-private.h
@@ -0,0 +1,132 @@
+/*
+ * Copyright © 2010 Kristian Høgsberg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef _XWAYLAND_PRIVATE_H_
+#define _XWAYLAND_PRIVATE_H_
+
+struct xwl_window {
+    struct xwl_screen		*xwl_screen;
+    struct wl_surface		*surface;
+    struct wl_buffer		*buffer;
+    WindowPtr			 window;
+    DamagePtr			 damage;
+    struct xorg_list		 link;
+    struct xorg_list		 link_damage;
+};
+
+struct xwl_output;
+
+struct xwl_screen {
+    struct xwl_driver		*driver;
+    ScreenPtr			 screen;
+    ScrnInfoPtr			 scrninfo;
+    int				 drm_fd;
+    int				 wayland_fd;
+    struct xwl_output		*xwl_output;
+    struct wl_display		*display;
+    struct wl_registry          *registry;
+    struct wl_registry          *drm_registry;
+    struct wl_registry          *input_registry;
+    struct wl_registry          *output_registry;
+    struct wl_compositor	*compositor;
+    struct wl_drm		*drm;
+    struct wl_shm		*shm;
+    struct xserver		*xorg_server;
+    uint32_t			 mask;
+    uint32_t			 flags;
+    char			*device_name;
+    uint32_t			 authenticated;
+    struct xorg_list		 seat_list;
+    struct xorg_list		 damage_window_list;
+    struct xorg_list		 window_list;
+    struct xorg_list		 authenticate_client_list;
+    uint32_t			 serial;
+
+    CreateWindowProcPtr		 CreateWindow;
+    DestroyWindowProcPtr	 DestroyWindow;
+    RealizeWindowProcPtr	 RealizeWindow;
+    UnrealizeWindowProcPtr	 UnrealizeWindow;
+    SetWindowPixmapProcPtr	 SetWindowPixmap;
+    MoveWindowProcPtr		 MoveWindow;
+    miPointerSpriteFuncPtr	 sprite_funcs;
+};
+
+struct xwl_output {
+    struct wl_output		*output;
+    struct xwl_screen		*xwl_screen;
+    int32_t			 x, y, width, height;
+    xf86Monitor			 xf86monitor;
+    xf86OutputPtr		 xf86output;
+    xf86CrtcPtr			 xf86crtc;
+};
+
+
+#define MODIFIER_META 0x01
+
+struct xwl_seat {
+    DeviceIntPtr		 pointer;
+    DeviceIntPtr		 keyboard;
+    struct xwl_screen		*xwl_screen;
+    struct wl_seat		*seat;
+    struct wl_pointer		*wl_pointer;
+    struct wl_keyboard		*wl_keyboard;
+    struct wl_array		 keys;
+    struct wl_surface		*cursor;
+    struct xwl_window		*focus_window;
+    uint32_t			 id;
+    uint32_t			 pointer_enter_serial;
+    struct xorg_list		 link;
+    CursorPtr                    x_cursor;
+
+    wl_fixed_t			 horizontal_scroll;
+    wl_fixed_t			 vertical_scroll;
+    uint32_t			 scroll_time;
+
+    size_t			 keymap_size;
+    char			*keymap;
+
+};
+
+
+struct xwl_screen *xwl_screen_get(ScreenPtr screen);
+
+void xwayland_screen_preinit_output(struct xwl_screen *xwl_screen, ScrnInfoPtr scrninfo);
+
+int xwl_screen_init_cursor(struct xwl_screen *xwl_screen, ScreenPtr screen);
+int xwl_screen_init_window(struct xwl_screen *xwl_screen, ScreenPtr screen);
+
+struct xwl_output *xwl_output_create(struct xwl_screen *xwl_screen);
+
+void xwl_input_teardown(pointer p);
+pointer xwl_input_setup(pointer module, pointer opts, int *errmaj, int *errmin);
+void xwl_input_init(struct xwl_screen *screen);
+
+Bool xwl_drm_initialised(struct xwl_screen *screen);
+
+void xwl_seat_set_cursor(struct xwl_seat *xwl_seat);
+
+extern const struct xserver_listener xwl_server_listener;
+
+#endif /* _XWAYLAND_PRIVATE_H_ */
diff --git a/hw/xfree86/xwayland/xwayland-window.c b/hw/xfree86/xwayland/xwayland-window.c
new file mode 100644
index 0000000..d56e0d0
--- /dev/null
+++ b/hw/xfree86/xwayland/xwayland-window.c
@@ -0,0 +1,317 @@
+/*
+ * Copyright © 2011 Intel Corporation
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include "xorg-config.h"
+#endif
+
+#include <unistd.h>
+#include <errno.h>
+#include <sys/mman.h>
+#include <wayland-client.h>
+#include <X11/extensions/compositeproto.h>
+
+#include <xorg-server.h>
+#include <xf86Crtc.h>
+#include <selection.h>
+#include <compositeext.h>
+#include <exevents.h>
+
+#include "xwayland.h"
+#include "xwayland-private.h"
+#include "xserver-client-protocol.h"
+
+static DevPrivateKeyRec xwl_window_private_key;
+
+static void
+free_pixmap(void *data, struct wl_callback *callback, uint32_t time)
+{
+    PixmapPtr pixmap = data;
+    ScreenPtr screen = pixmap->drawable.pScreen;
+
+    (*screen->DestroyPixmap)(pixmap);
+    wl_callback_destroy(callback);
+}
+
+static const struct wl_callback_listener free_pixmap_listener = {
+	free_pixmap,
+};
+
+static void
+xwl_window_attach(struct xwl_window *xwl_window, PixmapPtr pixmap)
+{
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+    struct wl_callback *callback;
+
+    /* We can safely destroy the buffer because we only use one buffer
+     * per surface in xwayland model */
+    if (xwl_window->buffer)
+        wl_buffer_destroy(xwl_window->buffer);
+
+    xwl_screen->driver->create_window_buffer(xwl_window, pixmap);
+
+    if (!xwl_window->buffer) {
+        ErrorF("failed to create buffer\n");
+	return;
+    }
+
+    wl_surface_attach(xwl_window->surface, xwl_window->buffer, 0, 0);
+    wl_surface_damage(xwl_window->surface, 0, 0,
+		      pixmap->drawable.width,
+		      pixmap->drawable.height);
+    wl_surface_commit(xwl_window->surface);
+
+    callback = wl_display_sync(xwl_screen->display);
+    wl_callback_add_listener(callback, &free_pixmap_listener, pixmap);
+    pixmap->refcnt++;
+}
+
+static Bool
+xwl_create_window(WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen;
+    char buffer[32];
+    int len, rc;
+    Atom name;
+    Bool ret;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    screen->CreateWindow = xwl_screen->CreateWindow;
+    ret = (*screen->CreateWindow)(window);
+    xwl_screen->CreateWindow = screen->CreateWindow;
+    screen->CreateWindow = xwl_create_window;
+
+    if (!(xwl_screen->flags & XWL_FLAGS_ROOTLESS) ||
+	window->parent != NULL)
+	return ret;
+
+    CompositeRedirectSubwindows(window, CompositeRedirectManual);
+
+    return ret;
+}
+
+static int
+xwl_destroy_window (WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen;
+    Bool ret;
+
+    if (window->parent == NULL)
+	CompositeUnRedirectSubwindows (window, CompositeRedirectManual);
+
+    xwl_screen = xwl_screen_get(screen);
+
+    screen->DestroyWindow = xwl_screen->DestroyWindow;
+    ret = (*screen->DestroyWindow)(window);
+    xwl_screen->DestroyWindow = screen->DestroyWindow;
+    screen->DestroyWindow = xwl_destroy_window;
+
+    return ret;
+}
+
+static void
+damage_report(DamagePtr pDamage, RegionPtr pRegion, void *data)
+{
+    struct xwl_window *xwl_window = data;
+    struct xwl_screen *xwl_screen = xwl_window->xwl_screen;
+
+    xorg_list_add(&xwl_window->link_damage, &xwl_screen->damage_window_list);
+}
+
+static void
+damage_destroy(DamagePtr pDamage, void *data)
+{
+}
+
+static Bool
+xwl_realize_window(WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen;
+    struct xwl_window *xwl_window;
+    Bool ret;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    screen->RealizeWindow = xwl_screen->RealizeWindow;
+    ret = (*screen->RealizeWindow)(window);
+    xwl_screen->RealizeWindow = xwl_screen->RealizeWindow;
+    screen->RealizeWindow = xwl_realize_window;
+
+    if (xwl_screen->flags & XWL_FLAGS_ROOTLESS) {
+	if (window->redirectDraw != RedirectDrawManual)
+	    return ret;
+    } else {
+	if (window->parent)
+	    return ret;
+    }
+
+    xwl_window = calloc(sizeof *xwl_window, 1);
+    xwl_window->xwl_screen = xwl_screen;
+    xwl_window->window = window;
+    xwl_window->surface =
+	wl_compositor_create_surface(xwl_screen->compositor);
+    if (xwl_window->surface == NULL) {
+	ErrorF("wl_display_create_surface failed\n");
+	return FALSE;
+    }
+
+    if (xwl_screen->xorg_server)
+	xserver_set_window_id(xwl_screen->xorg_server,
+			      xwl_window->surface, window->drawable.id);
+
+    wl_surface_set_user_data(xwl_window->surface, xwl_window);
+    xwl_window_attach(xwl_window, (*screen->GetWindowPixmap)(window));
+
+    dixSetPrivate(&window->devPrivates,
+		  &xwl_window_private_key, xwl_window);
+
+    xwl_window->damage =
+	DamageCreate(damage_report, damage_destroy, DamageReportNonEmpty,
+		     FALSE, screen, xwl_window);
+    DamageRegister(&window->drawable, xwl_window->damage);
+    DamageSetReportAfterOp(xwl_window->damage, TRUE);
+
+    xorg_list_add(&xwl_window->link, &xwl_screen->window_list);
+    xorg_list_init(&xwl_window->link_damage);
+
+    return ret;
+}
+
+static Bool
+xwl_unrealize_window(WindowPtr window)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen;
+    struct xwl_window *xwl_window;
+    struct xwl_seat *xwl_seat;
+    Bool ret;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    xorg_list_for_each_entry(xwl_seat,
+			     &xwl_screen->seat_list, link) {
+	if (!xwl_seat->focus_window)
+	    continue ;
+	if (xwl_seat->focus_window->window == window) {
+	    xwl_seat->focus_window = NULL;
+	    SetDeviceRedirectWindow(xwl_seat->pointer, PointerRootWin);
+	}
+    }
+
+    screen->UnrealizeWindow = xwl_screen->UnrealizeWindow;
+    ret = (*screen->UnrealizeWindow)(window);
+    xwl_screen->UnrealizeWindow = screen->UnrealizeWindow;
+    screen->UnrealizeWindow = xwl_unrealize_window;
+
+    xwl_window =
+	dixLookupPrivate(&window->devPrivates, &xwl_window_private_key);
+    if (!xwl_window)
+	return ret;
+
+    if (xwl_window->buffer)
+	wl_buffer_destroy(xwl_window->buffer);
+    wl_surface_destroy(xwl_window->surface);
+    xorg_list_del(&xwl_window->link);
+    if (RegionNotEmpty(DamageRegion(xwl_window->damage)))
+	xorg_list_del(&xwl_window->link_damage);
+    DamageUnregister(&window->drawable, xwl_window->damage);
+    DamageDestroy(xwl_window->damage);
+    free(xwl_window);
+    dixSetPrivate(&window->devPrivates, &xwl_window_private_key, NULL);
+
+    return ret;
+}
+
+static void
+xwl_set_window_pixmap(WindowPtr window, PixmapPtr pixmap)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen;
+    struct xwl_window *xwl_window;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    screen->SetWindowPixmap = xwl_screen->SetWindowPixmap;
+    (*screen->SetWindowPixmap)(window, pixmap);
+    xwl_screen->SetWindowPixmap = screen->SetWindowPixmap;
+    screen->SetWindowPixmap = xwl_set_window_pixmap;
+
+    xwl_window =
+	dixLookupPrivate(&window->devPrivates, &xwl_window_private_key);
+    if (xwl_window)
+	xwl_window_attach(xwl_window, pixmap);
+}
+
+static void
+xwl_move_window(WindowPtr window, int x, int y,
+		   WindowPtr sibling, VTKind kind)
+{
+    ScreenPtr screen = window->drawable.pScreen;
+    struct xwl_screen *xwl_screen;
+    struct xwl_window *xwl_window;
+
+    xwl_screen = xwl_screen_get(screen);
+
+    screen->MoveWindow = xwl_screen->MoveWindow;
+    (*screen->MoveWindow)(window, x, y, sibling, kind);
+    xwl_screen->MoveWindow = screen->MoveWindow;
+    screen->MoveWindow = xwl_move_window;
+
+    xwl_window =
+	dixLookupPrivate(&window->devPrivates, &xwl_window_private_key);
+    if (xwl_window == NULL)
+	return;
+}
+
+int
+xwl_screen_init_window(struct xwl_screen *xwl_screen, ScreenPtr screen)
+{
+    if (!dixRegisterPrivateKey(&xwl_window_private_key, PRIVATE_WINDOW, 0))
+	return BadAlloc;
+
+    xwl_screen->CreateWindow = screen->CreateWindow;
+    screen->CreateWindow = xwl_create_window;
+
+    xwl_screen->DestroyWindow = screen->DestroyWindow;
+    screen->DestroyWindow = xwl_destroy_window;
+
+    xwl_screen->RealizeWindow = screen->RealizeWindow;
+    screen->RealizeWindow = xwl_realize_window;
+
+    xwl_screen->UnrealizeWindow = screen->UnrealizeWindow;
+    screen->UnrealizeWindow = xwl_unrealize_window;
+
+    xwl_screen->SetWindowPixmap = screen->SetWindowPixmap;
+    screen->SetWindowPixmap = xwl_set_window_pixmap;
+
+    xwl_screen->MoveWindow = screen->MoveWindow;
+    screen->MoveWindow = xwl_move_window;
+
+    return Success;
+}
diff --git a/hw/xfree86/xwayland/xwayland.c b/hw/xfree86/xwayland/xwayland.c
new file mode 100644
index 0000000..f59bfe4
--- /dev/null
+++ b/hw/xfree86/xwayland/xwayland.c
@@ -0,0 +1,392 @@
+/*
+ * Copyright © 2008-2011 Kristian Høgsberg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include "xorg-config.h"
+#endif
+
+#include <stdint.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <wayland-util.h>
+#include <wayland-client.h>
+
+#include <xorg-server.h>
+#include <extinit.h>
+
+#include <xf86Xinput.h>
+#include <xf86Crtc.h>
+#include <xf86Priv.h>
+#include <os.h>
+#include <selection.h>
+
+#include "xwayland.h"
+#include "xwayland-private.h"
+#include "xserver-client-protocol.h"
+
+/*
+ * TODO:
+ *  - lose X kb focus when wayland surface loses it
+ *  - active grabs, grab owner crack
+ */
+
+static DevPrivateKeyRec xwl_screen_private_key;
+static Atom xdnd_atom;
+
+static void
+xserver_client(void *data, struct xserver *xserver, int fd)
+{
+    AddClientOnOpenFD(fd);
+}
+
+static void
+xserver_listen_socket(void *data, struct xserver *xserver, int fd)
+{
+    ListenOnOpenFD(fd, TRUE);
+}
+
+const struct xserver_listener xwl_server_listener = {
+    xserver_client,
+    xserver_listen_socket
+};
+
+static void
+xwl_input_delayed_init(void *data, struct wl_callback *callback, uint32_t time)
+{
+    struct xwl_screen *xwl_screen = data;
+
+    ErrorF("xwl_input_delayed_init\n");
+
+    wl_callback_destroy(callback);
+    xwl_input_init(xwl_screen);
+}
+
+static const struct wl_callback_listener delayed_init_listner = {
+	xwl_input_delayed_init
+};
+
+static void
+registry_global(void *data, struct wl_registry *registry, uint32_t id,
+	        const char *interface, uint32_t version)
+{
+    struct xwl_screen *xwl_screen = data;
+
+    if (strcmp (interface, "wl_compositor") == 0) {
+	xwl_screen->compositor =
+            wl_registry_bind(registry, id, &wl_compositor_interface, 1);
+    } else if (strcmp(interface, "wl_shm") == 0) {
+        xwl_screen->shm =
+            wl_registry_bind(registry, id, &wl_shm_interface, 1);
+    }
+}
+
+static const struct wl_registry_listener registry_listener = {
+    registry_global,
+};
+
+static void
+wakeup_handler(pointer data, int err, pointer read_mask)
+{
+    struct xwl_screen *xwl_screen = data;
+    int ret;
+
+    if (err < 0)
+        return;
+
+    if (!FD_ISSET(xwl_screen->wayland_fd, (fd_set *) read_mask))
+        return;
+
+    ret = wl_display_dispatch(xwl_screen->display);
+    if (ret == -1)
+        FatalError("failed to dispatch Wayland events: %s\n", strerror(errno));
+}
+
+static void
+block_handler(pointer data, struct timeval **tv, pointer read_mask)
+{
+    struct xwl_screen *xwl_screen = data;
+    int ret;
+
+    ret = wl_display_dispatch_pending(xwl_screen->display);
+    if (ret == -1)
+	FatalError("failed to dispatch Wayland events: %s\n", strerror(errno));
+
+    ret = wl_display_flush(xwl_screen->display);
+    if (ret == -1)
+        FatalError("failed to write to XWayland fd: %s\n", strerror(errno));
+}
+
+int
+xwl_screen_init(struct xwl_screen *xwl_screen, ScreenPtr screen)
+{
+    struct wl_callback *callback;
+
+    xwl_screen->screen = screen;
+
+    if (!dixRegisterPrivateKey(&xwl_screen_private_key, PRIVATE_SCREEN, 0))
+	return BadAlloc;
+
+    dixSetPrivate(&screen->devPrivates,
+		  &xwl_screen_private_key, xwl_screen);
+
+    xwl_screen_init_window(xwl_screen, screen);
+
+    xwl_screen_init_cursor(xwl_screen, screen);
+
+    AddGeneralSocket(xwl_screen->wayland_fd);
+    RegisterBlockAndWakeupHandlers(block_handler, wakeup_handler, xwl_screen);
+
+    callback = wl_display_sync(xwl_screen->display);
+    wl_callback_add_listener(callback, &delayed_init_listner, xwl_screen);
+
+    return Success;
+}
+
+struct xwl_screen *
+xwl_screen_get(ScreenPtr screen)
+{
+    return dixLookupPrivate(&screen->devPrivates, &xwl_screen_private_key);
+}
+
+static void
+xwayland_selection_callback(CallbackListPtr *callbacks,
+			    pointer data, pointer args)
+{
+    SelectionInfoRec *info = (SelectionInfoRec *) args;
+    Selection *selection = info->selection;
+
+    switch (info->kind) {
+    case SelectionSetOwner:
+	if (selection->selection == xdnd_atom) {
+	    if (selection->window != None)
+		ErrorF("client %p starts dnd\n", info->client);
+	    else
+		ErrorF("client %p stops dnd\n", info->client);
+	}
+	break;
+    case SelectionWindowDestroy:
+	ErrorF("selection window destroy\n");
+	break;
+    case SelectionClientClose:
+	ErrorF("selection client close\n");
+	break;
+    }
+}
+
+struct xwl_screen *
+xwl_screen_create(void)
+{
+    struct xwl_screen *xwl_screen;
+
+    xwl_screen = calloc(sizeof *xwl_screen, 1);
+    if (xwl_screen == NULL) {
+	ErrorF("calloc failed\n");
+	return NULL;
+    }
+
+    xwl_screen->display = wl_display_connect(NULL);
+    if (xwl_screen->display == NULL) {
+	ErrorF("wl_display_create failed\n");
+	return NULL;
+    }
+
+    return xwl_screen;
+}
+
+Bool
+xwl_screen_pre_init(ScrnInfoPtr scrninfo, struct xwl_screen *xwl_screen,
+		    uint32_t flags, struct xwl_driver *driver)
+{
+    int ret;
+
+    noScreenSaverExtension = TRUE;
+
+    xdnd_atom = MakeAtom("XdndSelection", 13, 1);
+    if (!AddCallback(&SelectionCallback,
+		     xwayland_selection_callback, xwl_screen)) {
+	return FALSE;
+    }
+
+    xorg_list_init(&xwl_screen->seat_list);
+    xorg_list_init(&xwl_screen->damage_window_list);
+    xorg_list_init(&xwl_screen->window_list);
+    xorg_list_init(&xwl_screen->authenticate_client_list);
+    xwl_screen->scrninfo = scrninfo;
+    xwl_screen->driver = driver;
+    xwl_screen->flags = flags;
+    xwl_screen->wayland_fd = wl_display_get_fd(xwl_screen->display);
+
+    if (xorgRootless)
+	xwl_screen->flags |= XWL_FLAGS_ROOTLESS;
+
+    /* Set up listener so we'll catch all events. */
+    xwl_screen->registry = wl_display_get_registry(xwl_screen->display);
+    wl_registry_add_listener(xwl_screen->registry, &registry_listener,
+                             xwl_screen);
+    ret = wl_display_roundtrip(xwl_screen->display);
+    if (ret == -1) {
+        xf86DrvMsg(scrninfo->scrnIndex, X_ERROR,
+                   "failed to dispatch Wayland events: %s\n", strerror(errno));
+        return FALSE;
+    }
+
+#ifdef WITH_LIBDRM
+    if (xwl_screen->driver->use_drm && !xwl_drm_initialised(xwl_screen))
+	if (xwl_drm_pre_init(xwl_screen) != Success)
+            return FALSE;
+#endif
+
+    xwayland_screen_preinit_output(xwl_screen, scrninfo);
+
+    return TRUE;
+}
+
+int
+xwl_create_window_buffer_shm(struct xwl_window *xwl_window,
+			     PixmapPtr pixmap, int fd)
+{
+    struct wl_shm_pool *pool;
+    int size, stride;
+
+    stride = pixmap->drawable.width * 4;
+
+    size = pixmap->drawable.width * pixmap->drawable.height * 4;
+    pool = wl_shm_create_pool(xwl_window->xwl_screen->shm, fd, size);
+    xwl_window->buffer =  wl_shm_pool_create_buffer(pool, 0,
+			   pixmap->drawable.width,
+			   pixmap->drawable.height,
+			   stride, WL_SHM_FORMAT_ARGB8888);
+    wl_shm_pool_destroy(pool);
+
+    return xwl_window->buffer ? Success : BadDrawable;
+}
+
+void xwl_screen_close(struct xwl_screen *xwl_screen)
+{
+    struct xwl_seat *xwl_seat, *itmp;
+    struct xwl_window *xwl_window, *wtmp;
+
+    if (xwl_screen->registry)
+        wl_registry_destroy(xwl_screen->registry);
+    xwl_screen->registry = NULL;
+
+    xorg_list_for_each_entry_safe(xwl_seat, itmp,
+				  &xwl_screen->seat_list, link) {
+	wl_seat_destroy(xwl_seat->seat);
+	free(xwl_seat);
+    }
+    xorg_list_for_each_entry_safe(xwl_window, wtmp,
+				  &xwl_screen->window_list, link) {
+	wl_buffer_destroy(xwl_window->buffer);
+	wl_surface_destroy(xwl_window->surface);
+	free(xwl_window);
+    }
+
+    xorg_list_init(&xwl_screen->seat_list);
+    xorg_list_init(&xwl_screen->damage_window_list);
+    xorg_list_init(&xwl_screen->window_list);
+    xorg_list_init(&xwl_screen->authenticate_client_list);
+
+    wl_display_roundtrip(xwl_screen->display);
+}
+
+void xwl_screen_destroy(struct xwl_screen *xwl_screen)
+{
+    if (xwl_screen->xwl_output) {
+	xf86OutputDestroy(xwl_screen->xwl_output->xf86output);
+	xf86CrtcDestroy(xwl_screen->xwl_output->xf86crtc);
+    }
+
+    free(xwl_screen->xwl_output);
+    free(xwl_screen);
+}
+
+/* DDX driver must call this after submitting the rendering */
+void xwl_screen_post_damage(struct xwl_screen *xwl_screen)
+{
+    struct xwl_window *xwl_window;
+    RegionPtr region;
+    BoxPtr box;
+    int count, i;
+
+    xorg_list_for_each_entry(xwl_window, &xwl_screen->damage_window_list,
+			     link_damage) {
+
+	region = DamageRegion(xwl_window->damage);
+	count = RegionNumRects(region);
+	for (i = 0; i < count; i++) {
+	    box = &RegionRects(region)[i];
+	    wl_surface_damage(xwl_window->surface,
+			      box->x1, box->y1,
+			      box->x2 - box->x1 + 1,
+			      box->y2 - box->y1 + 1);
+	}
+	wl_surface_attach(xwl_window->surface,
+			  xwl_window->buffer,
+			  0, 0);
+	wl_surface_commit(xwl_window->surface);
+	DamageEmpty(xwl_window->damage);
+    }
+
+    xorg_list_init(&xwl_screen->damage_window_list);
+}
+
+static pointer
+xwl_setup(pointer module, pointer opts, int *errmaj, int *errmin)
+{
+    return xwl_input_setup(module, opts, errmaj, errmin);
+}
+
+static void
+xwl_teardown(pointer p)
+{
+    xwl_input_teardown(p);
+}
+
+static XF86ModuleVersionInfo xwl_version_info = {
+    "xwayland",
+    MODULEVENDORSTRING,
+    MODINFOSTRING1,
+    MODINFOSTRING2,
+    XORG_VERSION_CURRENT,
+    1, 0, 0,
+    ABI_CLASS_EXTENSION,
+    ABI_EXTENSION_VERSION,
+    MOD_CLASS_NONE,
+    { 0, 0, 0, 0 }
+};
+
+_X_EXPORT const XF86ModuleData xwaylandModuleData = {
+    &xwl_version_info,
+    &xwl_setup,
+    &xwl_teardown
+};
+
+int
+xwl_version(void)
+{
+    return xwl_version_info.minorversion;
+}
diff --git a/hw/xfree86/xwayland/xwayland.h b/hw/xfree86/xwayland/xwayland.h
new file mode 100644
index 0000000..f268366
--- /dev/null
+++ b/hw/xfree86/xwayland/xwayland.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright © 2008 Kristian Høgsberg
+ *
+ * Permission to use, copy, modify, distribute, and sell this software
+ * and its documentation for any purpose is hereby granted without
+ * fee, provided that the above copyright notice appear in all copies
+ * and that both that copyright notice and this permission notice
+ * appear in supporting documentation, and that the name of the
+ * copyright holders not be used in advertising or publicity
+ * pertaining to distribution of the software without specific,
+ * written prior permission.  The copyright holders make no
+ * representations about the suitability of this software for any
+ * purpose.  It is provided "as is" without express or implied
+ * warranty.
+ *
+ * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
+ * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+ * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
+ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
+ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
+ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
+ * SOFTWARE.
+ */
+
+#ifndef _XWAYLAND_H_
+#define _XWAYLAND_H_
+
+#define XWL_VERSION 2
+
+struct xwl_window;
+struct xwl_screen;
+
+struct xwl_driver {
+    int version;
+    int use_drm;
+    int (*create_window_buffer)(struct xwl_window *xwl_window,
+                                PixmapPtr pixmap);
+};
+
+#define XWL_FLAGS_ROOTLESS 0x01
+
+extern _X_EXPORT int
+xwl_version(void);
+
+extern _X_EXPORT struct xwl_screen *
+xwl_screen_create(void);
+
+extern _X_EXPORT Bool
+xwl_screen_pre_init(ScrnInfoPtr scrninfo, struct xwl_screen *xwl_screen,
+		    uint32_t flags, struct xwl_driver *driver);
+
+extern _X_EXPORT int
+xwl_screen_init(struct xwl_screen *xwl_screen, ScreenPtr screen);
+
+extern _X_EXPORT int
+xwl_drm_pre_init(struct xwl_screen *xwl_screen);
+
+extern _X_EXPORT int
+xwl_screen_get_drm_fd(struct xwl_screen *xwl_screen);
+
+extern _X_EXPORT void
+xwl_screen_close(struct xwl_screen *xwl_screen);
+
+extern _X_EXPORT void
+xwl_screen_destroy(struct xwl_screen *xwl_screen);
+
+extern _X_EXPORT void
+xwl_screen_post_damage(struct xwl_screen *xwl_screen);
+
+extern _X_EXPORT int
+xwl_drm_authenticate(ClientPtr client, struct xwl_screen *xwl_screen,
+		     uint32_t magic);
+
+extern _X_EXPORT int
+xwl_create_window_buffer_drm(struct xwl_window *xwl_window,
+			     PixmapPtr pixmap, uint32_t name);
+
+extern _X_EXPORT int
+xwl_create_window_buffer_shm(struct xwl_window *xwl_window,
+			     PixmapPtr pixmap, int fd);
+
+#endif /* _XWAYLAND_H_ */
diff --git a/include/xorg-server.h.in b/include/xorg-server.h.in
index 81935be..2f9d27b 100644
--- a/include/xorg-server.h.in
+++ b/include/xorg-server.h.in
@@ -212,4 +212,7 @@
 #define _XSERVER64 1
 #endif
 
+/* Building Xorg server. */
+#undef XORG_WAYLAND
+
 #endif /* _XORG_SERVER_H_ */
-- 
1.8.3.1

