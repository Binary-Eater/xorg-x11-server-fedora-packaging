From df3b03e05b5c826584fc75466f404b53844edcf4 Mon Sep 17 00:00:00 2001
From: Chris Wilson <chris@chris-wilson.co.uk>
Date: Thu, 5 Feb 2015 14:11:40 -0500
Subject: [PATCH] present: Copy unflip contents back to the Screen Pixmap

As we unflip after the flip Window no longer passes the pixel ownership
test for the full Screen Pixmap, we can no longer utilize that Window to
copy the contents back to the backing pixmap. To first flip means that
the Window was originally backed by the Screen Pixmap and wholly covered
the Pixmap, thus we need to copy the last frame contents to the Screen
Pixmap when the flip chain is complete.

---
 present/present.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/present/present.c b/present/present.c
index 8e4829e..a516575 100644
--- a/present/present.c
+++ b/present/present.c
@@ -377,74 +377,74 @@ present_set_tree_pixmap(WindowPtr window, PixmapPtr pixmap)
 
     visit.old = (*screen->GetWindowPixmap)(window);
     visit.new = pixmap;
     if (visit.old == visit.new)
         return;
     TraverseTree(window, present_set_tree_pixmap_visit, &visit);
 }
 
 static void
 present_set_abort_flip(ScreenPtr screen)
 {
     present_screen_priv_ptr screen_priv = present_screen_priv(screen);
 
     /* Switch back to using the screen pixmap now to avoid
      * 2D applications drawing to the wrong pixmap.
      */
 
     if (screen_priv->flip_window)
         present_set_tree_pixmap(screen_priv->flip_window,
                                   (*screen->GetScreenPixmap)(screen));
 
     present_set_tree_pixmap(screen->root, (*screen->GetScreenPixmap)(screen));
 
     screen_priv->flip_pending->abort_flip = TRUE;
 }
 
 static void
 present_unflip(ScreenPtr screen)
 {
     present_screen_priv_ptr screen_priv = present_screen_priv(screen);
+    PixmapPtr pixmap = (*screen->GetScreenPixmap)(screen);
 
     assert (!screen_priv->unflip_event_id);
     assert (!screen_priv->flip_pending);
 
     if (screen_priv->flip_window)
-        present_set_tree_pixmap(screen_priv->flip_window,
-                                  (*screen->GetScreenPixmap)(screen));
+        present_set_tree_pixmap(screen_priv->flip_window, pixmap);
 
-    present_set_tree_pixmap(screen->root, (*screen->GetScreenPixmap)(screen));
+    present_set_tree_pixmap(screen->root, pixmap);
 
     /* Update the screen pixmap with the current flip pixmap contents
      */
     if (screen_priv->flip_pixmap && screen_priv->flip_window) {
-        present_copy_region(&screen_priv->flip_window->drawable,
+        present_copy_region(&pixmap->drawable,
                             screen_priv->flip_pixmap,
                             NULL, 0, 0);
     }
     screen_priv->unflip_event_id = ++present_event_id;
     DebugPresent(("u %lld\n", screen_priv->unflip_event_id));
     (*screen_priv->info->unflip) (screen, screen_priv->unflip_event_id);
 }
 
 static void
 present_flip_notify(present_vblank_ptr vblank, uint64_t ust, uint64_t crtc_msc)
 {
     ScreenPtr                   screen = vblank->screen;
     present_screen_priv_ptr     screen_priv = present_screen_priv(screen);
 
     DebugPresent(("\tn %lld %p %8lld: %08lx -> %08lx\n",
                   vblank->event_id, vblank, vblank->target_msc,
                   vblank->pixmap ? vblank->pixmap->drawable.id : 0,
                   vblank->window ? vblank->window->drawable.id : 0));
 
     assert (vblank == screen_priv->flip_pending);
 
     present_flip_idle(screen);
 
     xorg_list_del(&vblank->event_queue);
 
     /* Transfer reference for pixmap and fence from vblank to screen_priv */
     screen_priv->flip_crtc = vblank->crtc;
     screen_priv->flip_window = vblank->window;
     screen_priv->flip_serial = vblank->serial;
     screen_priv->flip_pixmap = vblank->pixmap;
-- 
2.1.0

