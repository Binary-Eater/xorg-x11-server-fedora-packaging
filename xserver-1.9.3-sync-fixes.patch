From 6576ada0f4aae8433dbda69b84dec886b13a6aef Mon Sep 17 00:00:00 2001
From: Adam Jackson <ajax@redhat.com>
Date: Mon, 20 Dec 2010 10:30:23 -0500
Subject: [PATCH] sync fixes

---
 Xext/sync.c |   30 ++++++++++++++++++++++++++++++
 1 files changed, 30 insertions(+), 0 deletions(-)

diff --git a/Xext/sync.c b/Xext/sync.c
index a51262a..314b63e 100644
--- a/Xext/sync.c
+++ b/Xext/sync.c
@@ -959,6 +959,17 @@ SyncComputeBracketValues(SyncCounter *pCounter)
 	    {
 		psci->bracket_less = pTrigger->test_value;
 		pnewltval = &psci->bracket_less;
+	    } else if (XSyncValueEqual(pCounter->value, pTrigger->test_value) &&
+		       XSyncValueLessThan(pTrigger->test_value,
+					  psci->bracket_greater))
+	    {
+	        /*
+		 * The value is exactly equal to our threshold.  We want one
+		 * more event in the positive direction to ensure we pick up
+		 * when the value *exceeds* this threshold.
+		 */
+	        psci->bracket_greater = pTrigger->test_value;
+		pnewgtval = &psci->bracket_greater;
 	    }
 	}
         else if (pTrigger->test_type == XSyncPositiveTransition &&
@@ -969,6 +980,17 @@ SyncComputeBracketValues(SyncCounter *pCounter)
 	    {
 		psci->bracket_greater = pTrigger->test_value;
 		pnewgtval = &psci->bracket_greater;
+	    } else if (XSyncValueEqual(pCounter->value, pTrigger->test_value) &&
+		       XSyncValueGreaterThan(pTrigger->test_value,
+					     psci->bracket_less))
+	    {
+	        /*
+		 * The value is exactly equal to our threshold.  We want one
+		 * more event in the negative direction to ensure we pick up
+		 * when the value is less than this threshold.
+		 */
+	        psci->bracket_less = pTrigger->test_value;
+		pnewltval = &psci->bracket_less;
 	    }
 	}
     } /* end for each trigger */
@@ -2300,6 +2322,14 @@ IdleTimeBlockHandler(pointer env, struct timeval **wt, pointer LastSelectMask)
 		break;
 	    }
 	}
+	/* 
+	 * We've been called exactly on the idle time, but we have a
+	 * NegativeTransition trigger which requires a transition from an
+	 * idle time greater than this.  Schedule a wakeup for the next
+	 * millisecond so we won't miss a transition.
+	 */
+	if (XSyncValueEqual (idle, *pIdleTimeValueLess))
+	    AdjustWaitForDelay(wt, 1);
     }
     else if (pIdleTimeValueGreater)
     {
-- 
1.7.3.2

